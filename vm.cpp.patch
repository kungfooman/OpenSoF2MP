--- a/codemp/qcommon/vm.cpp
+++ b/codemp/qcommon/vm.cpp
@@ -467,6 +467,8 @@ it will attempt to load as a system dll
 */
 
 #define	STACK_SIZE	0x20000
+#define LOCAL_POOL_SIZE 2048000
+static byte * dllLocalPool = 0;
 
 vm_t *VM_Create( const char *module, int (*systemCalls)(int *), 
 				vmInterpret_t interpret ) {
@@ -510,6 +512,11 @@ vm_t *VM_Create( const char *module, int (*systemCalls)(int *),
 		Com_Printf( "Loading dll file %s.\n", vm->name );
 		vm->dllHandle = Sys_LoadGameDll( module, &vm->entryPoint, VM_DllSyscall );
 		if ( vm->dllHandle ) {
+			// allocate memory for local allocs
+			vm->localPoolStart = 0;
+			vm->localPoolSize = 0;
+			vm->localPoolTail = LOCAL_POOL_SIZE;
+			dllLocalPool = (unsigned char *)VM_Alloc( LOCAL_POOL_SIZE );
 			return vm;
 		}
 
@@ -544,7 +551,10 @@ vm_t *VM_Create( const char *module, int (*systemCalls)(int *),
 
 	// round up to next power of 2 so all data operations can
 	// be mask protected
-	dataLength = header->dataLength + header->litLength + header->bssLength;
+	vm->localPoolStart = header->dataLength + header->litLength + header->bssLength;
+	vm->localPoolSize = 0;
+	vm->localPoolTail = LOCAL_POOL_SIZE;
+	dataLength = vm->localPoolStart + LOCAL_POOL_SIZE;
 	for ( i = 0 ; dataLength > ( 1 << i ) ; i++ ) {
 	}
 	dataLength = 1 << i;
@@ -597,6 +607,10 @@ VM_Free
 */
 void VM_Free( vm_t *vm ) {
 
+#ifdef _WIN32
+	VirtualFree(vm->codeBase, vm->codeLength, MEM_RELEASE);
+#endif
+
 	if ( vm->dllHandle ) {
 		Sys_UnloadDll( vm->dllHandle );
 		Com_Memset( vm, 0, sizeof( *vm ) );
@@ -669,6 +683,107 @@ void *BotVMShift( int ptr )
 	}
 }
 
+void *VM_Shift ( void * mem )
+{
+	//Alright, subtract the database from the memory pointer to get a memory address relative to the VM.
+	//When the VM modifies it it should be modifying the same chunk of memory we have allocated in the engine.
+	return (void*)((int)mem - (int)currentVM->dataBase);
+}
+
+/// Local pool allocation mirrored from BG_Local_Alloc and such
+void *VM_Local_Alloc ( int size )
+{
+	if (!currentVM)
+	{
+		assert(0);
+		return NULL;
+	}
+
+	currentVM->localPoolSize = ((currentVM->localPoolSize + 0x00000003) & 0xfffffffc);
+
+	if (currentVM->localPoolSize + size > currentVM->localPoolTail)
+	{
+		Com_Error( ERR_DROP, "VM_Local_Alloc: buffer exceeded tail (%d > %d)", currentVM->localPoolSize + size, currentVM->localPoolTail);
+		return 0;
+	}
+
+	currentVM->localPoolSize += size;
+	
+	byte * pool = currentVM->dataBase;
+	if (!currentVM->dataBase) {
+		pool = dllLocalPool;
+	}
+	return VM_Shift(&pool[currentVM->localPoolStart + currentVM->localPoolSize - size]);
+}
+
+void *VM_Local_AllocUnaligned ( int size )
+{
+	if (!currentVM)
+	{
+		assert(0);
+		return NULL;
+	}
+
+	if (currentVM->localPoolSize + size > currentVM->localPoolTail)
+	{
+		Com_Error( ERR_DROP, "VM_Local_AllocUnaligned: buffer exceeded tail (%d > %d)", currentVM->localPoolSize + size, currentVM->localPoolTail);
+		return 0;
+	}
+
+	currentVM->localPoolSize += size;
+
+	byte * pool = currentVM->dataBase;
+	if (!currentVM->dataBase) {
+		pool = dllLocalPool;
+	}
+	return VM_Shift(&pool[currentVM->localPoolStart + currentVM->localPoolSize-size]);
+}
+
+void *VM_Local_TempAlloc( int size )
+{
+	if (!currentVM)
+	{
+		assert(0);
+		return NULL;
+	}
+
+	size = ((size + 0x00000003) & 0xfffffffc);
+
+	if (currentVM->localPoolTail - size < currentVM->localPoolSize)
+	{
+		Com_Error( ERR_DROP, "VM_Local_TempAlloc: buffer exceeded head (%d > %d)", currentVM->localPoolTail - size, currentVM->localPoolSize);
+		return 0;
+	}
+
+	currentVM->localPoolTail -= size;
+
+	byte * pool = currentVM->dataBase;
+	if (!currentVM->dataBase) {
+		pool = dllLocalPool;
+	}
+	return VM_Shift(&pool[currentVM->localPoolStart + currentVM->localPoolTail]);
+}
+
+void VM_Local_TempFree( int size )
+{
+	size = ((size + 0x00000003) & 0xfffffffc);
+
+	if (currentVM->localPoolTail+size > LOCAL_POOL_SIZE)
+	{
+		Com_Error( ERR_DROP, "BG_TempFree: tail greater than size (%d > %d)", currentVM->localPoolTail+size, LOCAL_POOL_SIZE );
+	}
+
+	currentVM->localPoolTail += size;
+}
+
+char *VM_Local_StringAlloc ( const char *source )
+{
+	char *dest = (char*)VM_Local_Alloc( strlen ( source ) + 1 );
+	char *localDest = (char*)VM_ArgPtr((int)dest);
+	strcpy( localDest, source );
+	return dest;
+}
+
 void VM_Shifted_Alloc(void **ptr, int size)
 {
 	void *mem;
diff --git a/codemp/qcommon/vm_local.h b/codemp/qcommon/vm_local.h
index c8c9271..7c6eb67 100644
