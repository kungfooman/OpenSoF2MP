From 2ecc9ff397dc591db892430ac3556e30e851c0d8 Mon Sep 17 00:00:00 2001
From: Klaas Neirinck <klaas.neirinck@gmail.com>
Date: Thu, 25 Apr 2013 01:25:45 +0200
Subject: [PATCH] Base to get a somewhat working UI

Load the right ui/cgame/game qvm/dlls

Make the menu render correctly

Fix the keycodes

Fix another keycode

Fix text drawing in the menus

Don't crash when showing player models in the menu

Removed some JK/JA only code

Make the main part of the skins load decently

Fix the loading screen

Remove asian languages

Fix drawing of ingame console

Adjust the windows console to resemble the original SoF2 one

Make multiplayer animations work

Change README.md

Added progress url to README.md

Added newline to README.md

Make bolt-ons work again

Don't remove "_off" tail from surface names

Disable punkbuster

Make server listing work

Implement some game syscalls

Implement some cgame syscalls

Implement CG_AS_UPDATEAMBIENTSET and fix CG_G2_COPYSPECIFICGHOUL2MODEL

Implement CG_G2_GETBOLTINDEX and CG_UI_SETACTIVEMENU

Update todo statements

Fix some shader loading issues

Fix keybindings

Fix entityStateFields and playerStateFields

Fix snapshot and gamestate network code

Implement some CGAME syscalls and some fixes for model loading

Fix mouse look

Fix some sound cgame syscalls

Renamed engine project to SoF2MP

Fix cgame player model rendering

Fix entity number packing in the shader sorting

Fix some calls to the cgame vm

Fix some defines

Fix CG_FX_PLAY_BOLTED_EFFECT_ID

Fix gun models and implement BONE_ANIM_OVERRIDE_DEFAULT

Make reload work

Fix effects like shell ejection and fire and such

Remove unused struct

Fix QVM loading

Fix memory allocation inside the QVM for VM_LOCAL calls

Removed debug output

Fixed keybinds

Fix memory allocation inside dlls for VM_LOCAL calls

Activate mouse when asking for a password when connecting to a server

Fix font drawing and calculations in the menu.
This fixes kneirinck/OpenJK#2

Removed stringed implementations for translating certain ingame messages

Display talk and team talk correctly
This fixes kneirinck/OpenJK#7

Skip notification for chat messages (prefixed by @)

Implemented CG_UI_CLOSEALL

Fixed gore to actually load the shaders
This fixes kneirinck/OpenJK#3

Implement materials
This fixes kneirinck/OpenJK#6
This fixes kneirinck/OpenJK#5

Fix entity attached sounds
This fixes kneirinck/OpenSoF2MP#10

Fix blue first person guns
This fixes kneirinck/OpenSoF2MP#12

Fix a minor UI issue for drawing ingame menus

Fixed a wrong dereferenced double pointer
This fixes kneirinck/OpenSoF2MP#9

remove G2API_SetTime and G2API_GetTime

Fix bullet impacts after map restart and fall back to the default material if needed
This fixes kneirinck/OpenSoF2MP#16

Fix the walking speed
This fixes kneirinck/OpenSoF2MP#15

Remove unused TCG structs

Temporarily use CG_FX_PLAY_EFFECT_ID for the CG_FX_PLAY_BOLTED_EFFECT_ID implementation

Remove G2API_GetTime call

Fix SFxHelper::GetOriginAxisFromBolt

fix VS2017 compilation, s/abs/fabs

update solution to VS2017 with proper .gitignore

Update README.md

Update README.md
---
 README.md                                 |  117 +-
 codemp/.gitignore                         |  332 ++++
 codemp/OpenJK.sln                         |   33 +-
 codemp/{engine.vcxproj => SoF2MP.vcxproj} |   17 +-
 codemp/botlib/be_aas_entity.cpp           |    4 +-
 codemp/botlib/be_aas_move.cpp             |    2 +-
 codemp/botlib/be_aas_reach.cpp            |    8 +-
 codemp/botlib/be_ai_goal.cpp              |   55 +-
 codemp/botlib/be_ai_move.cpp              |    2 +-
 codemp/botlib/l_script.cpp                |    2 +-
 codemp/cgame/cg_draw.c                    |    4 +-
 codemp/cgame/cg_event.c                   |    4 +-
 codemp/cgame/cg_public.h                  |  383 ++---
 codemp/cgame/cg_servercmds.c              |   10 +-
 codemp/cgame/cgame.vcxproj                |    2 +
 codemp/cgame/cgame.vcxproj.filters        |   41 +-
 codemp/client/FxPrimitives.cpp            |   12 +-
 codemp/client/FxScheduler.cpp             |    4 +-
 codemp/client/FxSystem.cpp                |   18 +-
 codemp/client/FxSystem.h                  |   42 +-
 codemp/client/cl_cgame.cpp                |  881 +++-------
 codemp/client/cl_console.cpp              |  147 +-
 codemp/client/cl_input.cpp                |  822 +--------
 codemp/client/cl_keys.cpp                 |  693 +++-----
 codemp/client/cl_main.cpp                 |  194 +--
 codemp/client/cl_parse.cpp                |  119 +-
 codemp/client/cl_scrn.cpp                 |   46 +-
 codemp/client/cl_ui.cpp                   |  380 ++--
 codemp/client/client.h                    |   17 +-
 codemp/client/keys.h                      |    7 +-
 codemp/client/materials.cpp               |  208 +++
 codemp/client/materials.h                 |   10 +
 codemp/client/snd_dma.cpp                 |   60 +-
 codemp/client/snd_mix.cpp                 |    2 +-
 codemp/client/snd_public.h                |    6 +-
 codemp/dedicated.vcxproj                  |    5 +-
 codemp/game/anims.h                       | 1907 ++-------------------
 codemp/game/bg_public.h                   | 1343 ++++-----------
 codemp/game/bg_weapons.h                  |  382 ++++-
 codemp/game/g_main.c                      |   12 +-
 codemp/game/g_public.h                    |  258 +--
 codemp/game/g_syscalls.c                  |   56 +-
 codemp/game/g_xcvar.h                     |    2 +-
 codemp/game/game.vcxproj                  |    2 +
 codemp/game/surfaceflags.h                |    1 -
 codemp/ghoul2/G2.h                        |   18 +-
 codemp/ghoul2/G2_gore.h                   |    1 -
 codemp/ghoul2/ghoul2_shared.h             |   39 -
 codemp/icarus/GameInterface.cpp           |   28 +-
 codemp/icarus/Q3_Interface.cpp            |    8 +-
 codemp/icarus/Q3_Interface.h              |   13 -
 codemp/icarus/Q3_Registers.cpp            |   10 +-
 codemp/png/png.cpp                        |    2 +-
 codemp/qcommon/RoffSystem.cpp             |    8 +-
 codemp/qcommon/RoffSystem.h               |    2 +-
 codemp/qcommon/cm_shader.cpp              |    2 +-
 codemp/qcommon/common.cpp                 |   31 +-
 codemp/qcommon/cvar.cpp                   |   26 +-
 codemp/qcommon/files_common.cpp           |    4 +-
 codemp/qcommon/files_pc.cpp               |   27 +-
 codemp/qcommon/game_version.h             |   10 +-
 codemp/qcommon/msg.cpp                    | 1780 ++-----------------
 codemp/qcommon/q_shared.h                 | 1296 +++-----------
 codemp/qcommon/qcommon.h                  |   26 +-
 codemp/qcommon/stringed_ingame.cpp        | 1256 --------------
 codemp/qcommon/stringed_ingame.h          |  110 --
 codemp/qcommon/stringed_interface.cpp     |  215 ---
 codemp/qcommon/stringed_interface.h       |   21 -
 codemp/qcommon/vm.cpp                     |  117 +-
 codemp/qcommon/vm_local.h                 |    3 +
 codemp/qcommon/vm_x86.cpp                 |   13 +
 codemp/rd-dedicated/tr_image.cpp          |    6 +-
 codemp/rd-dedicated/tr_local.h            |    6 +-
 codemp/rd-vanilla/G2_API.cpp              |  231 ++-
 codemp/rd-vanilla/G2_bolts.cpp            |    2 +-
 codemp/rd-vanilla/G2_bones.cpp            |   30 +-
 codemp/rd-vanilla/G2_local.h              |   13 +-
 codemp/rd-vanilla/G2_misc.cpp             |   10 +-
 codemp/rd-vanilla/rd-vanilla.vcxproj      |    7 +-
 codemp/rd-vanilla/tr_WorldEffects.cpp     |   21 +-
 codemp/rd-vanilla/tr_backend.cpp          |   77 +-
 codemp/rd-vanilla/tr_bsp.cpp              |    2 +-
 codemp/rd-vanilla/tr_font.cpp             | 1408 +--------------
 codemp/rd-vanilla/tr_font.h               |    7 +-
 codemp/rd-vanilla/tr_ghoul2.cpp           |   84 +-
 codemp/rd-vanilla/tr_image.cpp            |  159 +-
 codemp/rd-vanilla/tr_init.cpp             |   39 +-
 codemp/rd-vanilla/tr_light.cpp            |   18 -
 codemp/rd-vanilla/tr_local.h              |   25 +-
 codemp/rd-vanilla/tr_main.cpp             |   22 +-
 codemp/rd-vanilla/tr_model.cpp            |   22 +-
 codemp/rd-vanilla/tr_scene.cpp            |   12 +-
 codemp/rd-vanilla/tr_shade.cpp            |   85 +-
 codemp/rd-vanilla/tr_shade_calc.cpp       |    7 +-
 codemp/rd-vanilla/tr_shader.cpp           |   92 +-
 codemp/rd-vanilla/tr_sky.cpp              |    4 +-
 codemp/rd-vanilla/tr_surface.cpp          |   32 +-
 codemp/rd-vanilla/tr_world.cpp            |    2 +-
 codemp/renderer/mdx_format.h              |    2 +-
 codemp/renderer/tr_public.h               |   21 +-
 codemp/renderer/tr_types.h                |  123 +-
 codemp/server/NPCNav/gameCallbacks.cpp    |    3 +-
 codemp/server/NPCNav/navigator.cpp        |    4 +-
 codemp/server/server.h                    |    7 -
 codemp/server/sv_ccmds.cpp                |  111 +-
 codemp/server/sv_client.cpp               |   21 +-
 codemp/server/sv_game.cpp                 |  174 +-
 codemp/server/sv_init.cpp                 |   19 +-
 codemp/server/sv_main.cpp                 |   19 +-
 codemp/server/sv_snapshot.cpp             |   90 -
 codemp/server/sv_world.cpp                |   20 +-
 codemp/ui/keycodes.h                      |  542 +++---
 codemp/ui/ui.vcxproj                      |    2 +
 codemp/ui/ui.vcxproj.filters              |   43 +-
 codemp/ui/ui_public.h                     |  249 +--
 codemp/win32/engine.rc                    |   10 +-
 codemp/win32/icon.ico                     |  Bin 3262 -> 2686 bytes
 codemp/win32/win_glimp.cpp                |   73 +-
 codemp/win32/win_input.cpp                |   62 +-
 codemp/win32/win_main.cpp                 |   25 +-
 codemp/win32/win_qgl.cpp                  |    4 +-
 codemp/win32/win_syscon.cpp               |   14 +-
 codemp/win32/win_wndproc.cpp              |  202 +--
 123 files changed, 4557 insertions(+), 13424 deletions(-)
 create mode 100644 codemp/.gitignore
 rename codemp/{engine.vcxproj => SoF2MP.vcxproj} (97%)
 create mode 100644 codemp/client/materials.cpp
 create mode 100644 codemp/client/materials.h
 delete mode 100644 codemp/qcommon/stringed_ingame.cpp
 delete mode 100644 codemp/qcommon/stringed_ingame.h
 delete mode 100644 codemp/qcommon/stringed_interface.cpp
 delete mode 100644 codemp/qcommon/stringed_interface.h

diff --git a/README.md b/README.md
index 5030df3..ed72100 100644
--- a/README.md
+++ b/README.md
@@ -1,79 +1,68 @@
-# SORRY FOR THE HISTORY CHANGES! #
+This engine is currently capable of:
+ - start a map e.g. via `map mp_shop` and play on it, but it crashes once you shoot a bullet (some netmsg crash)
+ - however, you can compile this ioquake3-sof2 engine https://github.com/sof2plus/sof2plus-engine and play on it nicely
+ 
+Current issues:
+ - `cg_thirdperson 1`, the player won't have a weapon in his hands: https://youtu.be/5Ec_ipUoRGs?t=344
+ - `alt+tab` doesn't work in `r_fullscreen 1`, so better use `r_fullscreen 0`
 
-For legal reasons we had to make changes to the history. This likely broke every forker's repo. See [here](http://git-scm.com/docs/git-rebase.html#_recovering_from_upstream_rebase) for how to fix if you've changed anything, or just delete your github fork and local folder and start over if you haven't.
+To compile sof2plus engine/game, just do:
+ 
+```
+mkdir ~/sof2plus
+cd ~/sof2plus
 
-# JACoders "OpenJK" project #
+git clone https://github.com/sof2plus/sof2plus-engine engine
+cd engine; make; cd ..
 
-IRC: irc.arloria.net / #JACoders
+git clone https://github.com/sof2plus/sof2plus-game game
+cd game; make; cd ..
 
-## Description ##
+# now we compiled all the needed binaries
 
-The purpose of this project is to maintain and improve the Jedi Academy and Jedi Outcast games, developed by Raven Software.
+# copy sof2plus executable in sof2plus directory
+cp engine/build/release-linux-x86_64/sof2plus.x86_64 .
 
-This project will not attempt to rebalance or otherwise modify core gameplay aspects.
+# you have to put all the original .pk3 files into this directory
+mkdir base
 
-Major contributors, in alphabetical order:
-* eezstreet
-* Ensiform
-* mrwonko
-* Raz0r
-* redsaurus
+# now copy all the .so files into base directory
+cp game/build/release-linux-x86_64/*.so base
 
-## Dependencies ##
-* OpenGL
-* OpenAL (included on Windows)
-* libpng (optional)
-* libjpeg (optional)
-* zlib (included on Windows)
+# start the server like:
+./sof2plus.x86_64 +set sv_pure 0 +rconPassword asd +devmap mp_shop
+```
 
-## Changelog ##
+If you want to run your SoF2 server permanently you can use `screen`:
 
-### Major Changes ###
-* The Jedi Academy singleplayer now searches for jagamex86.dll in the mod's folder, too, meaning SP Code mods are possible.
-* Increased Command Buffer from 16384 to 128*1024
-* Increased max cvars from 1224 to 2048
-* Removed unnecessary xbox code.
+```
+apt-get install screen
+screen -AmdS sof2
+screen -x sof2
+./sof2plus.x86_64 +set sv_pure 0 +rconPassword asd +devmap mp_shop
+# your terminal is inside the screen now, you can leave with hold-ctrl-key + a + d
+```
 
-### Minor Changes ###
-* Added mouse-wheel to console
-* Added misc security fixes to allow servers to deal with connectionless packets.
-* Added security fixes to prevent servers from spoofing clients with connect packets.
-* Added security fixes to prevent anyone from spoofing clients with print packets.
-* Compiles/runs with VS2012.
-* Fixed clients being able to set IP via cvar.
-* Fixed MiniHeapSize issue in SP
-* Fixed widescreen resolution changes causing black screen when UI restarted.
-* Fixed crash when trying to run custom resolutions with a local server.
-* Fixed crash related to ragnos NPC in MP
-* Fixed Gamma Clamp on WinXP+
-* Fixed buffer overflow in client side rcon command.
-* (Un)Pausing the MP game in solo play now results in smoother transition.
-* Tweaks to the cvar code to make it more strict in terms of read only/cheats/init.  Fixes a lot of broken rules with cvars.
-* Cheats are now defaulted to 1 in menu.  Do not be alarmed, starting normally will disable them or connecting to a non-cheat server. This allows cheats to work properly while playing back demos.
-* Fixed cvar commands that allow you to "cg_thirdPerson !" prevent you from typing out longer strings starting with a ! as the value.
-* Optimized MP shader loader.  This also fixes some cases where duplicate shaders that are wrong were being used.
-* Add fx_flashRadius (Defaults to 11) To set the size of FX flash radius. ("Rockets")  Set to 0 to disable completely.
-* Add sv_lanForceRate (Defaults to 1) Feature was already enabled, but not toggleable.
-* Timescale frametime fixes.  Frametime < 1 is no longer possible (bad things happen)
-* Tweaked globalservers master server command a bit for better verbosity.
-* Fixed a lot of formatting security holes.
-* Several Out-of-bounds memory access and memory leaks fixed.
-* Added fontlist command.  Useful for when making mods with custom fonts.
-* New serverside kick commands kickall kickallbots and kicknum (alias).
-* Improved command line parsing based off of ioquake3 patches.
-* Improved echo command by preserving colors based off of ioquake3 patches.
-* Improved GL_Extensions using ioquake3 to prevent crashes on newer cards.
-* Removed CD Check Code
-* Removed CD Key Code
-* Removed demo restriction code.
-* Removed Anti-Tamper Code.
-* Shift-Escape will now also open the console as an alternate (ie: keyboard doesn't support the normal console key)
-* Removed shift key requirement to open console
+Compiling of sof2plus (Ubuntu), test in OpenSoF2MP (Windows):
 
+[![video instruction](https://img.youtube.com/vi/5Ec_ipUoRGs/0.jpg)](https://www.youtube.com/watch?v=5Ec_ipUoRGs&hd=1)
 
-## Known Bugs ##
+Compile/build instructions:
+ - simply clone or download this repo
+ - open OpenSoF2MP\codemp\OpenJK.sln with Visual Studio
+ - right-click on SoF2MP project and fix the command line argument in the "Debugging" section
+    - e.g. to: `+set fs_basepath F:\sof2_gold +set sv_pure 0`
+ - just press F5 to run it
 
-* Missing Known Bugs list
+Suggested settings:
+ - `r_fullscreen 0`
+ - `r_customwidth 1900`
+ - `r_customheight 900`
+ - obviously fix the width/height to your desktop resolution, my is 1920x1080
+ - I suggest `r_fullscreen 0`, because alt+tab is buggy atm, you can't leave the window otherwise
+ - now just open console (tilde/grave key under ESC), to free the game-focus/mouse and use other stuff on desktop (or e.g. fix SoF2 window position on desktop)
+ 
+Old/original description of kneirinck:
 
-## Mod Developer Notes ##
-* If your mod intends to use engine "hax" to figure out the nedaddr types (NA_IP, etc) NA_BAD is now 0 and NA_BOT is now 1 instead of vice versa.
+Getting Soldier of Fortune 2 Multiplayer to work by using a heavily modified JK engine.  
+Progress can be found at [http://omgwtflol.rivercrew.net](http://omgwtflol.rivercrew.net).
diff --git a/codemp/.gitignore b/codemp/.gitignore
new file mode 100644
index 0000000..ba2d39a
--- /dev/null
+++ b/codemp/.gitignore
@@ -0,0 +1,332 @@
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+##
+## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore
+
+# User-specific files
+*.suo
+*.user
+*.userosscache
+*.sln.docstates
+
+# User-specific files (MonoDevelop/Xamarin Studio)
+*.userprefs
+
+# Build results
+[Dd]ebug/
+[Dd]ebugPublic/
+[Rr]elease/
+[Rr]eleases/
+x64/
+x86/
+bld/
+[Bb]in/
+[Oo]bj/
+[Ll]og/
+
+# Visual Studio 2015/2017 cache/options directory
+.vs/
+# Uncomment if you have tasks that create the project's static files in wwwroot
+#wwwroot/
+
+# Visual Studio 2017 auto generated files
+Generated\ Files/
+
+# MSTest test Results
+[Tt]est[Rr]esult*/
+[Bb]uild[Ll]og.*
+
+# NUNIT
+*.VisualState.xml
+TestResult.xml
+
+# Build Results of an ATL Project
+[Dd]ebugPS/
+[Rr]eleasePS/
+dlldata.c
+
+# Benchmark Results
+BenchmarkDotNet.Artifacts/
+
+# .NET Core
+project.lock.json
+project.fragment.lock.json
+artifacts/
+
+# StyleCop
+StyleCopReport.xml
+
+# Files built by Visual Studio
+*_i.c
+*_p.c
+*_i.h
+*.ilk
+*.meta
+*.obj
+*.iobj
+*.pch
+*.pdb
+*.ipdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.tmp_proj
+*.log
+*.vspscc
+*.vssscc
+.builds
+*.pidb
+*.svclog
+*.scc
+
+# Chutzpah Test files
+_Chutzpah*
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opendb
+*.opensdf
+*.sdf
+*.cachefile
+*.VC.db
+*.VC.VC.opendb
+
+# Visual Studio profiler
+*.psess
+*.vsp
+*.vspx
+*.sap
+
+# Visual Studio Trace Files
+*.e2e
+
+# TFS 2012 Local Workspace
+$tf/
+
+# Guidance Automation Toolkit
+*.gpState
+
+# ReSharper is a .NET coding add-in
+_ReSharper*/
+*.[Rr]e[Ss]harper
+*.DotSettings.user
+
+# JustCode is a .NET coding add-in
+.JustCode
+
+# TeamCity is a build add-in
+_TeamCity*
+
+# DotCover is a Code Coverage Tool
+*.dotCover
+
+# AxoCover is a Code Coverage Tool
+.axoCover/*
+!.axoCover/settings.json
+
+# Visual Studio code coverage results
+*.coverage
+*.coveragexml
+
+# NCrunch
+_NCrunch_*
+.*crunch*.local.xml
+nCrunchTemp_*
+
+# MightyMoose
+*.mm.*
+AutoTest.Net/
+
+# Web workbench (sass)
+.sass-cache/
+
+# Installshield output folder
+[Ee]xpress/
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish/
+
+# Publish Web Output
+*.[Pp]ublish.xml
+*.azurePubxml
+# Note: Comment the next line if you want to checkin your web deploy settings,
+# but database connection strings (with potential passwords) will be unencrypted
+*.pubxml
+*.publishproj
+
+# Microsoft Azure Web App publish settings. Comment the next line if you want to
+# checkin your Azure Web App publish settings, but sensitive information contained
+# in these scripts will be unencrypted
+PublishScripts/
+
+# NuGet Packages
+*.nupkg
+# The packages folder can be ignored because of Package Restore
+**/[Pp]ackages/*
+# except build/, which is used as an MSBuild target.
+!**/[Pp]ackages/build/
+# Uncomment if necessary however generally it will be regenerated when needed
+#!**/[Pp]ackages/repositories.config
+# NuGet v3's project.json files produces more ignorable files
+*.nuget.props
+*.nuget.targets
+
+# Microsoft Azure Build Output
+csx/
+*.build.csdef
+
+# Microsoft Azure Emulator
+ecf/
+rcf/
+
+# Windows Store app package directories and files
+AppPackages/
+BundleArtifacts/
+Package.StoreAssociation.xml
+_pkginfo.txt
+*.appx
+
+# Visual Studio cache files
+# files ending in .cache can be ignored
+*.[Cc]ache
+# but keep track of directories ending in .cache
+!*.[Cc]ache/
+
+# Others
+ClientBin/
+~$*
+*~
+*.dbmdl
+*.dbproj.schemaview
+*.jfm
+*.pfx
+*.publishsettings
+orleans.codegen.cs
+
+# Including strong name files can present a security risk
+# (https://github.com/github/gitignore/pull/2483#issue-259490424)
+#*.snk
+
+# Since there are multiple workflows, uncomment next line to ignore bower_components
+# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
+#bower_components/
+
+# RIA/Silverlight projects
+Generated_Code/
+
+# Backup & report files from converting an old project file
+# to a newer Visual Studio version. Backup files are not needed,
+# because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+UpgradeLog*.htm
+ServiceFabricBackup/
+*.rptproj.bak
+
+# SQL Server files
+*.mdf
+*.ldf
+*.ndf
+
+# Business Intelligence projects
+*.rdl.data
+*.bim.layout
+*.bim_*.settings
+*.rptproj.rsuser
+
+# Microsoft Fakes
+FakesAssemblies/
+
+# GhostDoc plugin setting file
+*.GhostDoc.xml
+
+# Node.js Tools for Visual Studio
+.ntvs_analysis.dat
+node_modules/
+
+# Visual Studio 6 build log
+*.plg
+
+# Visual Studio 6 workspace options file
+*.opt
+
+# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
+*.vbw
+
+# Visual Studio LightSwitch build output
+**/*.HTMLClient/GeneratedArtifacts
+**/*.DesktopClient/GeneratedArtifacts
+**/*.DesktopClient/ModelManifest.xml
+**/*.Server/GeneratedArtifacts
+**/*.Server/ModelManifest.xml
+_Pvt_Extensions
+
+# Paket dependency manager
+.paket/paket.exe
+paket-files/
+
+# FAKE - F# Make
+.fake/
+
+# JetBrains Rider
+.idea/
+*.sln.iml
+
+# CodeRush
+.cr/
+
+# Python Tools for Visual Studio (PTVS)
+__pycache__/
+*.pyc
+
+# Cake - Uncomment if you are using it
+# tools/**
+# !tools/packages.config
+
+# Tabs Studio
+*.tss
+
+# Telerik's JustMock configuration file
+*.jmconfig
+
+# BizTalk build output
+*.btp.cs
+*.btm.cs
+*.odx.cs
+*.xsd.cs
+
+# OpenCover UI analysis results
+OpenCover/
+
+# Azure Stream Analytics local run output
+ASALocalRun/
+
+# MSBuild Binary and Structured Log
+*.binlog
+
+# NVidia Nsight GPU debugger configuration file
+*.nvuser
+
+# MFractors (Xamarin productivity tool) working folder
+.mfractor/
+
+# Local History for Visual Studio
+.localhistory/
diff --git a/codemp/OpenJK.sln b/codemp/OpenJK.sln
index e3d396b..5c60ac6 100644
--- a/codemp/OpenJK.sln
+++ b/codemp/OpenJK.sln
@@ -1,14 +1,9 @@
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual Studio 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dedicated", "dedicated.vcxproj", "{D1AF49E8-2E0B-4CF8-858B-40D72A6C041B}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "engine", "engine.vcxproj", "{940CECBC-C6E6-DBE5-B493-0A64D54AFDF6}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ui", "ui\ui.vcxproj", "{2DDA2041-6A68-4754-B342-14039CC91695}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "cgame", "cgame\cgame.vcxproj", "{4DC69D68-9DB8-4DEB-AC63-481153B1F41D}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "jampgame", "game\game.vcxproj", "{5B587283-8429-4F8B-AECA-C09BF364B617}"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Express 2012 for Windows Desktop
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SoF2MP", "SoF2MP.vcxproj", "{940CECBC-C6E6-DBE5-B493-0A64D54AFDF6}"
+	ProjectSection(ProjectDependencies) = postProject
+		{518BD884-C233-4B86-ACEA-79534A3CEC01} = {518BD884-C233-4B86-ACEA-79534A3CEC01}
+	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "rd-vanilla", "rd-vanilla\rd-vanilla.vcxproj", "{518BD884-C233-4B86-ACEA-79534A3CEC01}"
 EndProject
@@ -18,26 +13,10 @@ Global
 		Release|Win32 = Release|Win32
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{D1AF49E8-2E0B-4CF8-858B-40D72A6C041B}.Debug|Win32.ActiveCfg = Debug|Win32
-		{D1AF49E8-2E0B-4CF8-858B-40D72A6C041B}.Debug|Win32.Build.0 = Debug|Win32
-		{D1AF49E8-2E0B-4CF8-858B-40D72A6C041B}.Release|Win32.ActiveCfg = Release|Win32
-		{D1AF49E8-2E0B-4CF8-858B-40D72A6C041B}.Release|Win32.Build.0 = Release|Win32
 		{940CECBC-C6E6-DBE5-B493-0A64D54AFDF6}.Debug|Win32.ActiveCfg = Debug|Win32
 		{940CECBC-C6E6-DBE5-B493-0A64D54AFDF6}.Debug|Win32.Build.0 = Debug|Win32
 		{940CECBC-C6E6-DBE5-B493-0A64D54AFDF6}.Release|Win32.ActiveCfg = Release|Win32
 		{940CECBC-C6E6-DBE5-B493-0A64D54AFDF6}.Release|Win32.Build.0 = Release|Win32
-		{2DDA2041-6A68-4754-B342-14039CC91695}.Debug|Win32.ActiveCfg = Debug|Win32
-		{2DDA2041-6A68-4754-B342-14039CC91695}.Debug|Win32.Build.0 = Debug|Win32
-		{2DDA2041-6A68-4754-B342-14039CC91695}.Release|Win32.ActiveCfg = Release|Win32
-		{2DDA2041-6A68-4754-B342-14039CC91695}.Release|Win32.Build.0 = Release|Win32
-		{4DC69D68-9DB8-4DEB-AC63-481153B1F41D}.Debug|Win32.ActiveCfg = Debug|Win32
-		{4DC69D68-9DB8-4DEB-AC63-481153B1F41D}.Debug|Win32.Build.0 = Debug|Win32
-		{4DC69D68-9DB8-4DEB-AC63-481153B1F41D}.Release|Win32.ActiveCfg = Release|Win32
-		{4DC69D68-9DB8-4DEB-AC63-481153B1F41D}.Release|Win32.Build.0 = Release|Win32
-		{5B587283-8429-4F8B-AECA-C09BF364B617}.Debug|Win32.ActiveCfg = Debug|Win32
-		{5B587283-8429-4F8B-AECA-C09BF364B617}.Debug|Win32.Build.0 = Debug|Win32
-		{5B587283-8429-4F8B-AECA-C09BF364B617}.Release|Win32.ActiveCfg = Release|Win32
-		{5B587283-8429-4F8B-AECA-C09BF364B617}.Release|Win32.Build.0 = Release|Win32
 		{518BD884-C233-4B86-ACEA-79534A3CEC01}.Debug|Win32.ActiveCfg = Debug|Win32
 		{518BD884-C233-4B86-ACEA-79534A3CEC01}.Debug|Win32.Build.0 = Debug|Win32
 		{518BD884-C233-4B86-ACEA-79534A3CEC01}.Release|Win32.ActiveCfg = Release|Win32
diff --git a/codemp/engine.vcxproj b/codemp/SoF2MP.vcxproj
similarity index 97%
rename from codemp/engine.vcxproj
rename to codemp/SoF2MP.vcxproj
index 55e4969..dc8cc04 100644
--- a/codemp/engine.vcxproj
+++ b/codemp/SoF2MP.vcxproj
@@ -1,5 +1,5 @@
 ï»¿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug|Win32">
       <Configuration>Debug</Configuration>
@@ -11,17 +11,20 @@
     </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
-    <ProjectName>engine</ProjectName>
+    <ProjectName>SoF2MP</ProjectName>
     <ProjectGuid>{940CECBC-C6E6-DBE5-B493-0A64D54AFDF6}</ProjectGuid>
+    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
+    <PlatformToolset>v141</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
+    <PlatformToolset>v141</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
@@ -35,7 +38,7 @@
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup>
     <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\build\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\build\$(Configuration)\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">.build\$(Configuration)\$(Platform)\$(ProjectName)\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\build\</OutDir>
@@ -145,6 +148,7 @@
     </ResourceCompile>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClInclude Include="client\materials.h" />
     <ClInclude Include="game\anims.h" />
     <ClInclude Include="game\bg_weapons.h" />
     <ClInclude Include="game\botlib.h" />
@@ -185,8 +189,6 @@
     <ClInclude Include="qcommon\qcommon.h" />
     <ClInclude Include="qcommon\qfiles.h" />
     <ClInclude Include="qcommon\sstring.h" />
-    <ClInclude Include="qcommon\stringed_ingame.h" />
-    <ClInclude Include="qcommon\stringed_interface.h" />
     <ClInclude Include="game\surfaceflags.h" />
     <ClInclude Include="qcommon\tags.h" />
     <ClInclude Include="qcommon\timing.h" />
@@ -322,6 +324,7 @@
     <ClCompile Include="client\cl_parse.cpp" />
     <ClCompile Include="client\cl_scrn.cpp" />
     <ClCompile Include="client\cl_ui.cpp" />
+    <ClCompile Include="client\materials.cpp" />
     <ClCompile Include="qcommon\CNetProfile.cpp" />
     <ClCompile Include="qcommon\GenericParser2.cpp" />
     <ClCompile Include="qcommon\RoffSystem.cpp" />
@@ -350,8 +353,6 @@
     <ClCompile Include="qcommon\net_chan.cpp" />
     <ClCompile Include="qcommon\q_math.cpp" />
     <ClCompile Include="qcommon\q_shared.cpp" />
-    <ClCompile Include="qcommon\stringed_ingame.cpp" />
-    <ClCompile Include="qcommon\stringed_interface.cpp" />
     <ClCompile Include="qcommon\unzip.cpp" />
     <ClCompile Include="qcommon\vm.cpp" />
     <ClCompile Include="qcommon\vm_interpreted.cpp" />
@@ -374,7 +375,6 @@
     <ClCompile Include="server\sv_snapshot.cpp" />
     <ClCompile Include="server\sv_world.cpp" />
     <ClCompile Include="server\NPCNav\gameCallbacks.cpp" />
-    <ClCompile Include="server\NPCNav\navigator.cpp" />
     <ClCompile Include="client\snd_ambient.cpp" />
     <ClCompile Include="client\snd_dma.cpp" />
     <ClCompile Include="client\snd_mem.cpp" />
@@ -463,7 +463,6 @@
     <ClCompile Include="icarus\Instance.cpp" />
     <ClCompile Include="icarus\Interface.cpp" />
     <ClCompile Include="icarus\Memory.cpp" />
-    <ClCompile Include="icarus\Q3_Interface.cpp" />
     <ClCompile Include="icarus\Q3_Registers.cpp" />
     <ClCompile Include="icarus\Sequence.cpp" />
     <ClCompile Include="icarus\Sequencer.cpp" />
diff --git a/codemp/botlib/be_aas_entity.cpp b/codemp/botlib/be_aas_entity.cpp
index d3681ce..b9e34af 100644
--- a/codemp/botlib/be_aas_entity.cpp
+++ b/codemp/botlib/be_aas_entity.cpp
@@ -373,9 +373,9 @@ int AAS_NearestEntity(vec3_t origin, int modelindex)
 		ent = &aasworld.entities[i];
 		if (ent->i.modelindex != modelindex) continue;
 		VectorSubtract(ent->i.origin, origin, dir);
-		if (abs(dir[0]) < 40)
+		if (fabs(dir[0]) < 40)
 		{
-			if (abs(dir[1]) < 40)
+			if (fabs(dir[1]) < 40)
 			{
 				dist = VectorLength(dir);
 				if (dist < bestdist)
diff --git a/codemp/botlib/be_aas_move.cpp b/codemp/botlib/be_aas_move.cpp
index 87e9770..f78a4b5 100644
--- a/codemp/botlib/be_aas_move.cpp
+++ b/codemp/botlib/be_aas_move.cpp
@@ -151,7 +151,7 @@ int AAS_AgainstLadder(vec3_t origin)
 		//get the plane the face is in
 		plane = &aasworld.planes[face->planenum ^ side];
 		//if the origin is pretty close to the plane
-		if (abs(DotProduct(plane->normal, origin) - plane->dist) < 3)
+		if (fabs(DotProduct(plane->normal, origin) - plane->dist) < 3)
 		{
 			if (AAS_PointInsideFace(abs(facenum), origin, 0.1f)) return qtrue;
 		} //end if
diff --git a/codemp/botlib/be_aas_reach.cpp b/codemp/botlib/be_aas_reach.cpp
index caf7173..d8ad5bc 100644
--- a/codemp/botlib/be_aas_reach.cpp
+++ b/codemp/botlib/be_aas_reach.cpp
@@ -2448,8 +2448,8 @@ int AAS_Reachability_Ladder(int area1num, int area2num)
 		VectorMA(area1point, -32, dir, area1point);
 		VectorMA(area2point, 32, dir, area2point);
 		//
-		ladderface1vertical = abs(DotProduct(plane1->normal, up)) < 0.1;
-		ladderface2vertical = abs(DotProduct(plane2->normal, up)) < 0.1;
+		ladderface1vertical = fabs(DotProduct(plane1->normal, up)) < 0.1;
+		ladderface2vertical = fabs(DotProduct(plane2->normal, up)) < 0.1;
 		//there's only reachability between vertical ladder faces
 		if (!ladderface1vertical && !ladderface2vertical) return qfalse;
 		//if both vertical ladder faces
@@ -2457,7 +2457,7 @@ int AAS_Reachability_Ladder(int area1num, int area2num)
 					//and the ladder faces do not make a sharp corner
 					&& DotProduct(plane1->normal, plane2->normal) > 0.7
 					//and the shared edge is not too vertical
-					&& abs(DotProduct(sharededgevec, up)) < 0.7)
+					&& fabs(DotProduct(sharededgevec, up)) < 0.7)
 		{
 			//create a new reachability link
 			lreach = AAS_AllocReachability();
@@ -2582,7 +2582,7 @@ int AAS_Reachability_Ladder(int area1num, int area2num)
 				if (face2->faceflags & FACE_LADDER)
 				{
 					plane2 = &aasworld.planes[face2->planenum];
-					if (abs(DotProduct(plane2->normal, up)) < 0.1) break;
+					if (fabs(DotProduct(plane2->normal, up)) < 0.1) break;
 				} //end if
 			} //end for
 			//if from another area without vertical ladder faces
diff --git a/codemp/botlib/be_ai_goal.cpp b/codemp/botlib/be_ai_goal.cpp
index 660c3c8..2cc92f6 100644
--- a/codemp/botlib/be_ai_goal.cpp
+++ b/codemp/botlib/be_ai_goal.cpp
@@ -71,25 +71,6 @@ typedef struct campspot_s
 	struct campspot_s *next;
 } campspot_t;
 
-//FIXME: these are game specific
-typedef enum {
-	GT_FFA,				// free for all
-	GT_HOLOCRON,		// holocron match
-	GT_JEDIMASTER,		// jedi master
-	GT_DUEL,		// one on one tournament
-	GT_POWERDUEL,
-	GT_SINGLE_PLAYER,	// single player tournament
-
-	//-- team games go after this --
-
-	GT_TEAM,			// team deathmatch
-	GT_SIEGE,			// siege
-	GT_CTF,				// capture the flag
-	GT_CTY,
-	GT_MAX_GAME_TYPE
-};
-typedef int gametype_t;
-
 typedef struct levelitem_s
 {
 	int number;							//number of the level item
@@ -858,16 +839,13 @@ int BotGetLevelItemGoal(int index, char *name, bot_goal_t *goal)
 	} //end for
 	for (; li; li = li->next)
 	{
-		//
-		if (g_gametype == GT_SINGLE_PLAYER) {
-			if (li->flags & IFL_NOTSINGLE) continue;
-		}
-		else if (g_gametype >= GT_TEAM) {
+		//SOF2 TODO
+		/*if (g_gametype >= GT_TEAM) {
 			if (li->flags & IFL_NOTTEAM) continue;
 		}
 		else {
 			if (li->flags & IFL_NOTFREE) continue;
-		}
+		}*/
 		if (li->flags & IFL_NOTBOT) continue;
 		//
 		if (!Q_stricmp(name, itemconfig->iteminfo[li->iteminfo].name))
@@ -1069,16 +1047,13 @@ void BotUpdateEntityItems(void)
 		{
 			//if this level item is already linked
 			if (li->entitynum) continue;
-			//
-			if (g_gametype == GT_SINGLE_PLAYER) {
-				if (li->flags & IFL_NOTSINGLE) continue;
-			}
-			else if (g_gametype >= GT_TEAM) {
+			//SOF2 TODO
+			/*if (g_gametype >= GT_TEAM) {
 				if (li->flags & IFL_NOTTEAM) continue;
 			}
 			else {
 				if (li->flags & IFL_NOTFREE) continue;
-			}
+			}*/
 			//if the model of the level item and the entity are the same
 			if (ic->iteminfo[li->iteminfo].modelindex == modelindex)
 			{
@@ -1303,18 +1278,15 @@ int BotChooseLTGItem(int goalstate, vec3_t origin, int *inventory, int travelfla
 	//go through the items in the level
 	for (li = levelitems; li; li = li->next)
 	{
-		if (g_gametype == GT_SINGLE_PLAYER) {
-			if (li->flags & IFL_NOTSINGLE)
-				continue;
-		}
-		else if (g_gametype >= GT_TEAM) {
+		//SOF2 TODO
+		/*if (g_gametype >= GT_TEAM) {
 			if (li->flags & IFL_NOTTEAM)
 				continue;
 		}
 		else {
 			if (li->flags & IFL_NOTFREE)
 				continue;
-		}
+		}*/
 		if (li->flags & IFL_NOTBOT)
 			continue;
 		//if the item is not in a possible goal area
@@ -1474,18 +1446,15 @@ int BotChooseNBGItem(int goalstate, vec3_t origin, int *inventory, int travelfla
 	//go through the items in the level
 	for (li = levelitems; li; li = li->next)
 	{
-		if (g_gametype == GT_SINGLE_PLAYER) {
-			if (li->flags & IFL_NOTSINGLE)
-				continue;
-		}
-		else if (g_gametype >= GT_TEAM) {
+		//SOF2 TODO
+		/*if (g_gametype >= GT_TEAM) {
 			if (li->flags & IFL_NOTTEAM)
 				continue;
 		}
 		else {
 			if (li->flags & IFL_NOTFREE)
 				continue;
-		}
+		}*/
 		if (li->flags & IFL_NOTBOT)
 			continue;
 		//if the item is in a possible goal area
diff --git a/codemp/botlib/be_ai_move.cpp b/codemp/botlib/be_ai_move.cpp
index 29c7d9c..e925d65 100644
--- a/codemp/botlib/be_ai_move.cpp
+++ b/codemp/botlib/be_ai_move.cpp
@@ -2039,7 +2039,7 @@ bot_moveresult_t BotTravel_Elevator(bot_movestate_t *ms, aas_reachability_t *rea
 		botimport.Print(PRT_MESSAGE, "bot on elevator\n");
 #endif //DEBUG_ELEVATOR
 		//if vertically not too far from the end point
-		if (abs(ms->origin[2] - reach->end[2]) < sv_maxbarrier->value)
+		if (fabs(ms->origin[2] - reach->end[2]) < sv_maxbarrier->value)
 		{
 #ifdef DEBUG_ELEVATOR
 			botimport.Print(PRT_MESSAGE, "bot moving to end\n");
diff --git a/codemp/botlib/l_script.cpp b/codemp/botlib/l_script.cpp
index 7d772eb..acbad71 100644
--- a/codemp/botlib/l_script.cpp
+++ b/codemp/botlib/l_script.cpp
@@ -526,7 +526,7 @@ int PS_ReadName(script_t *script, token_t *token)
    } while ((c >= 'a' && c <= 'z') ||
 				(c >= 'A' && c <= 'Z') ||
 				(c >= '0' && c <= '9') ||
-				c == '_');
+				c == '_' || c == '/');
 	token->string[len] = '\0';
 	//the sub type is the length of the name
 	token->subtype = len;
diff --git a/codemp/cgame/cg_draw.c b/codemp/cgame/cg_draw.c
index 7438e3d..317fa62 100644
--- a/codemp/cgame/cg_draw.c
+++ b/codemp/cgame/cg_draw.c
@@ -4287,7 +4287,7 @@ void CG_DrawSiegeMessage( const char *str, int objectiveScreen )
 {
 //	if (!( trap_Key_GetCatcher() & KEYCATCH_UI ))
 	{
-		trap_OpenUIMenu(UIMENU_CLOSEALL);
+		/*trap_OpenUIMenu(UIMENU_CLOSEALL);
 		trap_Cvar_Set("cg_siegeMessage", str);
 		if (objectiveScreen)
 		{
@@ -4296,7 +4296,7 @@ void CG_DrawSiegeMessage( const char *str, int objectiveScreen )
 		else
 		{
 			trap_OpenUIMenu(UIMENU_SIEGEMESSAGE);
-		}
+		}*/
 	}
 }
 
diff --git a/codemp/cgame/cg_event.c b/codemp/cgame/cg_event.c
index 29cbbe4..15b5144 100644
--- a/codemp/cgame/cg_event.c
+++ b/codemp/cgame/cg_event.c
@@ -2874,10 +2874,10 @@ void CG_EntityEvent( centity_t *cent, vec3_t position ) {
 
 			trap_Cvar_Set("ui_myteam", va("%i", es->bolt2));
 
-			if (!( trap_Key_GetCatcher() & KEYCATCH_UI ) && !es->bolt1)
+			/*if (!( trap_Key_GetCatcher() & KEYCATCH_UI ) && !es->bolt1)
 			{
 				trap_OpenUIMenu(UIMENU_PLAYERCONFIG);
-			}
+			}*/
 		}
 		break;
 
diff --git a/codemp/cgame/cg_public.h b/codemp/cgame/cg_public.h
index 44e85bb..0bafb6f 100644
--- a/codemp/cgame/cg_public.h
+++ b/codemp/cgame/cg_public.h
@@ -26,7 +26,6 @@ typedef struct {
 	byte			areamask[MAX_MAP_AREA_BYTES];		// portalarea visibility bits
 
 	playerState_t	ps;						// complete information about the current player at this time
-	playerState_t	vps; //vehicle I'm riding's playerstate (if applicable) -rww
 
 	int				numEntities;			// all of the entities that need to be presented
 	entityState_t	entities[MAX_ENTITIES_IN_SNAPSHOT];	// at the time of this snapshot
@@ -54,19 +53,13 @@ functions imported from the main executable
 #define	CGAME_IMPORT_API_VERSION	5
 
 typedef enum {
-	CG_PRINT = 0,
+	CG_PRINT,
 	CG_ERROR,
 	CG_MILLISECONDS,
-
-	//Also for profiling.. do not use for game related tasks.
-	CG_PRECISIONTIMER_START,
-	CG_PRECISIONTIMER_END,
-
 	CG_CVAR_REGISTER,
 	CG_CVAR_UPDATE,
 	CG_CVAR_SET,
 	CG_CVAR_VARIABLESTRINGBUFFER,
-	CG_CVAR_GETHIDDENVALUE,
 	CG_ARGC,
 	CG_ARGV,
 	CG_ARGS,
@@ -77,105 +70,55 @@ typedef enum {
 	CG_FS_GETFILELIST,
 	CG_SENDCONSOLECOMMAND,
 	CG_ADDCOMMAND,
-	CG_REMOVECOMMAND,
 	CG_SENDCLIENTCOMMAND,
 	CG_UPDATESCREEN,
+	CG_RMG_INIT,
 	CG_CM_LOADMAP,
 	CG_CM_NUMINLINEMODELS,
 	CG_CM_INLINEMODEL,
+	CG_CM_LOADMODEL,
 	CG_CM_TEMPBOXMODEL,
-	CG_CM_TEMPCAPSULEMODEL,
 	CG_CM_POINTCONTENTS,
 	CG_CM_TRANSFORMEDPOINTCONTENTS,
 	CG_CM_BOXTRACE,
-	CG_CM_CAPSULETRACE,
 	CG_CM_TRANSFORMEDBOXTRACE,
-	CG_CM_TRANSFORMEDCAPSULETRACE,
 	CG_CM_MARKFRAGMENTS,
-	CG_S_GETVOICEVOLUME,
-	CG_S_MUTESOUND,
 	CG_S_STARTSOUND,
+	CG_S_STOPALLSOUNDS,
 	CG_S_STARTLOCALSOUND,
 	CG_S_CLEARLOOPINGSOUNDS,
 	CG_S_ADDLOOPINGSOUND,
 	CG_S_UPDATEENTITYPOSITION,
-	CG_S_ADDREALLOOPINGSOUND,
-	CG_S_STOPLOOPINGSOUND,
 	CG_S_RESPATIALIZE,
-	CG_S_SHUTUP,
 	CG_S_REGISTERSOUND,
 	CG_S_STARTBACKGROUNDTRACK,
-
-	//rww - AS trap implem
-	CG_S_UPDATEAMBIENTSET,
-	CG_AS_PARSESETS,
 	CG_AS_ADDPRECACHEENTRY,
-	CG_S_ADDLOCALSET,
+	CG_AS_PARSESETS,
+	CG_AS_UPDATEAMBIENTSET,
+	CG_AS_ADDLOCALSET,
 	CG_AS_GETBMODELSOUND,
-
 	CG_R_LOADWORLDMAP,
 	CG_R_REGISTERMODEL,
 	CG_R_REGISTERSKIN,
 	CG_R_REGISTERSHADER,
-	CG_R_REGISTERSHADERNOMIP,
-	CG_R_REGISTERFONT,
-	CG_R_FONT_STRLENPIXELS,
-	CG_R_FONT_STRLENCHARS,
-	CG_R_FONT_STRHEIGHTPIXELS,
-	CG_R_FONT_DRAWSTRING,
-	CG_LANGUAGE_ISASIAN,
-	CG_LANGUAGE_USESSPACES,
-	CG_ANYLANGUAGE_READCHARFROMSTRING,
-
-	CGAME_MEMSET = 100,
-	CGAME_MEMCPY,
-	CGAME_STRNCPY,
-	CGAME_SIN,
-	CGAME_COS,
-	CGAME_ATAN2,
-	CGAME_SQRT,
-	CGAME_MATRIXMULTIPLY,
-	CGAME_ANGLEVECTORS,
-	CGAME_PERPENDICULARVECTOR,
-	CGAME_FLOOR,
-	CGAME_CEIL,
-
-	CGAME_TESTPRINTINT,
-	CGAME_TESTPRINTFLOAT,
-
-	CGAME_ACOS,
-	CGAME_ASIN,
-
-	CG_R_CLEARSCENE = 200,
+	CG_R_CLEARSCENE,
 	CG_R_CLEARDECALS,
 	CG_R_ADDREFENTITYTOSCENE,
 	CG_R_ADDPOLYTOSCENE,
-	CG_R_ADDPOLYSTOSCENE,
 	CG_R_ADDDECALTOSCENE,
-	CG_R_LIGHTFORPOINT,
 	CG_R_ADDLIGHTTOSCENE,
-	CG_R_ADDADDITIVELIGHTTOSCENE,
 	CG_R_RENDERSCENE,
+	CG_R_DRAWVISUALOVERLAY,
 	CG_R_SETCOLOR,
 	CG_R_DRAWSTRETCHPIC,
 	CG_R_MODELBOUNDS,
 	CG_R_LERPTAG,
 	CG_R_DRAWROTATEPIC,
 	CG_R_DRAWROTATEPIC2,
-	CG_R_SETRANGEFOG, //linear fogging, with settable range -rww
-	CG_R_SETREFRACTIONPROP, //set some properties for the draw layer for my refractive effect (here primarily for mod authors) -rww
-	CG_R_REMAP_SHADER,
-	CG_R_GET_LIGHT_STYLE,
-	CG_R_SET_LIGHT_STYLE,
-	CG_R_GET_BMODEL_VERTS,
-	CG_R_GETDISTANCECULL,
-
-	CG_R_GETREALRES,
-	CG_R_AUTOMAPELEVADJ,
-	CG_R_INITWIREFRAMEAUTO,
-
-	CG_FX_ADDLINE,
-
+	CG_R_DRAWTEXT,
+	CG_R_DRAWTEXTWITHCURSOR,
+	CG_R_GETTEXTWIDTH,
+	CG_R_GETTEXTHEIGHT,
 	CG_GETGLCONFIG,
 	CG_GETGAMESTATE,
 	CG_GETCURRENTSNAPSHOTNUMBER,
@@ -185,17 +128,15 @@ typedef enum {
 	CG_GETCURRENTCMDNUMBER,
 	CG_GETUSERCMD,
 	CG_SETUSERCMDVALUE,
-	CG_SETCLIENTFORCEANGLE,
-	CG_SETCLIENTTURNEXTENT,
-	CG_OPENUIMENU,
-	CG_TESTPRINTINT,
-	CG_TESTPRINTFLOAT,
+	CG_RW_SETTEAM,
+	CG_RESETAUTORUN,
+	CG_R_REGISTERSHADERNOMIP,
 	CG_MEMORY_REMAINING,
+	CG_R_REGISTERFONT,
 	CG_KEY_ISDOWN,
 	CG_KEY_GETCATCHER,
 	CG_KEY_SETCATCHER,
 	CG_KEY_GETKEY,
-
  	CG_PC_ADD_GLOBAL_DEFINE,
 	CG_PC_LOAD_SOURCE,
 	CG_PC_FREE_SOURCE,
@@ -204,140 +145,165 @@ typedef enum {
 	CG_PC_LOAD_GLOBAL_DEFINES,
 	CG_PC_REMOVE_ALL_GLOBAL_DEFINES,
 
+	CG_MEMSET = 100,
+	CG_MEMCPY,
+	CG_STRNCPY,
+	CG_SIN,
+	CG_COS,
+	CG_ATAN2,
+	CG_SQRT,
+	CG_ANGLEVECTORS,
+	CG_PERPENDICULARVECTOR,
+	CG_FLOOR,
+	CG_CEIL,
+	CG_TESTPRINTINT,
+	CG_TESTPRINTFLOAT,
+	CG_ACOS,
+	CG_ASIN,
+	CG_MATRIXMULTIPLY,
+
+	
+	CG_SP_GETSTRINGTEXTSTRING,
+
 	CG_S_STOPBACKGROUNDTRACK,
 	CG_REAL_TIME,
 	CG_SNAPVECTOR,
+	CG_REMOVECOMMAND,
+	CG_R_LIGHTFORPOINT,
 	CG_CIN_PLAYCINEMATIC,
 	CG_CIN_STOPCINEMATIC,
 	CG_CIN_RUNCINEMATIC,
 	CG_CIN_DRAWCINEMATIC,
 	CG_CIN_SETEXTENTS,
+	CG_R_REMAP_SHADER,
+	CG_R_GET_LIGHT_STYLE,
+	CG_R_SET_LIGHT_STYLE,
+	CG_FX_ADDLINE,
+	CG_S_ADDREALLOOPINGSOUND,
+	CG_S_STOPLOOPINGSOUND,
 
+	CG_CM_TEMPCAPSULEMODEL,
+	CG_CM_CAPSULETRACE,
+	CG_CM_TRANSFORMEDCAPSULETRACE,
+	CG_R_ADDADDITIVELIGHTTOSCENE,
 	CG_GET_ENTITY_TOKEN,
+	CG_R_ADDPOLYSTOSCENE,
 	CG_R_INPVS,
 
 	CG_FX_REGISTER_EFFECT,
+	CG_FX_PLAY_SIMPLE_EFFECT,
 	CG_FX_PLAY_EFFECT,
 	CG_FX_PLAY_ENTITY_EFFECT,
+	CG_FX_PLAY_SIMPLE_EFFECT_ID,
 	CG_FX_PLAY_EFFECT_ID,
-	CG_FX_PLAY_PORTAL_EFFECT_ID,
 	CG_FX_PLAY_ENTITY_EFFECT_ID,
 	CG_FX_PLAY_BOLTED_EFFECT_ID,
 	CG_FX_ADD_SCHEDULED_EFFECTS,
 	CG_FX_INIT_SYSTEM,
-	CG_FX_SET_REFDEF,
 	CG_FX_FREE_SYSTEM,
 	CG_FX_ADJUST_TIME,
 	CG_FX_DRAW_2D_EFFECTS,
 	CG_FX_RESET,
-	CG_FX_ADDPOLY,
-	CG_FX_ADDBEZIER,
-	CG_FX_ADDPRIMITIVE,
-	CG_FX_ADDSPRITE,
-	CG_FX_ADDELECTRICITY,
-
-//	CG_SP_PRINT,
-	CG_SP_GETSTRINGTEXTSTRING,
-
-	CG_ROFF_CLEAN,
-	CG_ROFF_UPDATE_ENTITIES,
-	CG_ROFF_CACHE,
-	CG_ROFF_PLAY,
-	CG_ROFF_PURGE_ENT,
 
+	CG_G2_LISTBONES,
+	CG_G2_LISTSURFACES,
 
-	//rww - dynamic vm memory allocation!
-	CG_TRUEMALLOC,
-	CG_TRUEFREE,
+	CG_G2_ADDBOLT,
+	CG_G2_SETBOLTON,
+	CG_G2_REMOVEBOLT,
+	CG_G2_ATTACHG2MODEL,
+	CG_G2_DETACHG2MODEL,
 
-/*
-Ghoul2 Insert Start
-*/
-	CG_G2_LISTSURFACES,
-	CG_G2_LISTBONES,
-	CG_G2_SETMODELS,
 	CG_G2_HAVEWEGHOULMODELS,
+	CG_G2_SETMODELS,
 	CG_G2_GETBOLT,
-	CG_G2_GETBOLT_NOREC,
-	CG_G2_GETBOLT_NOREC_NOROT,
 	CG_G2_INITGHOUL2MODEL,
-	CG_G2_SETSKIN,
-	CG_G2_COLLISIONDETECT,
-	CG_G2_COLLISIONDETECTCACHE,
 	CG_G2_CLEANMODELS,
 	CG_G2_ANGLEOVERRIDE,
 	CG_G2_PLAYANIM,
-	CG_G2_GETBONEANIM,
-	CG_G2_GETBONEFRAME, //trimmed down version of GBA, so I don't have to pass all those unused args across the VM-exe border
+	CG_G2_GETANIM,
+	CG_G2_SETSURFACEONOFF,
+	CG_G2_SETROOTSURFACE,
+	CG_G2_SETNEWORIGIN,
 	CG_G2_GETGLANAME,
 	CG_G2_COPYGHOUL2INSTANCE,
 	CG_G2_COPYSPECIFICGHOUL2MODEL,
 	CG_G2_DUPLICATEGHOUL2INSTANCE,
-	CG_G2_HASGHOUL2MODELONINDEX,
 	CG_G2_REMOVEGHOUL2MODEL,
-	CG_G2_SKINLESSMODEL,
-	CG_G2_GETNUMGOREMARKS,
 	CG_G2_ADDSKINGORE,
 	CG_G2_CLEARSKINGORE,
-	CG_G2_SIZE,
-	CG_G2_ADDBOLT,
-	CG_G2_ATTACHENT,
-	CG_G2_SETBOLTON,
-	CG_G2_SETROOTSURFACE,
-	CG_G2_SETSURFACEONOFF,
-	CG_G2_SETNEWORIGIN,
-	CG_G2_DOESBONEEXIST,
-	CG_G2_GETSURFACERENDERSTATUS,
-
-	CG_G2_GETTIME,
-	CG_G2_SETTIME,
-
-	CG_G2_ABSURDSMOOTHING,
-
-/*
-	//rww - RAGDOLL_BEGIN
-*/
-	CG_G2_SETRAGDOLL,
-	CG_G2_ANIMATEG2MODELS,
-/*
-	//rww - RAGDOLL_END
-*/
-
-	//additional ragdoll options -rww
-	CG_G2_RAGPCJCONSTRAINT,
-	CG_G2_RAGPCJGRADIENTSPEED,
-	CG_G2_RAGEFFECTORGOAL,
-	CG_G2_GETRAGBONEPOS,
-	CG_G2_RAGEFFECTORKICK,
-	CG_G2_RAGFORCESOLVE,
-
-	//rww - ik move method, allows you to specify a bone and move it to a world point (within joint constraints)
-	//by using the majority of gil's existing bone angling stuff from the ragdoll code.
-	CG_G2_SETBONEIKSTATE,
-	CG_G2_IKMOVE,
-
-	CG_G2_REMOVEBONE,
+	CG_G2_SETGHOUL2MODELFLAGS,
+	CG_G2_GETGHOUL2MODELFLAGS,
+	CG_G2_SETGHOUL2MODELFLAGSBYINDEX,
+	CG_G2_GETGHOUL2MODELFLAGSBYINDEX,
+	CG_G2_GETNUMMODELS,
+	CG_G2_GETANIMFILENAMEINDEX,
+	CG_G2_FINDBOLTINDEX,
+	CG_G2_GETBOLTINDEX,
+
+	CG_G2_REGISTERSKIN,
+	CG_G2_SETSKIN,
+	CG_G2_COLLISIONDETECT,
 
-	CG_G2_ATTACHINSTANCETOENTNUM,
-	CG_G2_CLEARATTACHEDINSTANCE,
-	CG_G2_CLEANENTATTACHMENTS,
-	CG_G2_OVERRIDESERVER,
+	CG_MAT_RESET,
+	CG_MAT_CACHE,
+	CG_MAT_GET_SOUND,
+	CG_MAT_GET_DECAL,
+	CG_MAT_GET_DECAL_SCALE,
+	CG_MAT_GET_EFFECT,
+	CG_MAT_GET_DEBRIS,
+	CG_MAT_GET_DEBRIS_SCALE,
+
+	CG_CM_TM_CREATE,
+	CG_CM_TM_ADDBUILDING,
+	CG_CM_TM_ADDSPOT,
+	CG_CM_TM_ADDTARGET,
+	CG_CM_TM_UPLOAD,
+	CG_CM_TM_CONVERT_POS,
+
+	// CGenericParser2 (void *) routines
+	GP_PARSE,
+	GP_PARSE_FILE,
+	GP_CLEAN,
+	GP_DELETE,
+	GP_GET_BASE_PARSE_GROUP,
+
+	// CGPGroup (void *) routines
+	GPG_GET_NAME,
+	GPG_GET_NEXT,
+	GPG_GET_INORDER_NEXT,
+	GPG_GET_INORDER_PREVIOUS,
+	GPG_GET_PAIRS,
+	GPG_GET_INORDER_PAIRS,
+	GPG_GET_SUBGROUPS,
+	GPG_GET_INORDER_SUBGROUPS,
+	GPG_FIND_SUBGROUP,
+	GPG_FIND_PAIR,
+	GPG_FIND_PAIRVALUE,
+
+	// CGPValue (void *) routines
+	GPV_GET_NAME,
+	GPV_GET_NEXT,
+	GPV_GET_INORDER_NEXT,
+	GPV_GET_INORDER_PREVIOUS,
+	GPV_IS_LIST,
+	GPV_GET_TOP_VALUE,
+	GPV_GET_LIST,
 
-	CG_G2_GETSURFACENAME,
+	CG_CM_REGISTER_TERRAIN,
+	CG_RE_INIT_RENDERER_TERRAIN,
 
 	CG_SET_SHARED_BUFFER,
 
-	CG_CM_REGISTER_TERRAIN,
-	CG_RMG_INIT,
-	CG_RE_INIT_RENDERER_TERRAIN,
-	CG_R_WEATHER_CONTENTS_OVERRIDE,
-	CG_R_WORLDEFFECTCOMMAND,
-	//Adding trap to get weather working
-	CG_WE_ADDWEATHERZONE
+	CG_VM_LOCALALLOC,
+	CG_VM_LOCALALLOCUNALIGNED,
+	CG_VM_LOCALTEMPALLOC,
+	CG_VM_LOCALTEMPFREE,
+	CG_VM_LOCALSTRINGALLOC,
+	
+	CG_UI_SETACTIVEMENU,
+	CG_UI_CLOSEALL,
 
-/*
-Ghoul2 Insert End
-*/
 } cgameImport_t;
 
 
@@ -395,7 +361,8 @@ typedef enum {
 	CG_GET_LERP_ORIGIN,
 //	void CG_LerpOrigin(int num, vec3_t result);
 
-	CG_GET_LERP_DATA,
+	CG_GET_LERP_ANGLES,
+	CG_GET_MODEL_SCALE,
 	CG_GET_GHOUL2,
 	CG_GET_MODEL_LIST,
 
@@ -403,17 +370,6 @@ typedef enum {
 //	void CG_CalcEntityLerpPositions(int num);
 
 	CG_TRACE,
-	CG_G2TRACE,
-//void CG_Trace( trace_t *result, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, 
-//					 int skipNumber, int mask );
-
-	CG_G2MARK,
-
-	CG_RAG_CALLBACK,
-
-	CG_INCOMING_CONSOLE_COMMAND,
-
-	CG_GET_USEABLE_FORCE,
 
 	CG_GET_ORIGIN,		// int entnum, vec3_t origin
 	CG_GET_ANGLES,		// int entnum, vec3_t angle
@@ -421,33 +377,18 @@ typedef enum {
 	CG_GET_ORIGIN_TRAJECTORY,		// int entnum
 	CG_GET_ANGLE_TRAJECTORY,		// int entnum
 
-	CG_ROFF_NOTETRACK_CALLBACK,		// int entnum, char *notetrack
+	CG_FX_CAMERASHAKE,
 
-	CG_IMPACT_MARK,
-//void CG_ImpactMark( qhandle_t markShader, const vec3_t origin, const vec3_t dir, 
-//				   float orientation, float red, float green, float blue, float alpha,
-//				   qboolean alphaFade, float radius, qboolean temporary )
+	CG_MISC_ENT, //rwwRMG - added
 
 	CG_MAP_CHANGE,
 
-	CG_AUTOMAP_INPUT,
-
-	CG_MISC_ENT, //rwwRMG - added
-
-	CG_GET_SORTED_FORCE_POWER,
+	CG_VOICE_EVENT,
 
-	CG_FX_CAMERASHAKE,//mcg post-gold added
+	CG_GET_TEAM_COUNT,
+	CG_GET_TEAM_SCORE,
 } cgameExport_t;
 
-typedef struct
-{
-	float		up;
-	float		down;
-	float		yaw;
-	float		pitch;
-	qboolean	goToDefaults;
-} autoMapInput_t;
-
 // CG_POINT_CONTENTS
 typedef struct
 {
@@ -455,29 +396,6 @@ typedef struct
 	int			mPassEntityNum;	// input
 } TCGPointContents;
 
-// CG_GET_BOLT_POS
-typedef struct
-{
-	vec3_t		mOrigin;		// output
-	vec3_t		mAngles;		// output
-	vec3_t		mScale;			// output
-	int			mEntityNum;		// input
-} TCGGetBoltData;
-
-// CG_IMPACT_MARK
-typedef struct
-{
-	int		mHandle;
-	vec3_t	mPoint;
-	vec3_t	mAngle;
-	float	mRotation;
-	float	mRed;
-	float	mGreen;
-	float	mBlue;
-	float	mAlphaStart;
-	float	mSizeStart;
-} TCGImpactMark;
-
 // CG_GET_LERP_ORIGIN
 // CG_GET_LERP_ANGLES
 // CG_GET_MODEL_SCALE
@@ -495,20 +413,6 @@ typedef struct
 	int		mSkipNumber, mMask;			// input
 } TCGTrace;
 
-// CG_G2MARK
-typedef struct
-{
-	int			shader;
-	float		size;
-	vec3_t		start, dir;
-} TCGG2Mark;
-
-// CG_INCOMING_CONSOLE_COMMAND
-typedef struct
-{
-	char conCommand[1024];
-} TCGIncomingConsoleCommand;
-
 // CG_FX_CAMERASHAKE
 typedef struct
 {
@@ -525,16 +429,13 @@ typedef struct
 	vec3_t	mOrigin, mAngles, mScale;	// input
 } TCGMiscEnt;
 
+/// CG_CM_TM_CONVERT_POS
 typedef struct
 {
-	refEntity_t		ent;				// output
-	void			*ghoul2;			// input
-	int				modelIndex;			// input
-	int				boltIndex;			// input
-	vec3_t			origin;				// input
-	vec3_t			angles;				// input
-	vec3_t			modelScale;			// input
-} TCGPositionOnBolt;
+	vec3_t	mOrigin;					// input
+	int		mWidth, mHeight;			// input
+	int		mX, mY;						// output
+} TCGConvertPos;
 
 //ragdoll callback structs -rww
 #define RAG_CALLBACK_NONE				0
diff --git a/codemp/cgame/cg_servercmds.c b/codemp/cgame/cg_servercmds.c
index 1f7aa7e..bbdc5cf 100644
--- a/codemp/cgame/cg_servercmds.c
+++ b/codemp/cgame/cg_servercmds.c
@@ -1354,16 +1354,16 @@ static void CG_ServerCommand( void ) {
 	{
 		//if (!( trap_Key_GetCatcher() & KEYCATCH_UI ))
 		//Well, I want it to come up even if the briefing display is up.
-		{
+		/*{
 			trap_OpenUIMenu(UIMENU_CLASSSEL); //UIMENU_CLASSSEL
-		}
+		}*/
 		return;
 	}
 
 	if ( !strcmp( cmd, "spc" ) )
 	{
 		trap_Cvar_Set("ui_myteam", "3");
-		trap_OpenUIMenu(UIMENU_PLAYERCONFIG); //UIMENU_CLASSSEL
+		//trap_OpenUIMenu(UIMENU_PLAYERCONFIG); //UIMENU_CLASSSEL
 		return;
 	}
 
@@ -1389,10 +1389,10 @@ static void CG_ServerCommand( void ) {
 
 		trap_Cvar_Set("ui_myteam", va("%i", setTeam));
 
-		if (!( trap_Key_GetCatcher() & KEYCATCH_UI ) && doMenu)
+		/*if (!( trap_Key_GetCatcher() & KEYCATCH_UI ) && doMenu)
 		{
 			trap_OpenUIMenu(UIMENU_PLAYERCONFIG);
-		}
+		}*/
 
 		return;
 	}
diff --git a/codemp/cgame/cgame.vcxproj b/codemp/cgame/cgame.vcxproj
index bc83a03..1f1bee5 100644
--- a/codemp/cgame/cgame.vcxproj
+++ b/codemp/cgame/cgame.vcxproj
@@ -18,10 +18,12 @@
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
+    <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
+    <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
diff --git a/codemp/cgame/cgame.vcxproj.filters b/codemp/cgame/cgame.vcxproj.filters
index 31243bc..e646c59 100644
--- a/codemp/cgame/cgame.vcxproj.filters
+++ b/codemp/cgame/cgame.vcxproj.filters
@@ -152,12 +152,6 @@
     <ClCompile Include="fx_rocketlauncher.c">
       <Filter>Source Files</Filter>
     </ClCompile>
-    <ClCompile Include="..\game\q_math.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\game\q_shared.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
     <ClCompile Include="..\game\SpeederNPC.c">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -170,6 +164,12 @@
     <ClCompile Include="cg_spawn.c">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\qcommon\q_math.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\qcommon\q_shared.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\game\anims.h">
@@ -202,15 +202,9 @@
     <ClInclude Include="cg_public.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\shared\qcommon\disablewarnings.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
     <ClInclude Include="fx_local.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\shared\Ghoul2\G2.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
     <ClInclude Include="holocronicons.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -220,32 +214,33 @@
     <ClInclude Include="..\ui\menudef.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\game\q_shared.h">
+    <ClInclude Include="..\game\surfaceflags.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\shared\qcommon\qfiles.h">
+    <ClInclude Include="tr_types.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\game\surfaceflags.h">
+    <ClInclude Include="..\ui\ui_shared.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\shared\qcommon\tags.h">
+    <ClInclude Include="cg_xcvar.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="tr_types.h">
+    <ClInclude Include="..\qcommon\disablewarnings.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\ui\ui_shared.h">
+    <ClInclude Include="..\ghoul2\G2.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="cg_xcvar.h">
+    <ClInclude Include="..\qcommon\q_shared.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="cgame.def">
+    <ClInclude Include="..\qcommon\qfiles.h">
       <Filter>Header Files</Filter>
-    </None>
+    </ClInclude>
+    <ClInclude Include="..\qcommon\tags.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="..\win32\cgame.rc">
diff --git a/codemp/client/FxPrimitives.cpp b/codemp/client/FxPrimitives.cpp
index 0d9865e..38acda1 100644
--- a/codemp/client/FxPrimitives.cpp
+++ b/codemp/client/FxPrimitives.cpp
@@ -252,25 +252,25 @@ bool CParticle::UpdateOrigin(void)
 
 			if ( mFlags & FX_USE_BBOX )
 			{
-				if (mFlags & FX_GHOUL2_TRACE)
+				/*if (mFlags & FX_GHOUL2_TRACE)
 				{
 					theFxHelper.G2Trace( trace, mOrigin1, mMin, mMax, new_origin, -1, MASK_SOLID );
 				}
 				else
-				{
+				{*/
 					theFxHelper.Trace( trace, mOrigin1, mMin, mMax, new_origin, -1, MASK_SOLID );
-				}
+				//}
 			}
 			else
 			{
-				if (mFlags & FX_GHOUL2_TRACE)
+				/*if (mFlags & FX_GHOUL2_TRACE)
 				{
 					theFxHelper.G2Trace( trace, mOrigin1, NULL, NULL, new_origin, -1, MASK_PLAYERSOLID );
 				}
 				else
-				{
+				{*/
 					theFxHelper.Trace( trace, mOrigin1, NULL, NULL, new_origin, -1, MASK_SOLID );
-				}
+				//}
 			}
 
 			// Hit something
diff --git a/codemp/client/FxScheduler.cpp b/codemp/client/FxScheduler.cpp
index bffd37f..66bb302 100644
--- a/codemp/client/FxScheduler.cpp
+++ b/codemp/client/FxScheduler.cpp
@@ -1649,10 +1649,10 @@ void CFxScheduler::CreateEffect( CPrimitiveTemplate *fx, const vec3_t origin, ve
 
 		theFxHelper.AddDecalToScene ( fx->mMediaHandles.GetHandle(), org, ax[0], fx->mRotation.GetVal(), sRGB[0], sRGB[1], sRGB[2], fx->mAlphaStart.GetVal(), qtrue, fx->mSizeStart.GetVal(), qfalse );
 
-		if (fx->mFlags & FX_GHOUL2_DECALS)
+		/*if (fx->mFlags & FX_GHOUL2_DECALS)
 		{
 			theFxHelper.AddGhoul2Decal(fx->mMediaHandles.GetHandle(), org, ax[0], fx->mSizeStart.GetVal());
-		}
+		}*/
 
 		break;
 
diff --git a/codemp/client/FxSystem.cpp b/codemp/client/FxSystem.cpp
index 2eac708..b22586e 100644
--- a/codemp/client/FxSystem.cpp
+++ b/codemp/client/FxSystem.cpp
@@ -99,15 +99,25 @@ qboolean SFxHelper::GetOriginAxisFromBolt(CGhoul2Info_v *pGhoul2, int mEntNum, i
 {
 	qboolean doesBoltExist;
 	mdxaBone_t 		boltMatrix;
-	TCGGetBoltData	*data = (TCGGetBoltData*)cl.mSharedMemory;
+
+	TCGVectorData *data = (TCGVectorData*)cl.mSharedMemory;
 	data->mEntityNum = mEntNum;
-	VM_Call( cgvm, CG_GET_LERP_DATA );//this func will zero out pitch and roll for players, and ridable vehicles
 
-	//Fixme: optimize these VM calls away by storing 
+	VM_Call(cgvm, CG_GET_LERP_ANGLES);
+	vec3_t lerpAngles;
+	VectorCopy(data->mPoint, lerpAngles);
+
+	VM_Call(cgvm, CG_GET_LERP_ORIGIN);
+	vec3_t lerpOrigin;
+	VectorCopy(data->mPoint, lerpOrigin);
+
+	VM_Call(cgvm, CG_GET_MODEL_SCALE);
+	vec3_t modelScale;
+	VectorCopy(data->mPoint, modelScale);
 
 	// go away and get me the bolt position for this frame please
 	doesBoltExist = re.G2API_GetBoltMatrix(*pGhoul2, modelNum, boltNum, 
-		&boltMatrix, data->mAngles, data->mOrigin, theFxHelper.mOldTime, 0, data->mScale);
+		&boltMatrix, lerpAngles, lerpOrigin, theFxHelper.mOldTime, 0, modelScale);
 
 	if (doesBoltExist)
 	{	// set up the axis and origin we need for the actual effect spawning
diff --git a/codemp/client/FxSystem.h b/codemp/client/FxSystem.h
index 6a11885..b56c794 100644
--- a/codemp/client/FxSystem.h
+++ b/codemp/client/FxSystem.h
@@ -90,8 +90,7 @@ public:
 	// Sound
 	inline	void	PlaySound( vec3_t origin, int entityNum, int entchannel, sfxHandle_t sfxHandle, int volume, int radius )
 	{
-		//S_StartSound( origin, ENTITYNUM_NONE, CHAN_AUTO, sfxHandle, volume, radius );
-		S_StartSound( origin, ENTITYNUM_NONE, CHAN_AUTO, sfxHandle );
+		S_StartSound( origin, ENTITYNUM_NONE, CHAN_AUTO, sfxHandle, volume, radius );
 	}
 	inline	void	PlayLocalSound(sfxHandle_t sfxHandle, int entchannel)
 	{
@@ -131,45 +130,6 @@ public:
 		tr = td->mResult;
 	}
 
-	inline	void	G2Trace( trace_t &tr, vec3_t start, vec3_t min, vec3_t max, vec3_t end, int skipEntNum, int flags )
-	{
-		TCGTrace		*td = (TCGTrace *)cl.mSharedMemory;
-
-		if ( !min )
-		{
-			min = vec3_origin;
-		}
-
-		if ( !max )
-		{
-			max = vec3_origin;
-		}
-
-		memset(td, sizeof(*td), 0);
-		VectorCopy(start, td->mStart);
-		VectorCopy(min, td->mMins);
-		VectorCopy(max, td->mMaxs);
-		VectorCopy(end, td->mEnd);
-		td->mSkipNumber = skipEntNum;
-		td->mMask = flags;
-
-		VM_Call( cgvm, CG_G2TRACE );
-
-		tr = td->mResult;
-	}
-
-	inline	void	AddGhoul2Decal(int shader, vec3_t start, vec3_t dir, float size)
-	{
-		TCGG2Mark		*td = (TCGG2Mark *)cl.mSharedMemory;
-
-		td->size = size;
-		td->shader = shader;
-		VectorCopy(start, td->start);
-		VectorCopy(dir, td->dir);
-
-		VM_Call(cgvm, CG_G2MARK);
-	}
-
 	inline	void	AddFxToScene( refEntity_t *ent )
 	{
 #ifdef _DEBUG
diff --git a/codemp/client/cl_cgame.cpp b/codemp/client/cl_cgame.cpp
index ed10e15..f910993 100644
--- a/codemp/client/cl_cgame.cpp
+++ b/codemp/client/cl_cgame.cpp
@@ -38,8 +38,6 @@ Ghoul2 Insert Start
 	#include "ghoul2/G2_local.h"
 #endif
 
-#include "qcommon/stringed_ingame.h"
-
 #include "ghoul2/G2_gore.h"
 
 extern CMiniHeap *G2VertSpaceClient;
@@ -48,6 +46,8 @@ extern CMiniHeap *G2VertSpaceClient;
 
 #include "qcommon/timing.h"
 
+#include "materials.h"
+
 //#include "renderer/tr_local.h"
 
 //extern int contentOverride;
@@ -117,27 +117,6 @@ int CL_GetCurrentCmdNumber( void ) {
 }
 
 
-/*
-====================
-CL_GetParseEntityState
-====================
-*/
-qboolean	CL_GetParseEntityState( int parseEntityNumber, entityState_t *state ) {
-	// can't return anything that hasn't been parsed yet
-	if ( parseEntityNumber >= cl.parseEntitiesNum ) {
-		Com_Error( ERR_DROP, "CL_GetParseEntityState: %i >= %i",
-			parseEntityNumber, cl.parseEntitiesNum );
-	}
-
-	// can't return anything that has been overwritten in the circular buffer
-	if ( parseEntityNumber <= cl.parseEntitiesNum - MAX_PARSE_ENTITIES ) {
-		return qfalse;
-	}
-
-	*state = cl.parseEntities[ parseEntityNumber & ( MAX_PARSE_ENTITIES - 1 ) ];
-	return qtrue;
-}
-
 /*
 ====================
 CL_GetCurrentSnapshotNumber
@@ -185,7 +164,6 @@ qboolean	CL_GetSnapshot( int snapshotNumber, snapshot_t *snapshot ) {
 	snapshot->serverTime = clSnap->serverTime;
 	Com_Memcpy( snapshot->areamask, clSnap->areamask, sizeof( snapshot->areamask ) );
 	snapshot->ps = clSnap->ps;
-	snapshot->vps = clSnap->vps; //get the vehicle ps
 	count = clSnap->numEntities;
 	if ( count > MAX_ENTITIES_IN_SNAPSHOT ) {
 		Com_DPrintf( "CL_GetSnapshot: truncated %i entities to %i\n", count, MAX_ENTITIES_IN_SNAPSHOT );
@@ -228,17 +206,9 @@ qboolean CL_GetDefaultState(int index, entityState_t *state)
 CL_SetUserCmdValue
 =====================
 */
-extern float cl_mPitchOverride;
-extern float cl_mYawOverride;
-extern float cl_mSensitivityOverride;
-void CL_SetUserCmdValue( int userCmdValue, float sensitivityScale, float mPitchOverride, float mYawOverride, float mSensitivityOverride, int fpSel, int invenSel ) {
+void CL_SetUserCmdValue( int userCmdValue, float sensitivityScale ) {
 	cl.cgameUserCmdValue = userCmdValue;
 	cl.cgameSensitivity = sensitivityScale;
-	cl_mPitchOverride = mPitchOverride;
-	cl_mYawOverride = mYawOverride;
-	cl_mSensitivityOverride = mSensitivityOverride;
-	cl.cgameForceSelection = fpSel;
-	cl.cgameInvenSelection = invenSel;
 }
 
 /*
@@ -273,8 +243,6 @@ void CL_CgameError( const char *string ) {
 
 int gCLTotalClientNum = 0;
 //keep track of the total number of clients
-extern cvar_t	*cl_autolodscale;
-//if we want to do autolodscaling
 
 void CL_DoAutoLODScale(void)
 {
@@ -343,114 +311,13 @@ void CL_ConfigstringModified( void ) {
 		cl.gameState.dataCount += len + 1;
 	}
 
-	if (cl_autolodscale && cl_autolodscale->integer)
-	{
-		if (index >= CS_PLAYERS &&
-			index < CS_G2BONES)
-		{ //this means that a client was updated in some way. Go through and count the clients.
-			int clientCount = 0;
-			i = CS_PLAYERS;
-
-			while (i < CS_G2BONES)
-			{
-				s = cl.gameState.stringData + cl.gameState.stringOffsets[ i ];
-
-				if (s && s[0])
-				{
-					clientCount++;
-				}
-
-				i++;
-			}
-
-			gCLTotalClientNum = clientCount;
-
-#ifdef _DEBUG
-			Com_DPrintf("%i clients\n", gCLTotalClientNum);
-#endif
-
-			CL_DoAutoLODScale();
-		}
-	}
-
 	if ( index == CS_SYSTEMINFO ) {
 		// parse serverId and other cvars
 		CL_SystemInfoChanged();
 	}
 
 }
-#ifndef MAX_STRINGED_SV_STRING
-	#define MAX_STRINGED_SV_STRING 1024
-#endif
-// just copied it from CG_CheckSVStringEdRef(
-void CL_CheckSVStringEdRef(char *buf, const char *str)
-{ //I don't really like doing this. But it utilizes the system that was already in place.
-	int i = 0;
-	int b = 0;
-	int strLen = 0;
-	qboolean gotStrip = qfalse;
-
-	if (!str || !str[0])
-	{
-		if (str)
-		{
-			strcpy(buf, str);
-		}
-		return;
-	}
-
-	strcpy(buf, str);
-
-	strLen = strlen(str);
-
-	if (strLen >= MAX_STRINGED_SV_STRING)
-	{
-		return;
-	}
 
-	while (i < strLen && str[i])
-	{
-		gotStrip = qfalse;
-
-		if (str[i] == '@' && (i+1) < strLen)
-		{
-			if (str[i+1] == '@' && (i+2) < strLen)
-			{
-				if (str[i+2] == '@' && (i+3) < strLen)
-				{ //@@@ should mean to insert a StringEd reference here, so insert it into buf at the current place
-					char stringRef[MAX_STRINGED_SV_STRING];
-					int r = 0;
-
-					while (i < strLen && str[i] == '@')
-					{
-						i++;
-					}
-
-					while (i < strLen && str[i] && str[i] != ' ' && str[i] != ':' && str[i] != '.' && str[i] != '\n')
-					{
-						stringRef[r] = str[i];
-						r++;
-						i++;
-					}
-					stringRef[r] = 0;
-
-					buf[b] = 0;
-					Q_strcat(buf, MAX_STRINGED_SV_STRING, SE_GetString("MP_SVGAME", stringRef));
-					b = strlen(buf);
-				}
-			}
-		}
-
-		if (!gotStrip)
-		{
-			buf[b] = str[i];
-			b++;
-		}
-		i++;
-	}
-
-	buf[b] = 0;
-}
 /*
 ===================
 CL_GetServerCommand
@@ -493,16 +360,12 @@ qboolean CL_GetServerCommand( int serverCommandNumber ) {
 	s = clc.serverCommands[ serverCommandNumber & ( MAX_RELIABLE_COMMANDS - 1 ) ];
 	clc.lastExecutedServerCommand = serverCommandNumber;
 
-	Com_DPrintf( "serverCommand: %i : %s\n", serverCommandNumber, s );
-
 rescan:
 	Cmd_TokenizeString( s );
 	cmd = Cmd_Argv(0);
 
 	if ( !strcmp( cmd, "disconnect" ) ) {
-		char strEd[MAX_STRINGED_SV_STRING];
-		CL_CheckSVStringEdRef(strEd, Cmd_Argv(1));
-		Com_Error (ERR_SERVERDISCONNECT, "%s: %s\n", SE_GetString("MP_SVGAME_SERVER_DISCONNECTED"), strEd );
+		Com_Error (ERR_SERVERDISCONNECT, "Server disconnected: %s\n", Cmd_Argv(1) );
 	}
 
 	if ( !strcmp( cmd, "bcs0" ) ) {
@@ -681,24 +544,6 @@ int CL_CgameSystemCalls( int *args ) {
 		return 0;
 	case CG_MILLISECONDS:
 		return Sys_Milliseconds();
-	//rww - precision timer funcs... -ALWAYS- call end after start with supplied ptr, or you'll get a nasty memory leak.
-	//not that you should be using these outside of debug anyway.. because you shouldn't be. So don't.
-	case CG_PRECISIONTIMER_START:
-		{
-			void **suppliedPtr =(void **)VMA(1); //we passed in a pointer to a point
-			timing_c *newTimer = new timing_c; //create the new timer
-			*suppliedPtr = newTimer; //assign the pointer within the pointer to point at the mem addr of our new timer
-			newTimer->Start(); //start the timer
-		}
-		return 0;
-	case CG_PRECISIONTIMER_END:
-		{
-			int r;
-			timing_c *timer = (timing_c *)args[1]; //this is the pointer we assigned in start, so we can directly cast it back
-			r = timer->End(); //get the result
-			delete timer; //delete the timer since we're done with it
-			return r; //return the result
-		}
 	case CG_CVAR_REGISTER:
 		Cvar_Register( (vmCvar_t *)VMA(1), (const char *)VMA(2), (const char *)VMA(3), args[4] ); 
 		return 0;
@@ -711,8 +556,6 @@ int CL_CgameSystemCalls( int *args ) {
 	case CG_CVAR_VARIABLESTRINGBUFFER:
 		Cvar_VariableStringBuffer( (const char *)VMA(1), (char *)VMA(2), args[3] );
 		return 0;
-	case CG_CVAR_GETHIDDENVALUE:
-		return CL_GetValueForHidden((const char *)VMA(1));
 	case CG_ARGC:
 		return Cmd_Argc();
 	case CG_ARGV:
@@ -792,26 +635,21 @@ int CL_CgameSystemCalls( int *args ) {
 		return 0;
 	case CG_CM_MARKFRAGMENTS:
 		return re.MarkFragments( args[1], (const vec3_t *)VMA(2), (const float *)VMA(3), args[4], (float *)VMA(5), args[6], (markFragment_t *)VMA(7) );
-	case CG_S_GETVOICEVOLUME:
-		return s_entityWavVol[args[1]];
-	case CG_S_MUTESOUND:
-		S_MuteSound( args[1], args[2] );
-		return 0;
 	case CG_S_STARTSOUND:
-		S_StartSound( (float *)VMA(1), args[2], args[3], args[4] );
+		S_StartSound( (float *)VMA(1), args[2], args[3], args[4], args[5], args[6] );
 		return 0;
 	case CG_S_STARTLOCALSOUND:
 		S_StartLocalSound( args[1], args[2] );
 		return 0;
 	case CG_S_CLEARLOOPINGSOUNDS:
-		S_ClearLoopingSounds();
+		S_ClearLoopingSounds( args[1]?qtrue:qfalse );
 		return 0;
 	case CG_S_ADDLOOPINGSOUND:
-		S_AddLoopingSound( args[1], (const float *)VMA(2), (const float *)VMA(3), args[4] );
+		S_AddLoopingSound( args[1], (const float *)VMA(2), (const float *)VMA(3), VMF(4), args[5] );
 		return 0;
 	case CG_S_ADDREALLOOPINGSOUND:
 		//S_AddRealLoopingSound( args[1], (const float *)VMA(2), (const float *)VMA(3), args[4] );
-		S_AddLoopingSound( args[1], (const float *)VMA(2), (const float *)VMA(3), args[4] );
+		S_AddLoopingSound( args[1], (const float *)VMA(2), (const float *)VMA(3), VMF(4), args[5] );
 		return 0;
 	case CG_S_STOPLOOPINGSOUND:
 		S_StopLoopingSound( args[1] );
@@ -822,26 +660,18 @@ int CL_CgameSystemCalls( int *args ) {
 	case CG_S_RESPATIALIZE:
 		S_Respatialize( args[1], (const float *)VMA(2), (vec3_t *)VMA(3), args[4] );
 		return 0;
-	case CG_S_SHUTUP:
-		s_shutUp = (qboolean)args[1];
-		return 0;
 	case CG_S_REGISTERSOUND:
 		return S_RegisterSound( (const char *)VMA(1) );
 	case CG_S_STARTBACKGROUNDTRACK:
 		S_StartBackgroundTrack( (const char *)VMA(1), (const char *)VMA(2), args[3]?qtrue:qfalse );
 		return 0;
 
-	case CG_S_UPDATEAMBIENTSET:
-		S_UpdateAmbientSet((const char *)VMA(1), (float *)VMA(2));
-		return 0;
 	case CG_AS_PARSESETS:
 		AS_ParseSets();
 		return 0;
 	case CG_AS_ADDPRECACHEENTRY:
 		AS_AddPrecacheEntry((const char *)VMA(1));
 		return 0;
-	case CG_S_ADDLOCALSET:
-		return S_AddLocalSet((const char *)VMA(1), (float *)VMA(2), (float *)VMA(3), args[4], args[5]);
 	case CG_AS_GETBMODELSOUND:
 		return AS_GetBModelSound((const char *)VMA(1), args[2]);
 
@@ -851,28 +681,14 @@ int CL_CgameSystemCalls( int *args ) {
 	case CG_R_REGISTERMODEL:
 		return re.RegisterModel( (const char *)VMA(1) );
 	case CG_R_REGISTERSKIN:
-		return re.RegisterSkin( (const char *)VMA(1) );
+		//SOF2 TODO
+		return re.RegisterSkin( (const char *)VMA(1), 0, NULL );
 	case CG_R_REGISTERSHADER:
 		return re.RegisterShader( (const char *)VMA(1) );
 	case CG_R_REGISTERSHADERNOMIP:
 		return re.RegisterShaderNoMip( (const char *)VMA(1) );
 	case CG_R_REGISTERFONT:
 		return re.RegisterFont( (const char *)VMA(1) );
-	case CG_R_FONT_STRLENPIXELS:
-		return re.Font_StrLenPixels( (const char *)VMA(1), args[2], VMF(3) );
-	case CG_R_FONT_STRLENCHARS:
-		return re.Font_StrLenChars( (const char *)VMA(1) );
-	case CG_R_FONT_STRHEIGHTPIXELS:
-		return re.Font_HeightPixels( args[1], VMF(2) );
-	case CG_R_FONT_DRAWSTRING:
-		re.Font_DrawString( args[1], args[2], (const char *)VMA(3), (const float *) VMA(4), args[5], args[6], VMF(7) );
-		return 0;
-	case CG_LANGUAGE_ISASIAN:
-		return re.Language_IsAsian();
-	case CG_LANGUAGE_USESSPACES:
-		return re.Language_UsesSpaces();
-	case CG_ANYLANGUAGE_READCHARFROMSTRING:
-		return re.AnyLanguage_ReadCharFromString( (const char *) VMA(1), (int *) VMA(2), (qboolean *) VMA(3) );
 	case CG_R_CLEARSCENE:
 		re.ClearScene();
 		return 0;
@@ -914,7 +730,7 @@ int CL_CgameSystemCalls( int *args ) {
 		re.SetColor( (const float *)VMA(1) );
 		return 0;
 	case CG_R_DRAWSTRETCHPIC:
-		re.DrawStretchPic( VMF(1), VMF(2), VMF(3), VMF(4), VMF(5), VMF(6), VMF(7), VMF(8), args[9] );
+		re.DrawStretchPic( VMF(1), VMF(2), VMF(3), VMF(4), VMF(5), VMF(6), VMF(7), VMF(8), args[10] );
 		return 0;
 	case CG_R_MODELBOUNDS:
 		re.ModelBounds( args[1], (float *)VMA(2), (float *)VMA(3) );
@@ -928,14 +744,6 @@ int CL_CgameSystemCalls( int *args ) {
 		re.DrawRotatePic2( VMF(1), VMF(2), VMF(3), VMF(4), VMF(5), VMF(6), VMF(7), VMF(8), VMF(9), args[10] );
 		return 0;
 	
-	case CG_R_SETRANGEFOG:
-		re.SetRangedFog( VMF(1) );
-		return 0;
-
-	case CG_R_SETREFRACTIONPROP:
-		re.SetRefractionProperties( VMF(1), VMF(2), (qboolean)args[3], (qboolean)args[4] );
-		return 0;
-
 	case CG_GETGLCONFIG:
 		CL_GetGlconfig( (glconfig_t *)VMA(1) );
 		return 0;
@@ -956,29 +764,19 @@ int CL_CgameSystemCalls( int *args ) {
 	case CG_GETUSERCMD:
 		return CL_GetUserCmd( args[1], (struct usercmd_s *)VMA(2) );
 	case CG_SETUSERCMDVALUE:
-		cl_bUseFighterPitch = (qboolean)args[8];
-		CL_SetUserCmdValue( args[1], VMF(2), VMF(3), VMF(4), VMF(5), args[6], args[7] );
-		return 0;
-	case CG_SETCLIENTFORCEANGLE:
-		CL_SetClientForceAngle(args[1], (float *)VMA(2));
-		return 0;
-	case CG_SETCLIENTTURNEXTENT:
-		return 0;
-
-	case CG_OPENUIMENU:
-		VM_Call( uivm, UI_SET_ACTIVE_MENU, args[1] );
+		CL_SetUserCmdValue( args[1], VMF(2) );
 		return 0;
 
 	case CG_MEMORY_REMAINING:
 		return Hunk_MemoryRemaining();
-  case CG_KEY_ISDOWN:
+	case CG_KEY_ISDOWN:
 		return Key_IsDown( args[1] );
-  case CG_KEY_GETCATCHER:
+	case CG_KEY_GETCATCHER:
 		return Key_GetCatcher();
-  case CG_KEY_SETCATCHER:
+	case CG_KEY_SETCATCHER:
 		Key_SetCatcher( args[1] );
-    return 0;
-  case CG_KEY_GETKEY:
+		return 0;
+	case CG_KEY_GETKEY:
 		return Key_GetKey( (const char *)VMA(1) );
 
 	case CG_PC_ADD_GLOBAL_DEFINE:
@@ -1036,48 +834,11 @@ int CL_CgameSystemCalls( int *args ) {
 		re.SetLightStyle(args[1], args[2]);
 		return 0;
 
-	case CG_R_GET_BMODEL_VERTS:
-		re.GetBModelVerts( args[1], (float (*)[3])VMA(2), (float *)VMA(3) );
-		return 0;
-
-	case CG_R_GETDISTANCECULL:
-		{
-			float *f;
-			f = (float *)VMA(1);
-			*f = re.GetDistanceCull();
-		}
-		return 0;
-
-	case CG_R_GETREALRES:
-		{
-			int *w = (int *)VMA(1);
-			int *h = (int *)VMA(2);
-			re.GetRealRes( w, h );
-		}
-		return 0;
-
-	case CG_R_AUTOMAPELEVADJ:
-		re.AutomapElevationAdjustment(VMF(1));
-		return 0;
-
-	case CG_R_INITWIREFRAMEAUTO:
-		return re.InitializeWireframeAutomap();
-
-/*
-	case CG_LOADCAMERA:
-		return loadCamera(VMA(1));
-
-	case CG_STARTCAMERA:
-		startCamera(args[1]);
-		return 0;
-
-	case CG_GETCAMERAINFO:
-		return getCameraInfo(args[1], VMA(2), VMA(3));
-*/
 	case CG_GET_ENTITY_TOKEN:
 		return re.GetEntityToken( (char *)VMA(1), args[2] );
 	case CG_R_INPVS:
-		return re.inPVS( (const float *)VMA(1), (const float *)VMA(2), (byte *)VMA(3) );
+		//SOF2 TODO
+		return re.inPVS( (const float *)VMA(1), (const float *)VMA(2), 0 );
 
 #ifndef DEBUG_DISABLEFXCALLS
 	case CG_FX_ADDLINE:
@@ -1102,28 +863,20 @@ int CL_CgameSystemCalls( int *args ) {
 		FX_PlayEffectID(args[1], (float *)VMA(2), (float *)VMA(3), args[4], args[5] );
 		return 0;
 
-	case CG_FX_PLAY_PORTAL_EFFECT_ID:
-		FX_PlayEffectID(args[1], (float *)VMA(2), (float *)VMA(3), args[4], args[5], qtrue );
-		return 0;
-
 	case CG_FX_PLAY_ENTITY_EFFECT_ID:
 		FX_PlayEntityEffectID(args[1], (float *)VMA(2), (vec3_t *)VMA(3), args[4], args[5], args[6], args[7] );
 		return 0;
 
 	case CG_FX_PLAY_BOLTED_EFFECT_ID:
 		{
-		//( int id, vec3_t org, void *pGhoul2, const int boltNum, const int entNum, const int modelNum, int iLooptime, qboolean isRelative );
-		CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[3]);
-		int boltInfo=0;
-		if ( re.G2API_AttachEnt( &boltInfo, &g2[args[6]], args[4], args[5], args[6] ) )
-		{
-			FX_PlayBoltedEffectID(args[1], (float *)VMA(2), boltInfo, g2.mItem, args[7], (qboolean)args[8] );
-			return 1;
-		}
-		return 0;
+			//SOF2 TODO Temporarily use FX_PlayEffectID here.
+			//(int id,CFxBoltInterface *obj, int vol, int rad)
+			CFxBoltInterface * boltInterface = (CFxBoltInterface *) VMA(2);
+			FX_PlayEffectID(args[1], boltInterface->origin, boltInterface->forward, args[3], args[4]);
+			return 0;
 		}
 	case CG_FX_ADD_SCHEDULED_EFFECTS:
-		FX_AddScheduledEffects((qboolean)args[1]);
+		FX_AddScheduledEffects(qfalse);
 		return 0;
 
 	case CG_FX_DRAW_2D_EFFECTS:
@@ -1133,10 +886,6 @@ int CL_CgameSystemCalls( int *args ) {
 	case CG_FX_INIT_SYSTEM:
 		return FX_InitSystem( (refdef_t*)VMA(1) );
 
-	case CG_FX_SET_REFDEF:
-		FX_SetRefDefFromCGame( (refdef_t*)VMA(1) );
-		return 0;
-
 	case CG_FX_FREE_SYSTEM:
 		return FX_FreeSystem();
 
@@ -1148,83 +897,6 @@ int CL_CgameSystemCalls( int *args ) {
 		FX_Free ( false );
 		return 0;
 
-	case CG_FX_ADDPOLY:
-		{
-			addpolyArgStruct_t *p;
-
-			p = (addpolyArgStruct_t *)VMA(1);//args[1];
-
-			if (p)
-			{
-				FX_AddPoly(p->p, p->ev, p->numVerts, p->vel, p->accel, p->alpha1, p->alpha2,
-					p->alphaParm, p->rgb1, p->rgb2, p->rgbParm, p->rotationDelta, p->bounce, p->motionDelay,
-					p->killTime, p->shader, p->flags);
-			}
-		}
-		return 0;
-
-	case CG_FX_ADDBEZIER:
-		{
-			addbezierArgStruct_t *b;
-
-			b = (addbezierArgStruct_t *)VMA(1);//args[1];
-
-			if (b)
-			{
-				FX_AddBezier(b->start, b->end, b->control1, b->control1Vel, b->control2, b->control2Vel,
-					b->size1, b->size2, b->sizeParm, b->alpha1, b->alpha2, b->alphaParm, b->sRGB,
-					b->eRGB, b->rgbParm, b->killTime, b->shader, b->flags);
-			}
-		}
-		return 0;
-
-	case CG_FX_ADDPRIMITIVE:
-		{
-			effectTrailArgStruct_t *a;
-
-			a = (effectTrailArgStruct_t *)VMA(1);//args[1];
-
-			if (a)
-			{
-				FX_FeedTrail(a);
-			}
-		}
-		return 0;
-
-	case CG_FX_ADDSPRITE:
-		{
-			addspriteArgStruct_t *s;
-
-			s = (addspriteArgStruct_t *)VMA(1);//args[1];
-
-			if (s)
-			{
-				vec3_t rgb;
-				rgb[0] = 1;
-				rgb[1] = 1;
-				rgb[2] = 1;
-				//FX_AddSprite(NULL, s->origin, s->vel, s->accel, s->scale, s->dscale, s->sAlpha, s->eAlpha,
-				//	s->rotation, s->bounce, s->life, s->shader, s->flags);
-				FX_AddParticle(s->origin, s->vel, s->accel, s->scale, s->dscale, 0, s->sAlpha, s->eAlpha, 0,
-					rgb, rgb, 0, s->rotation, 0, vec3_origin, vec3_origin, s->bounce, 0, 0, s->life,
-					s->shader, s->flags);
-			}
-		}
-		return 0;
-	case CG_FX_ADDELECTRICITY:
-		{
-			addElectricityArgStruct_t *p;
-
-			p = (addElectricityArgStruct_t *)VMA(1);
-
-			if (p)
-			{
-
-				FX_AddElectricity(p->start, p->end, p->size1, p->size2, p->sizeParm, p->alpha1, p->alpha2,
-					p->alphaParm, p->sRGB, p->eRGB, p->rgbParm, p->chaos, p->killTime, p->shader, p->flags);
-			}
-		}
-		return 0;
 #else
 	case CG_FX_REGISTER_EFFECT:
 	case CG_FX_PLAY_EFFECT:
@@ -1245,34 +917,6 @@ int CL_CgameSystemCalls( int *args ) {
 		return 0;
 #endif
 
-//	case CG_SP_PRINT:
-//		CL_SP_Print(args[1], (byte *)VMA(2));
-//		return 0;
-
-	case CG_ROFF_CLEAN:
-		return theROFFSystem.Clean(qtrue);
-	
-	case CG_ROFF_UPDATE_ENTITIES:
-		theROFFSystem.UpdateEntities(qtrue);
-		return 0;
-
-	case CG_ROFF_CACHE:
-		return theROFFSystem.Cache( (char *)VMA(1), qtrue );
-		
-	case CG_ROFF_PLAY:
-		return theROFFSystem.Play(args[1], args[2], (qboolean)args[3], qtrue );
-
-	case CG_ROFF_PURGE_ENT:
-		return theROFFSystem.PurgeEnt( args[1], qtrue );
-
-	//rww - dynamic vm memory allocation!
-	case CG_TRUEMALLOC:
-		VM_Shifted_Alloc((void **)VMA(1), args[2]);
-		return 0;
-	case CG_TRUEFREE:
-		VM_Shifted_Free((void **)VMA(1));
-		return 0;
-
 /*
 Ghoul2 Insert Start
 */
@@ -1298,20 +942,7 @@ Ghoul2 Insert Start
 	case CG_G2_GETBOLT:
 		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
 
-	case CG_G2_GETBOLT_NOREC:
-		re.G2API_BoltMatrixReconstruction( qfalse );
-		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
-
-	case CG_G2_GETBOLT_NOREC_NOROT:
-		//gG2_GBMNoReconstruct = qtrue;
-		//Yeah, this was probably BAD.
-		re.G2API_BoltMatrixSPMethod( qtrue );
-		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
-
 	case CG_G2_INITGHOUL2MODEL:
-#ifdef _FULL_G2_LEAK_CHECKING
-		g_G2AllocServer = 0;
-#endif
 		return	re.G2API_InitGhoul2Model((CGhoul2Info_v **)VMA(1), (const char *)VMA(2), args[3], (qhandle_t) args[4],
 									  (qhandle_t) args[5], args[6], args[7]);
 
@@ -1319,8 +950,7 @@ Ghoul2 Insert Start
 		{
 			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
 			int modelIndex = args[2];
-			
-			return re.G2API_SetSkin(&g2[modelIndex], args[3], args[4]);
+			return re.G2API_SetSkin(&g2[modelIndex], args[3], 0);
 		}
 
 	case CG_G2_COLLISIONDETECT:
@@ -1335,22 +965,7 @@ Ghoul2 Insert Start
 								   G2VertSpaceClient,
 								   args[10],
 								   args[11],
-								   VMF(12) );
-		return 0;
-
-	case CG_G2_COLLISIONDETECTCACHE:
-		re.G2API_CollisionDetectCache ( (CollisionRecord_t*)VMA(1), *((CGhoul2Info_v *)args[2]), 
-								   (const float*)VMA(3),
-								   (const float*)VMA(4),
-								   args[5],
-								   args[6],
-								   (float*)VMA(7),
-								   (float*)VMA(8),
-								   (float*)VMA(9),
-								   G2VertSpaceClient,
-								   args[10],
-								   args[11],
-								   VMF(12) );
+								   -1 );
 		return 0;
 
 	case CG_G2_ANGLEOVERRIDE:
@@ -1359,40 +974,15 @@ Ghoul2 Insert Start
 							 (qhandle_t *)VMA(9), args[10], args[11] );
 	
 	case CG_G2_CLEANMODELS:
-#ifdef _FULL_G2_LEAK_CHECKING
-		g_G2AllocServer = 0;
-#endif
 		if ( re.G2API_CleanGhoul2Models )
 			re.G2API_CleanGhoul2Models((CGhoul2Info_v **)VMA(1));
-	//	G2API_CleanGhoul2Models((CGhoul2Info_v **)args[1]);
 		return 0;
 
 	case CG_G2_PLAYANIM:
 		return re.G2API_SetBoneAnim(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3), args[4], args[5],
 								args[6], VMF(7), args[8], VMF(9), args[10]);
 
-	case CG_G2_GETBONEANIM:
-		{
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-			int modelIndex = args[10];
-
-			return re.G2API_GetBoneAnim(&g2[modelIndex], (const char*)VMA(2), args[3], (float *)VMA(4), (int *)VMA(5),
-								(int *)VMA(6), (int *)VMA(7), (float *)VMA(8), (int *)VMA(9));
-		}
-
-	case CG_G2_GETBONEFRAME:
-		{ //rwwFIXMEFIXME: Just make a G2API_GetBoneFrame func too. This is dirty.
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-			int modelIndex = args[6];
-			int iDontCare1 = 0, iDontCare2 = 0, iDontCare3 = 0;
-			float fDontCare1 = 0;
-
-			return re.G2API_GetBoneAnim(&g2[modelIndex], (const char*)VMA(2), args[3], (float *)VMA(4), &iDontCare1,
-								&iDontCare2, &iDontCare3, &fDontCare1, (int *)VMA(5));
-		}
-
 	case CG_G2_GETGLANAME:
-		//	return (int)G2API_GetGLAName(*((CGhoul2Info_v *)VMA(1)), args[2]);
 		{
 			char *point = ((char *)VMA(3));
 			char *local;
@@ -1408,42 +998,16 @@ Ghoul2 Insert Start
 		return re.G2API_CopyGhoul2Instance(*((CGhoul2Info_v *)args[1]), *((CGhoul2Info_v *)args[2]), args[3]);
 
 	case CG_G2_COPYSPECIFICGHOUL2MODEL:
-		re.G2API_CopySpecificG2Model(*((CGhoul2Info_v *)args[1]), args[2], *((CGhoul2Info_v *)args[3]), args[4]);
-		return 0;
+		return re.G2API_CopySpecificG2Model(*((CGhoul2Info_v *)args[1]), args[2], *((CGhoul2Info_v *)args[3]), args[4]);
 
 	case CG_G2_DUPLICATEGHOUL2INSTANCE:
-#ifdef _FULL_G2_LEAK_CHECKING
-		g_G2AllocServer = 0;
-#endif
 		re.G2API_DuplicateGhoul2Instance(*((CGhoul2Info_v *)args[1]), (CGhoul2Info_v **)VMA(2));
 		return 0;
 
-	case CG_G2_HASGHOUL2MODELONINDEX:
-		return (int)re.G2API_HasGhoul2ModelOnIndex((CGhoul2Info_v **)VMA(1), args[2]);
-		//return (int)G2API_HasGhoul2ModelOnIndex((CGhoul2Info_v **)args[1], args[2]);
-
 	case CG_G2_REMOVEGHOUL2MODEL:
-#ifdef _FULL_G2_LEAK_CHECKING
-		g_G2AllocServer = 0;
-#endif
 		return (int)re.G2API_RemoveGhoul2Model((CGhoul2Info_v **)VMA(1), args[2]);
 		//return (int)G2API_RemoveGhoul2Model((CGhoul2Info_v **)args[1], args[2]);
 
-	case CG_G2_SKINLESSMODEL:
-		{
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-			return re.G2API_SkinlessModel(&g2[args[2]]);
-		}
-
-	case CG_G2_GETNUMGOREMARKS:
-#ifdef _G2_GORE
-		{
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-			return re.G2API_GetNumGoreMarks(&g2[args[2]]);
-		}
-#endif
-		return 0;
-
 	case CG_G2_ADDSKINGORE:
 #ifdef _G2_GORE
 		re.G2API_AddSkinGore(*((CGhoul2Info_v *)args[1]),*(SSkinGoreData *)VMA(2));
@@ -1456,20 +1020,8 @@ Ghoul2 Insert Start
 #endif
 		return 0;
 
-	case CG_G2_SIZE:
-		return re.G2API_Ghoul2Size ( *((CGhoul2Info_v *)args[1]) );
-		break;
-
 	case CG_G2_ADDBOLT:
-		return	re.G2API_AddBolt(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3));
-
-
-	case CG_G2_ATTACHENT:
-//				G2API_AttachEnt(int *boltInfo, CGhoul2Info *ghlInfoTo, int toBoltIndex, int entNum, int toModelNum)
-		{
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[2]);
-			return	re.G2API_AttachEnt( (int*)VMA(1), &g2[0], args[3], args[4], args[5] );
-		}
+		return re.G2API_AddBolt(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3));
 
 	case CG_G2_SETBOLTON:
 		re.G2API_SetBoltInfo(*((CGhoul2Info_v *)args[1]), args[2], args[3]);
@@ -1484,165 +1036,16 @@ Ghoul2 Insert Start
 Ghoul2 Insert End
 */
 	case CG_G2_SETROOTSURFACE:
-		return re.G2API_SetRootSurface(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3));
+		return re.G2API_SetRootSurface(**(CGhoul2Info_v **)VMA(1), args[2], (const char *)VMA(3));
 
 	case CG_G2_SETSURFACEONOFF:
-		return re.G2API_SetSurfaceOnOff(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), /*(const int)VMA(3)*/args[3]);
+		return re.G2API_SetSurfaceOnOff(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3), args[4]);
 
 	case CG_G2_SETNEWORIGIN:
-		return re.G2API_SetNewOrigin(*((CGhoul2Info_v *)args[1]), /*(const int)VMA(2)*/args[2]);
-
-	case CG_G2_DOESBONEEXIST:
-		{
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-			return re.G2API_DoesBoneExist(&g2[args[2]], (const char *)VMA(3));
-		}
-
-	case CG_G2_GETSURFACERENDERSTATUS:
-	{
-		CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-
-		return re.G2API_GetSurfaceRenderStatus(&g2[args[2]], (const char *)VMA(3));
-	}
-
-	case CG_G2_GETTIME:
-		return re.G2API_GetTime(0);
-
-	case CG_G2_SETTIME:
-		re.G2API_SetTime(args[1], args[2]);
-		return 0;
-
-	case CG_G2_ABSURDSMOOTHING:
-		{
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-
-			re.G2API_AbsurdSmoothing(g2, (qboolean)args[2]);
-		}
-		return 0;
-
-
-	case CG_G2_SETRAGDOLL:
-		{
-			//Convert the info in the shared structure over to the class-based version.
-			sharedRagDollParams_t *rdParamst = (sharedRagDollParams_t *)VMA(2);
-			CRagDollParams rdParams;
-
-			if (!rdParamst)
-			{
-				re.G2API_ResetRagDoll(*((CGhoul2Info_v *)args[1]));
-				return 0;
-			}
-
-			VectorCopy(rdParamst->angles, rdParams.angles);
-			VectorCopy(rdParamst->position, rdParams.position);
-			VectorCopy(rdParamst->scale, rdParams.scale);
-			VectorCopy(rdParamst->pelvisAnglesOffset, rdParams.pelvisAnglesOffset);
-			VectorCopy(rdParamst->pelvisPositionOffset, rdParams.pelvisPositionOffset);
-
-			rdParams.fImpactStrength = rdParamst->fImpactStrength;
-			rdParams.fShotStrength = rdParamst->fShotStrength;
-			rdParams.me = rdParamst->me;
-
-			rdParams.startFrame = rdParamst->startFrame;
-			rdParams.endFrame = rdParamst->endFrame;
-
-			rdParams.collisionType = rdParamst->collisionType;
-			rdParams.CallRagDollBegin = rdParamst->CallRagDollBegin;
-
-			rdParams.RagPhase = (CRagDollParams::ERagPhase)rdParamst->RagPhase;
-			rdParams.effectorsToTurnOff = (CRagDollParams::ERagEffector)rdParamst->effectorsToTurnOff;
-
-			re.G2API_SetRagDoll(*((CGhoul2Info_v *)args[1]), &rdParams);
-		}
-		return 0;
-		break;
-	case CG_G2_ANIMATEG2MODELS:
-		{
-			sharedRagDollUpdateParams_t *rduParamst = (sharedRagDollUpdateParams_t *)VMA(3);
-			CRagDollUpdateParams rduParams;
-
-			if (!rduParamst)
-			{
-				return 0;
-			}
-
-			VectorCopy(rduParamst->angles, rduParams.angles);
-			VectorCopy(rduParamst->position, rduParams.position);
-			VectorCopy(rduParamst->scale, rduParams.scale);
-			VectorCopy(rduParamst->velocity, rduParams.velocity);
-
-			rduParams.me = rduParamst->me;
-			rduParams.settleFrame = rduParamst->settleFrame;
-
-			re.G2API_AnimateG2ModelsRag(*((CGhoul2Info_v *)args[1]), args[2], &rduParams);
-		}
-		return 0;
-		break;
-
-	//additional ragdoll options -rww
-	case CG_G2_RAGPCJCONSTRAINT:
-		return re.G2API_RagPCJConstraint(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), (float *)VMA(3), (float *)VMA(4));
-	case CG_G2_RAGPCJGRADIENTSPEED:
-		return re.G2API_RagPCJGradientSpeed(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), VMF(3));
-	case CG_G2_RAGEFFECTORGOAL:
-		return re.G2API_RagEffectorGoal(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), (float *)VMA(3));
-	case CG_G2_GETRAGBONEPOS:
-		return re.G2API_GetRagBonePos(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), (float *)VMA(3), (float *)VMA(4), (float *)VMA(5), (float *)VMA(6));
-	case CG_G2_RAGEFFECTORKICK:
-		return re.G2API_RagEffectorKick(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), (float *)VMA(3));
-	case CG_G2_RAGFORCESOLVE:
-		return re.G2API_RagForceSolve(*((CGhoul2Info_v *)args[1]), (qboolean)args[2]);
-
-	case CG_G2_SETBONEIKSTATE:
-		return re.G2API_SetBoneIKState(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3), args[4], (sharedSetBoneIKStateParams_t *)VMA(5));
-	case CG_G2_IKMOVE:
-		return re.G2API_IKMove(*((CGhoul2Info_v *)args[1]), args[2], (sharedIKMoveParams_t *)VMA(3));
-
-	case CG_G2_REMOVEBONE:
-		{
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-
-			return re.G2API_RemoveBone(&g2[args[3]], (const char *)VMA(2));
-		}
-
-	case CG_G2_ATTACHINSTANCETOENTNUM:
-		{
-			re.G2API_AttachInstanceToEntNum(*((CGhoul2Info_v *)args[1]), args[2], (qboolean)args[3]);
-		}
-		return 0;
-	case CG_G2_CLEARATTACHEDINSTANCE:
-		re.G2API_ClearAttachedInstance(args[1]);
-		return 0;
-	case CG_G2_CLEANENTATTACHMENTS:
-		re.G2API_CleanEntAttachments();
-		return 0;
-	case CG_G2_OVERRIDESERVER:
-		{
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-			return re.G2API_OverrideServerWithClientData(&g2[0]);
-		}
-
-	case CG_G2_GETSURFACENAME:
-		{ //Since returning a pointer in such a way to a VM seems to cause MASSIVE FAILURE<tm>, we will shove data into the pointer the vm passes instead
-			char *point = ((char *)VMA(4));
-			char *local;
-			int modelindex = args[3];
-
-			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-
-			local = re.G2API_GetSurfaceName(&g2[modelindex], args[2]);
-			if (local)
-			{
-				strcpy(point, local);
-			}
-		}
-
-		return 0;
+		return re.G2API_SetNewOrigin(*((CGhoul2Info_v *)args[1]), args[2], args[3]);
 
 	case CG_SP_GETSTRINGTEXTSTRING:
 //	case CG_SP_GETSTRINGTEXT:
-		const char* text;
-
 		assert(VMA(1));
 		assert(VMA(2));
 
@@ -1651,21 +1054,8 @@ Ghoul2 Insert End
 //			text = SP_GetStringText( args[1] );
 //		}
 //		else
-		{
-			text = SE_GetString( (const char *) VMA(1) );
-		}
-
-		if ( text[0] )
-		{
-			Q_strncpyz( (char *) VMA(2), text, args[3] );
-			return qtrue;
-		}
-		else 
-		{
-			Com_sprintf( (char *) VMA(2), args[3], "??%s", VMA(1) );
-			return qfalse;
-		}
-		break;
+		Com_sprintf( (char *) VMA(2), args[3], "??%s", VMA(1) );
+		return qfalse;
 
 	case CG_SET_SHARED_BUFFER:
 		cl.mSharedMemory = ((char *)VMA(1));
@@ -1699,21 +1089,198 @@ Ghoul2 Insert End
 		re.InitRendererTerrain((const char *)VMA(1));
 		return 0;
 
-	case CG_R_WEATHER_CONTENTS_OVERRIDE:
-		//contentOverride = args[1];
+	case GP_PARSE:
+		return (int)GP_Parse((char **) VMA(1), (bool) args[2], (bool) args[3]);
+	case GP_PARSE_FILE:
+		{
+			char * data;
+			FS_ReadFile((char *) VMA(1), (void **) &data);
+			return (int)GP_Parse(&data, (bool) args[2], (bool) args[3]);
+		}
+	case GP_CLEAN:
+		GP_Clean((TGenericParser2) args[1]);
+		return 0;
+	case GP_DELETE:
+		GP_Delete((TGenericParser2 *) VMA(1));
+		return 0;
+	case GP_GET_BASE_PARSE_GROUP:
+		return (int)GP_GetBaseParseGroup((TGenericParser2) args[1]);
+
+
+	case GPG_GET_NAME:
+		return (int)GPG_GetName((TGPGroup) args[1], (char *) VMA(2));
+	case GPG_GET_NEXT:
+		return (int)GPG_GetNext((TGPGroup) args[1]);
+	case UI_GPG_GET_INORDER_NEXT:
+		return (int)GPG_GetInOrderNext((TGPGroup) args[1]);
+	case GPG_GET_INORDER_PREVIOUS:
+		return (int)GPG_GetInOrderPrevious((TGPGroup) args[1]);
+	case GPG_GET_PAIRS:
+		return (int)GPG_GetPairs((TGPGroup) args[1]);
+	case GPG_GET_INORDER_PAIRS:
+		return (int)GPG_GetInOrderPairs((TGPGroup) args[1]);
+	case GPG_GET_SUBGROUPS:
+		return (int)GPG_GetSubGroups((TGPGroup) args[1]);
+	case GPG_GET_INORDER_SUBGROUPS:
+		return (int)GPG_GetInOrderSubGroups((TGPGroup) args[1]);
+	case GPG_FIND_SUBGROUP:
+		return (int)GPG_FindSubGroup((TGPGroup) args[1], (char *) VMA(2));
+	case GPG_FIND_PAIR:
+		return (int)GPG_FindPair((TGPGroup) args[1], (const char *) VMA(2));
+	case GPG_FIND_PAIRVALUE:
+		return (int)GPG_FindPairValue((TGPGroup) args[1], (const char *) VMA(2), (const char *) VMA(3), (char *) VMA(4));
+
+
+	case GPV_GET_NAME:
+		return (int)GPV_GetName((TGPValue) args[1], (char *) VMA(2));
+	case GPV_GET_NEXT:
+		return (int)GPV_GetNext((TGPValue) args[1]);
+	case GPV_GET_INORDER_NEXT:
+		return (int)GPV_GetInOrderNext((TGPValue) args[1]);
+	case GPV_GET_INORDER_PREVIOUS:
+		return (int)GPV_GetInOrderPrevious((TGPValue) args[1]);
+	case GPV_IS_LIST:
+		return (int)GPV_IsList((TGPValue) args[1]);
+	case GPV_GET_TOP_VALUE:
+		{
+			const char * topValue = GPV_GetTopValue((TGPValue) args[1]);
+			if (topValue)
+			{
+				strcpy((char *) VMA(2), topValue);
+			}
+			return 0;
+		}
+	case GPV_GET_LIST:
+		return (int)GPV_GetList((TGPValue) args[1]);
+
+
+	case CG_VM_LOCALALLOC:
+		return (int)VM_Local_Alloc(args[1]);
+	case CG_VM_LOCALALLOCUNALIGNED:
+		return (int)VM_Local_AllocUnaligned(args[1]);
+	case CG_VM_LOCALTEMPALLOC:
+		return (int)VM_Local_TempAlloc(args[1]);
+	case CG_VM_LOCALTEMPFREE:
+		VM_Local_TempFree(args[1]);
+		return 0;
+	case CG_VM_LOCALSTRINGALLOC:
+		return (int)VM_Local_StringAlloc((char *) VMA(1));
+
+
+	case CG_R_DRAWTEXT:
+		re.Font_DrawString(args[1], args[2], args[3], VMF(4), (vec_t *)VMA(5), (const char *)VMA(6), args[7], args[8], 0, 0);
+		return 0;
+	case CG_R_DRAWTEXTWITHCURSOR:
+		re.Font_DrawString(args[1], args[2], args[3], VMF(4), (vec_t *)VMA(5), (const char *)VMA(6), args[7], args[8], args[9], args[10]);
 		return 0;
+	case CG_R_GETTEXTWIDTH:
+		return re.Font_StrLenPixels((const char *)VMA(1), args[2], VMF(3));
+	case CG_R_GETTEXTHEIGHT:
+		return re.Font_HeightPixels(args[2], VMF(3));
+
+
+	case CG_G2_REGISTERSKIN:
+		return re.RegisterSkin((const char *)VMA(1), args[2], (char *)VMA(3) );
+	case CG_G2_GETANIMFILENAMEINDEX:
+		{
+			CGhoul2Info_v &ghoul2 = *((CGhoul2Info_v *)args[1]);
+			qhandle_t modelIndex = (qhandle_t) args[2];
+			char * srcFilename;
+			qboolean retval = re.G2API_GetAnimFileName(&ghoul2[modelIndex], &srcFilename);
+			strncpy((char *) VMA(3), srcFilename, MAX_QPATH);
+			return (int) retval;
+		}
 
-	case CG_R_WORLDEFFECTCOMMAND:
-		re.WorldEffectCommand((const char *)VMA(1));
+
+	case CG_MAT_RESET:
+		Mat_Reset();
+		return 0;
+	case CG_MAT_CACHE:
+		Mat_Init();
 		return 0;
+	case CG_MAT_GET_SOUND:
+		return Mat_GetSound((char*) VMA(1), args[2]);
+	case CG_MAT_GET_DECAL:
+		return Mat_GetDecal((char*) VMA(1), args[2]);
+	case CG_MAT_GET_DECAL_SCALE:
+		return Mat_GetDecalScale((char*) VMA(1), args[2]);
+	case CG_MAT_GET_EFFECT:
+		return Mat_GetEffect((char*) VMA(1), args[2]);
+	case CG_MAT_GET_DEBRIS:
+		return Mat_GetDebris((char*) VMA(1), args[2]);
+	case CG_MAT_GET_DEBRIS_SCALE:
+		return Mat_GetDebrisScale((char*) VMA(1), args[2]);
+
 
-	case CG_WE_ADDWEATHERZONE:
-		re.AddWeatherZone( (vec_t *)VMA(1), (vec_t *)VMA(2) );
+	case CG_G2_ATTACHG2MODEL:
+		{
+			CGhoul2Info_v *g2From = ((CGhoul2Info_v *)args[1]);
+			CGhoul2Info_v *g2To = ((CGhoul2Info_v *)args[3]);
+			
+			return re.G2API_AttachG2Model(*g2From, args[2], *g2To, args[4], args[5]);
+		}
+	case CG_G2_DETACHG2MODEL:
+		{
+			CGhoul2Info_v &ghoul2 = *((CGhoul2Info_v *)args[1]);
+			return re.G2API_DetachG2Model(&ghoul2[args[2]]);
+		}
+
+
+	case CG_RESETAUTORUN:
+		//SOF2 TODO
 		return 0;
 
+	case CG_AS_UPDATEAMBIENTSET:
+		S_UpdateAmbientSet((const char *)VMA(1), (float *)VMA(2));
+		return 0;
+
+	case CG_G2_GETBOLTINDEX:
+		{
+			CGhoul2Info_v &ghoul2 = *((CGhoul2Info_v *)args[1]);
+			//SOF2 TODO
+			return re.G2API_GetBoltIndex(&ghoul2[args[2]], args[2]);
+		}
+
+	case CG_UI_SETACTIVEMENU:
+		VM_Call( uivm, UI_SET_ACTIVE_MENU, args[1] );
+		return 0;
+
+	case CG_UI_CLOSEALL:
+		VM_Call( uivm, UI_CLOSEALL );
+		return 0;
+
+	case CG_G2_SETGHOUL2MODELFLAGSBYINDEX:
+		{
+			CGhoul2Info_v &ghoul2 = *((CGhoul2Info_v *)args[1]);
+			re.G2API_SetGhoul2ModelFlags(&ghoul2[args[2]], args[3]);
+			return 0;
+		}
+
+	case CG_G2_GETGHOUL2MODELFLAGSBYINDEX:
+		{
+			CGhoul2Info_v &ghoul2 = *((CGhoul2Info_v *)args[1]);
+			return re.G2API_GetGhoul2ModelFlags(&ghoul2[args[2]]);
+		}
+
+	case CG_S_STOPALLSOUNDS:
+		S_StopAllSounds();
+		return 0;
+
+	case CG_AS_ADDLOCALSET:
+		//SOF2 TODO
+		return 0;
+
+	case CG_G2_GETNUMMODELS:
+		//SOF2 TODO
+		return -1;
+
+	case CG_G2_FINDBOLTINDEX:
+		//SOF2 TODO
+		return -1;
+
 	default:
-	        assert(0); // bk010102
-		Com_Error( ERR_DROP, "Bad cgame system trap: %i", args[0] );
+		Com_Printf("Bad cgame system trap: %i\n", args[0] );
+		//Com_Error( ERR_DROP, "Bad cgame system trap: %i", args[0] );
 	}
 	return 0;
 }
@@ -1754,7 +1321,7 @@ void CL_InitCGame( void ) {
 	else {
 		interpret = (vmInterpret_t)(int)Cvar_VariableValue( "vm_cgame" );
 	}
-	cgvm = VM_Create( "cgame", CL_CgameSystemCalls, interpret );
+	cgvm = VM_Create( "sof2mp_cgame", CL_CgameSystemCalls, interpret );
 	if ( !cgvm ) {
 		Com_Error( ERR_DROP, "VM_Create on cgame failed" );
 	}
@@ -1818,14 +1385,6 @@ CL_CGameRendering
 =====================
 */
 void CL_CGameRendering( stereoFrame_t stereo ) {
-	//rww - RAGDOLL_BEGIN
-	if (!com_sv_running->integer)
-	{ //set the server time to match the client time, if we don't have a server going.
-		re.G2API_SetTime(cl.serverTime, 0);
-	}
-	re.G2API_SetTime(cl.serverTime, 1);
-	//rww - RAGDOLL_END
-
 	VM_Call( cgvm, CG_DRAW_ACTIVE_FRAME, cl.serverTime, stereo, clc.demoplaying );
 	VM_Debug( 0 );
 }
diff --git a/codemp/client/cl_console.cpp b/codemp/client/cl_console.cpp
index 871e927..20783b5 100644
--- a/codemp/client/cl_console.cpp
+++ b/codemp/client/cl_console.cpp
@@ -4,7 +4,6 @@
 // console.c
 
 #include "client.h"
-#include "qcommon/stringed_ingame.h"
 #include "qcommon/game_version.h"
 
 
@@ -148,7 +147,7 @@ void Con_Dump_f (void)
 
 	if (Cmd_Argc() != 2)
 	{
-		Com_Printf ("%s\n", SE_GetString("CON_TEXT_DUMP_USAGE"));
+		Com_Printf ("usage: condump <filename>\n" );
 		return;
 	}
 
@@ -258,8 +257,8 @@ void Con_CheckResize (void)
 	else
 	{
 		// on wide screens, we will center the text
-		con.xadjust = 640.0f / cls.glconfig.vidWidth;
-		con.yadjust = 480.0f / cls.glconfig.vidHeight;
+		con.xadjust = 1;//640.0f / cls.glconfig.vidWidth;
+		con.yadjust = 1;//480.0f / cls.glconfig.vidHeight;
 
 		oldwidth = con.linewidth;
 		con.linewidth = width;
@@ -373,10 +372,10 @@ void CL_ConsolePrint( const char *txt) {
 	int prev;							// NERVE - SMF
 
 	// TTimo - prefix for text that shows up in console but not in notify
-	// backported from RTCW
-	if ( !Q_strncmp( txt, "[skipnotify]", 12 ) ) {
+	// backported from RTCW adjusted for SOF2
+	if ( txt[0] == '@' ) {
 		skipnotify = qtrue;
-		txt += 12;
+		txt += 1;
 	}
 	if ( txt[0] == '*' ) {
 		skipnotify = qtrue;
@@ -483,14 +482,14 @@ void Con_DrawInput (void) {
 		return;
 	}
 
-	y = con.vislines - ( SMALLCHAR_HEIGHT * (re.Language_IsAsian() ? 1.5 : 2) );
+	y = con.vislines - ( SMALLCHAR_HEIGHT * 2 );
 
 	re.SetColor( con.color );
 
 	SCR_DrawSmallChar( (int)(con.xadjust + 1 * SMALLCHAR_WIDTH), y, ']' );
 
 	Field_Draw( &kg.g_consoleField, (int)(con.xadjust + 2 * SMALLCHAR_WIDTH), y,
-				SCREEN_WIDTH - 3 * SMALLCHAR_WIDTH, qtrue );
+				cls.glconfig.vidWidth - 3 * SMALLCHAR_WIDTH, qtrue );
 }
 
 
@@ -539,53 +538,22 @@ void Con_DrawNotify (void)
 			cl_conXOffset = Cvar_Get ("cl_conXOffset", "0", 0);
 		}
 
-		// asian language needs to use the new font system to print glyphs...
-		//
-		// (ignore colours since we're going to print the whole thing as one string)
-		//
-		if (re.Language_IsAsian())
-		{
-			static int iFontIndex = re.RegisterFont("ocr_a");	// this seems naughty
-			const float fFontScale = 0.75f*con.yadjust;
-			const int iPixelHeightToAdvance =   2+(1.3/con.yadjust) * re.Font_HeightPixels(iFontIndex, fFontScale);	// for asian spacing, since we don't want glyphs to touch.
-
-			// concat the text to be printed...
-			//
-			char sTemp[4096]={0};	// ott
-			for (x = 0 ; x < con.linewidth ; x++) 
+		for (x = 0 ; x < con.linewidth ; x++) {
+			if ( ( text[x] & 0xff ) == ' ' ) {
+				continue;
+			}
+			if ( ( (text[x]>>8)&7 ) != currentColor ) {
+				currentColor = (text[x]>>8)&7;
+				re.SetColor( g_color_table[currentColor] );
+			}
+			if (!cl_conXOffset)
 			{
-				if ( ( (text[x]>>8)&7 ) != currentColor ) {
-					currentColor = (text[x]>>8)&7;
-					strcat(sTemp,va("^%i", (text[x]>>8)&7) );
-				}
-				strcat(sTemp,va("%c",text[x] & 0xFF));				
+				cl_conXOffset = Cvar_Get ("cl_conXOffset", "0", 0);
 			}
-			//
-			// and print...
-			//
-			re.Font_DrawString(cl_conXOffset->integer + con.xadjust*(con.xadjust + (1*SMALLCHAR_WIDTH/*aesthetics*/)), con.yadjust*(v), sTemp, g_color_table[currentColor], iFontIndex, -1, fFontScale);
-
-			v +=  iPixelHeightToAdvance;
+			SCR_DrawSmallChar( (int)(cl_conXOffset->integer + con.xadjust + (x+1)*SMALLCHAR_WIDTH), v, text[x] & 0xff );
 		}
-		else
-		{		
-			for (x = 0 ; x < con.linewidth ; x++) {
-				if ( ( text[x] & 0xff ) == ' ' ) {
-					continue;
-				}
-				if ( ( (text[x]>>8)&7 ) != currentColor ) {
-					currentColor = (text[x]>>8)&7;
-					re.SetColor( g_color_table[currentColor] );
-				}
-				if (!cl_conXOffset)
-				{
-					cl_conXOffset = Cvar_Get ("cl_conXOffset", "0", 0);
-				}
-				SCR_DrawSmallChar( (int)(cl_conXOffset->integer + con.xadjust + (x+1)*SMALLCHAR_WIDTH), v, text[x] & 0xff );
-			}
 
-			v += SMALLCHAR_HEIGHT;
-		}
+		v += SMALLCHAR_HEIGHT;
 	}
 
 	re.SetColor( NULL );
@@ -599,21 +567,21 @@ void Con_DrawNotify (void)
 	{
 		if (chat_team)
 		{
-			chattext = SE_GetString("MP_SVGAME", "SAY_TEAM");
-			SCR_DrawBigString (8, v, chattext, 1.0f );
+			chattext = "say_team:";
+			SCR_DrawBigString (16, v, chattext, 1.0f );
 			skip = strlen(chattext)+1;
 		}
 		else
 		{
-			chattext = SE_GetString("MP_SVGAME", "SAY");
-			SCR_DrawBigString (8, v, chattext, 1.0f );
+			chattext = "say:";
+			SCR_DrawBigString (16, v, chattext, 1.0f );
 			skip = strlen(chattext)+1;
 		}
 
-		Field_BigDraw( &chatField, skip * BIGCHAR_WIDTH, v,
-			SCREEN_WIDTH - ( skip + 1 ) * BIGCHAR_WIDTH, qtrue );
+		Field_BigDraw( &chatField, skip * GIANTCHAR_HEIGHT/2, v,
+			cls.glconfig.vidWidth - ( skip + 1 ) * GIANTCHAR_HEIGHT/2, qtrue );
 
-		v += BIGCHAR_HEIGHT;
+		v += GIANTCHAR_HEIGHT/2;
 	}
 
 }
@@ -642,19 +610,19 @@ void Con_DrawSolidConsole( float frac ) {
 		lines = cls.glconfig.vidHeight;
 
 	// draw the background
-	y = (int) (frac * SCREEN_HEIGHT - 2);
+	y = (int) (frac * cls.glconfig.vidHeight - 2);
 	if ( y < 1 ) {
 		y = 0;
 	}
 	else {
-		SCR_DrawPic( 0, 0, SCREEN_WIDTH, (float) y, cls.consoleShader );
+		SCR_DrawPic( 0, 0, cls.glconfig.vidWidth, (float) y, cls.consoleShader );
 	}
 
-	const vec4_t color = { 0.509f, 0.609f, 0.847f,  1.0f};
-	// draw the bottom bar and version number
+	const vec4_t color = { 1.0f, 0.0f, 0.0f,  1.0f};
 
+	// draw the bottom bar and version number
 	re.SetColor( color );
-	re.DrawStretchPic( 0, y, SCREEN_WIDTH, 2, 0, 0, 0, 0, cls.whiteShader );
+	re.DrawStretchPic( 0, y, cls.glconfig.vidWidth, 4, 0, 0, 0, 0, cls.whiteShader );
 
 	i = strlen( JK_VERSION );
 
@@ -690,17 +658,7 @@ void Con_DrawSolidConsole( float frac ) {
 	currentColor = 7;
 	re.SetColor( g_color_table[currentColor] );
 
-	static int iFontIndexForAsian = 0;
-	const float fFontScaleForAsian = 0.75f*con.yadjust;
 	int iPixelHeightToAdvance = SMALLCHAR_HEIGHT;
-	if (re.Language_IsAsian())
-	{
-		if (!iFontIndexForAsian) 
-		{
-			iFontIndexForAsian = re.RegisterFont("ocr_a");
-		}
-		iPixelHeightToAdvance = (1.3/con.yadjust) * re.Font_HeightPixels(iFontIndexForAsian, fFontScaleForAsian);	// for asian spacing, since we don't want glyphs to touch.
-	}
 
 	for (i=0 ; i<rows ; i++, y -= iPixelHeightToAdvance, row--)
 	{
@@ -713,41 +671,16 @@ void Con_DrawSolidConsole( float frac ) {
 
 		text = con.text + (row % con.totallines)*con.linewidth;
 
-		// asian language needs to use the new font system to print glyphs...
-		//
-		// (ignore colours since we're going to print the whole thing as one string)
-		//
-		if (re.Language_IsAsian())
-		{
-			// concat the text to be printed...
-			//
-			char sTemp[4096]={0};	// ott
-			for (x = 0 ; x < con.linewidth ; x++) 
-			{
-				if ( ( (text[x]>>8)&7 ) != currentColor ) {
-					currentColor = (text[x]>>8)&7;
-					strcat(sTemp,va("^%i", (text[x]>>8)&7) );
-				}
-				strcat(sTemp,va("%c",text[x] & 0xFF));				
+		for (x=0 ; x<con.linewidth ; x++) {
+			if ( ( text[x] & 0xff ) == ' ' ) {
+				continue;
 			}
-			//
-			// and print...
-			//
-			re.Font_DrawString(con.xadjust*(con.xadjust + (1*SMALLCHAR_WIDTH/*(aesthetics)*/)), con.yadjust*(y), sTemp, g_color_table[currentColor], iFontIndexForAsian, -1, fFontScaleForAsian);
-		}
-		else
-		{		
-			for (x=0 ; x<con.linewidth ; x++) {
-				if ( ( text[x] & 0xff ) == ' ' ) {
-					continue;
-				}
-
-				if ( ( (text[x]>>8)&7 ) != currentColor ) {
-					currentColor = (text[x]>>8)&7;
-					re.SetColor( g_color_table[currentColor] );
-				}
-				SCR_DrawSmallChar(  (int) (con.xadjust + (x+1)*SMALLCHAR_WIDTH), y, text[x] & 0xff );
+
+			if ( ( (text[x]>>8)&7 ) != currentColor ) {
+				currentColor = (text[x]>>8)&7;
+				re.SetColor( g_color_table[currentColor] );
 			}
+			SCR_DrawSmallChar(  (int) (con.xadjust + (x+1)*SMALLCHAR_WIDTH), y, text[x] & 0xff );
 		}
 	}
 
diff --git a/codemp/client/cl_input.cpp b/codemp/client/cl_input.cpp
index 24b5d56..9e18c58 100644
--- a/codemp/client/cl_input.cpp
+++ b/codemp/client/cl_input.cpp
@@ -7,12 +7,6 @@
 unsigned	frame_msec;
 int			old_com_frameTime;
 
-float cl_mPitchOverride = 0.0f;
-float cl_mYawOverride = 0.0f;
-float cl_mSensitivityOverride = 0.0f;
-qboolean cl_bUseFighterPitch = qfalse;
-qboolean cl_crazyShipControls = qfalse;
-
 #ifdef VEH_CONTROL_SCHEME_4
 #define	OVERRIDE_MOUSE_SENSITIVITY 5.0f//20.0f = 180 degree turn in one mouse swipe across keyboard
 #else// VEH_CONTROL_SCHEME_4
@@ -55,74 +49,6 @@ void IN_Button10Down(void);
 void IN_Button10Up(void);
 void IN_Button6Down(void);
 void IN_Button6Up(void);
-void IN_UseGivenForce(void)
-{
-	char *c = Cmd_Argv(1);
-	int forceNum =-1;
-	int genCmdNum = 0;
-
-	if(c) {
-		forceNum = atoi(c);
-	} else {
-		return;
-	}
-
-	switch(forceNum) {
-	case FP_DRAIN:
-		IN_Button11Down();
-		IN_Button11Up();
-		break;
-	case FP_PUSH:
-		genCmdNum = GENCMD_FORCE_THROW;
-		break;
-	case FP_SPEED:
-		genCmdNum = GENCMD_FORCE_SPEED;
-		break;
-	case FP_PULL:
-		genCmdNum = GENCMD_FORCE_PULL;
-		break;
-	case FP_TELEPATHY:
-		genCmdNum = GENCMD_FORCE_DISTRACT;
-		break;
-	case FP_GRIP:
-		IN_Button6Down();
-		IN_Button6Up();
-		break;
-	case FP_LIGHTNING:
-		IN_Button10Down();
-		IN_Button10Up();
-		break;
-	case FP_RAGE:
-		genCmdNum = GENCMD_FORCE_RAGE;
-		break;
-	case FP_PROTECT:
-		genCmdNum = GENCMD_FORCE_PROTECT;
-		break;
-	case FP_ABSORB:
-		genCmdNum = GENCMD_FORCE_ABSORB;
-		break;
-	case FP_SEE:
-		genCmdNum = GENCMD_FORCE_SEEING;
-		break;
-	case FP_HEAL:
-		genCmdNum = GENCMD_FORCE_HEAL;
-		break;
-	case FP_TEAM_HEAL:
-		genCmdNum = GENCMD_FORCE_HEALOTHER;
-		break;
-	case FP_TEAM_FORCE:
-		genCmdNum = GENCMD_FORCE_FORCEPOWEROTHER;
-		break;
-	default:
-		assert(0);
-		break;
-	}
-
-	if(genCmdNum != 0) {
-		cl.gcmdSendValue = qtrue;
-		cl.gcmdValue = genCmdNum;
-	}
-}
 
 void IN_MLookDown( void ) {
 	in_mlooking = qtrue;
@@ -135,241 +61,13 @@ void IN_MLookUp( void ) {
 	}
 }
 
-void IN_GenCMD1( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_SABERSWITCH;
-}
-
-void IN_GenCMD2( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_ENGAGE_DUEL;
-}
-
-void IN_GenCMD3( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_HEAL;
-}
-
-void IN_GenCMD4( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_SPEED;
-}
-
-void IN_GenCMD5( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_PULL;
-}
-
-void IN_GenCMD6( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_DISTRACT;
-}
-
-void IN_GenCMD7( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_RAGE;
-}
-
-void IN_GenCMD8( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_PROTECT;
-}
-
-void IN_GenCMD9( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_ABSORB;
-}
-
-void IN_GenCMD10( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_HEALOTHER;
-}
-
-void IN_GenCMD11( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_FORCEPOWEROTHER;
-}
-
-void IN_GenCMD12( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_SEEING;
-}
-
-void IN_GenCMD13( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_SEEKER;
-}
-
-void IN_GenCMD14( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_FIELD;
-}
-
-void IN_GenCMD15( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_BACTA;
-}
-
-void IN_GenCMD16( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_ELECTROBINOCULARS;
-}
-
-void IN_GenCMD17( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_ZOOM;
-}
-
-void IN_GenCMD18( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_SENTRY;
-}
-
-void IN_GenCMD19( void )
-{
-	if (Cvar_VariableIntegerValue("d_saberStanceDebug"))
-	{
-		Com_Printf("SABERSTANCEDEBUG: Gencmd on client set successfully.\n");
-	}
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_SABERATTACKCYCLE;
-}
-
-void IN_GenCMD20( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FORCE_THROW;
-}
-
-void IN_GenCMD21( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_JETPACK;
-}
-
-void IN_GenCMD22( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_BACTABIG;
-}
-
-void IN_GenCMD23( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_HEALTHDISP;
-}
-
-void IN_GenCMD24( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_AMMODISP;
-}
-
-void IN_GenCMD25( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_EWEB;
-}
-
-void IN_GenCMD26( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_USE_CLOAK;
-}
-
-void IN_GenCMD27( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_TAUNT;
-}
-
-void IN_GenCMD28( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_BOW;
-}
-
-void IN_GenCMD29( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_MEDITATE;
-}
-
-void IN_GenCMD30( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_FLOURISH;
-}
-
-void IN_GenCMD31( void )
-{
-	cl.gcmdSendValue = qtrue;
-	cl.gcmdValue = GENCMD_GLOAT;
-}
-
-
-//toggle automap view mode
-static bool g_clAutoMapMode = false;
-void IN_AutoMapButton(void)
-{
-	g_clAutoMapMode = !g_clAutoMapMode;
-}
-
-//toggle between automap, radar, nothing
-extern cvar_t *r_autoMap;
-void IN_AutoMapToggle(void)
-{
-
-	if (Cvar_VariableIntegerValue("cg_drawRadar"))
-	{
-		Cvar_Set("cg_drawRadar", "0");
-	}
-	else
-	{
-		Cvar_Set("cg_drawRadar", "1");
-	}
-	/*
-	if (r_autoMap && r_autoMap->integer)
-	{ //automap off, radar on
-		Cvar_Set("r_autoMap", "0");
-		Cvar_Set("cg_drawRadar", "1");
-	}
-	else if (Cvar_VariableIntegerValue("cg_drawRadar"))
-	{ //radar off, automap should be off too
-		Cvar_Set("cg_drawRadar", "0");
-	}
-	else
-	{ //turn automap on
-		Cvar_Set("r_autoMap", "1");
-	}
-	*/
-}
-
 void IN_VoiceChatButton(void)
 {
 	if (!uivm)
 	{ //ui not loaded so this command is useless
 		return;
 	}
-	VM_Call( uivm, UI_SET_ACTIVE_MENU, UIMENU_VOICECHAT );
+	//VM_Call( uivm, UI_SET_ACTIVE_MENU, UIMENU_VOICECHAT );
 }
 
 void IN_KeyDown( kbutton_t *b ) {
@@ -491,143 +189,21 @@ float CL_KeyState( kbutton_t *key ) {
 	return val;
 }
 
-#define		AUTOMAP_KEY_FORWARD			1
-#define		AUTOMAP_KEY_BACK			2
-#define		AUTOMAP_KEY_YAWLEFT			3
-#define		AUTOMAP_KEY_YAWRIGHT		4
-#define		AUTOMAP_KEY_PITCHUP			5
-#define		AUTOMAP_KEY_PITCHDOWN		6
-#define		AUTOMAP_KEY_DEFAULTVIEW		7
-static autoMapInput_t			g_clAutoMapInput;
-//intercept certain keys during automap mode
-static void CL_AutoMapKey(int autoMapKey, qboolean up)
-{
-	autoMapInput_t *data = (autoMapInput_t *)cl.mSharedMemory;
-
-	switch (autoMapKey)
-	{
-	case AUTOMAP_KEY_FORWARD:
-        if (up)
-		{
-			g_clAutoMapInput.up = 0.0f;
-		}
-		else
-		{
-			g_clAutoMapInput.up = 16.0f;
-		}
-		break;
-	case AUTOMAP_KEY_BACK:
-        if (up)
-		{
-			g_clAutoMapInput.down = 0.0f;
-		}
-		else
-		{
-			g_clAutoMapInput.down = 16.0f;
-		}
-		break;
-	case AUTOMAP_KEY_YAWLEFT:
-		if (up)
-		{
-			g_clAutoMapInput.yaw = 0.0f;
-		}
-		else
-		{
-			g_clAutoMapInput.yaw = -4.0f;
-		}
-		break;
-	case AUTOMAP_KEY_YAWRIGHT:
-		if (up)
-		{
-			g_clAutoMapInput.yaw = 0.0f;
-		}
-		else
-		{
-			g_clAutoMapInput.yaw = 4.0f;
-		}
-		break;
-	case AUTOMAP_KEY_PITCHUP:
-		if (up)
-		{
-			g_clAutoMapInput.pitch = 0.0f;
-		}
-		else
-		{
-			g_clAutoMapInput.pitch = -4.0f;
-		}
-		break;
-	case AUTOMAP_KEY_PITCHDOWN:
-		if (up)
-		{
-			g_clAutoMapInput.pitch = 0.0f;
-		}
-		else
-		{
-			g_clAutoMapInput.pitch = 4.0f;
-		}
-		break;
-	case AUTOMAP_KEY_DEFAULTVIEW:
-		memset(&g_clAutoMapInput, 0, sizeof(autoMapInput_t));
-		g_clAutoMapInput.goToDefaults = qtrue;
-		break;
-	default:
-		break;
-	}
-
-	memcpy(data, &g_clAutoMapInput, sizeof(autoMapInput_t));
-
-	if (cgvm)
-	{
-		VM_Call(cgvm, CG_AUTOMAP_INPUT, 0);
-	}
-
-	g_clAutoMapInput.goToDefaults = qfalse;
-}
-
-
 void IN_UpDown(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_PITCHUP, qfalse);
-	}
-	else
-	{
-		IN_KeyDown(&in_up);
-	}
+	IN_KeyDown(&in_up);
 }
 void IN_UpUp(void) 
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_PITCHUP, qtrue);
-	}
-	else
-	{
-		IN_KeyUp(&in_up);
-	}
+	IN_KeyUp(&in_up);
 }
 void IN_DownDown(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_PITCHDOWN, qfalse);
-	}
-	else
-	{
-		IN_KeyDown(&in_down);
-	}
+	IN_KeyDown(&in_down);
 }
 void IN_DownUp(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_PITCHDOWN, qtrue);
-	}
-	else
-	{
-		IN_KeyUp(&in_down);
-	}
+	IN_KeyUp(&in_down);
 }
 void IN_LeftDown(void) {IN_KeyDown(&in_left);}
 void IN_LeftUp(void) {IN_KeyUp(&in_left);}
@@ -635,47 +211,19 @@ void IN_RightDown(void) {IN_KeyDown(&in_right);}
 void IN_RightUp(void) {IN_KeyUp(&in_right);}
 void IN_ForwardDown(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_FORWARD, qfalse);
-	}
-	else
-	{
-		IN_KeyDown(&in_forward);
-	}
+	IN_KeyDown(&in_forward);
 }
 void IN_ForwardUp(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_FORWARD, qtrue);
-	}
-	else
-	{
-		IN_KeyUp(&in_forward);
-	}
+	IN_KeyUp(&in_forward);
 }
 void IN_BackDown(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_BACK, qfalse);
-	}
-	else
-	{
-		IN_KeyDown(&in_back);
-	}
+	IN_KeyDown(&in_back);
 }
 void IN_BackUp(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_BACK, qtrue);
-	}
-	else
-	{
-		IN_KeyUp(&in_back);
-	}
+	IN_KeyUp(&in_back);
 }
 void IN_LookupDown(void) {IN_KeyDown(&in_lookup);}
 void IN_LookupUp(void) {IN_KeyUp(&in_lookup);}
@@ -683,47 +231,19 @@ void IN_LookdownDown(void) {IN_KeyDown(&in_lookdown);}
 void IN_LookdownUp(void) {IN_KeyUp(&in_lookdown);}
 void IN_MoveleftDown(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_YAWLEFT, qfalse);
-	}
-	else
-	{
-		IN_KeyDown(&in_moveleft);
-	}
+	IN_KeyDown(&in_moveleft);
 }
 void IN_MoveleftUp(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_YAWLEFT, qtrue);
-	}
-	else
-	{
-		IN_KeyUp(&in_moveleft);
-	}
+	IN_KeyUp(&in_moveleft);
 }
 void IN_MoverightDown(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_YAWRIGHT, qfalse);
-	}
-	else
-	{
-		IN_KeyDown(&in_moveright);
-	}
+	IN_KeyDown(&in_moveright);
 }
 void IN_MoverightUp(void)
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_YAWRIGHT, qtrue);
-	}
-	else
-	{
-		IN_KeyUp(&in_moveright);
-	}
+	IN_KeyUp(&in_moveright);
 }
 
 void IN_SpeedDown(void) {IN_KeyDown(&in_speed);}
@@ -746,14 +266,7 @@ void IN_Button4Down(void) {IN_KeyDown(&in_buttons[4]);}
 void IN_Button4Up(void) {IN_KeyUp(&in_buttons[4]);}
 void IN_Button5Down(void) //use key
 {
-	if (g_clAutoMapMode)
-	{
-		CL_AutoMapKey(AUTOMAP_KEY_DEFAULTVIEW, qfalse);
-	}
-	else
-	{
-		IN_KeyDown(&in_buttons[5]);
-	}
+	IN_KeyDown(&in_buttons[5]);
 }
 void IN_Button5Up(void) {IN_KeyUp(&in_buttons[5]);}
 void IN_Button6Down(void) {IN_KeyDown(&in_buttons[6]);}
@@ -826,44 +339,12 @@ void CL_AdjustAngles( void ) {
 	}
 
 	if ( !in_strafe.active ) {
-		if ( cl_mYawOverride )
-		{
-			if ( cl_mSensitivityOverride )
-			{
-				cl.viewangles[YAW] -= cl_mYawOverride*cl_mSensitivityOverride*speed*cl_yawspeed->value*CL_KeyState (&in_right);
-				cl.viewangles[YAW] += cl_mYawOverride*cl_mSensitivityOverride*speed*cl_yawspeed->value*CL_KeyState (&in_left);
-			}
-			else
-			{
-				cl.viewangles[YAW] -= cl_mYawOverride*OVERRIDE_MOUSE_SENSITIVITY*speed*cl_yawspeed->value*CL_KeyState (&in_right);
-				cl.viewangles[YAW] += cl_mYawOverride*OVERRIDE_MOUSE_SENSITIVITY*speed*cl_yawspeed->value*CL_KeyState (&in_left);
-			}
-		}
-		else
-		{
-			cl.viewangles[YAW] -= speed*cl_yawspeed->value*CL_KeyState (&in_right);
-			cl.viewangles[YAW] += speed*cl_yawspeed->value*CL_KeyState (&in_left);
-		}
+		cl.viewangles[YAW] -= speed*cl_yawspeed->value*CL_KeyState (&in_right);
+		cl.viewangles[YAW] += speed*cl_yawspeed->value*CL_KeyState (&in_left);
 	}
 
-	if ( cl_mPitchOverride )
-	{
-		if ( cl_mSensitivityOverride )
-		{
-			cl.viewangles[PITCH] -= cl_mPitchOverride*cl_mSensitivityOverride*speed*cl_pitchspeed->value * CL_KeyState (&in_lookup);
-			cl.viewangles[PITCH] += cl_mPitchOverride*cl_mSensitivityOverride*speed*cl_pitchspeed->value * CL_KeyState (&in_lookdown);
-		}
-		else
-		{
-			cl.viewangles[PITCH] -= cl_mPitchOverride*OVERRIDE_MOUSE_SENSITIVITY*speed*cl_pitchspeed->value * CL_KeyState (&in_lookup);
-			cl.viewangles[PITCH] += cl_mPitchOverride*OVERRIDE_MOUSE_SENSITIVITY*speed*cl_pitchspeed->value * CL_KeyState (&in_lookdown);
-		}
-	}
-	else
-	{
-		cl.viewangles[PITCH] -= speed*cl_pitchspeed->value * CL_KeyState (&in_lookup);
-		cl.viewangles[PITCH] += speed*cl_pitchspeed->value * CL_KeyState (&in_lookdown);
-	}
+	cl.viewangles[PITCH] -= speed*cl_pitchspeed->value * CL_KeyState (&in_lookup);
+	cl.viewangles[PITCH] += speed*cl_pitchspeed->value * CL_KeyState (&in_lookdown);
 }
 
 /*
@@ -887,7 +368,7 @@ void CL_KeyMove( usercmd_t *cmd ) {
 		cmd->buttons &= ~BUTTON_WALKING;
 	} else {
 		cmd->buttons |= BUTTON_WALKING;
-		movespeed = 46;
+		movespeed = 64;
 	}
 
 	forward = 0;
@@ -919,19 +400,7 @@ CL_MouseEvent
 =================
 */
 void CL_MouseEvent( int dx, int dy, int time ) {
-	if (g_clAutoMapMode && cgvm)
-	{ //automap input
-		autoMapInput_t *data = (autoMapInput_t *)cl.mSharedMemory;
-
-		g_clAutoMapInput.yaw = dx;
-		g_clAutoMapInput.pitch = dy;
-		memcpy(data, &g_clAutoMapInput, sizeof(autoMapInput_t));
-		VM_Call(cgvm, CG_AUTOMAP_INPUT, 1);
-
-		g_clAutoMapInput.yaw = 0.0f;
-		g_clAutoMapInput.pitch = 0.0f;
-	}
-	else if ( cls.keyCatchers & KEYCATCH_UI ) {
+	if ( cls.keyCatchers & KEYCATCH_UI ) {
 		VM_Call( uivm, UI_MOUSE_EVENT, dx, dy );
 	} else if (cls.keyCatchers & KEYCATCH_CGAME) {
 		VM_Call (cgvm, CG_MOUSE_EVENT, dx, dy);
@@ -984,42 +453,14 @@ void CL_JoystickMove( usercmd_t *cmd ) {
 	}
 
 	if ( !in_strafe.active ) {
-		if ( cl_mYawOverride )
-		{
-			if ( cl_mSensitivityOverride )
-			{
-				cl.viewangles[YAW] += cl_mYawOverride * cl_mSensitivityOverride * cl.joystickAxis[AXIS_SIDE]/2.0f;
-			}
-			else
-			{
-				cl.viewangles[YAW] += cl_mYawOverride * OVERRIDE_MOUSE_SENSITIVITY * cl.joystickAxis[AXIS_SIDE]/2.0f;
-			}
-		}
-		else
-		{
-			cl.viewangles[YAW] += anglespeed * (cl_yawspeed->value / 100.0f) * cl.joystickAxis[AXIS_SIDE];
-		}
+		cl.viewangles[YAW] += anglespeed * (cl_yawspeed->value / 100.0f) * cl.joystickAxis[AXIS_SIDE];
 	} else
 	{
 		cmd->rightmove = ClampChar( cmd->rightmove + cl.joystickAxis[AXIS_SIDE] );
 	}
 
 	if ( in_mlooking || cl_freelook->integer ) {
-		if ( cl_mPitchOverride )
-		{
-			if ( cl_mSensitivityOverride )
-			{
-				cl.viewangles[PITCH] += cl_mPitchOverride * cl_mSensitivityOverride * cl.joystickAxis[AXIS_FORWARD]/2.0f;
-			}
-			else
-			{
-				cl.viewangles[PITCH] += cl_mPitchOverride * OVERRIDE_MOUSE_SENSITIVITY * cl.joystickAxis[AXIS_FORWARD]/2.0f;
-			}
-		}
-		else
-		{
-			cl.viewangles[PITCH] += anglespeed * (cl_pitchspeed->value / 100.0f) * cl.joystickAxis[AXIS_FORWARD];
-		}
+		cl.viewangles[PITCH] += anglespeed * (cl_pitchspeed->value / 100.0f) * cl.joystickAxis[AXIS_FORWARD];
 	} else
 	{
 		cmd->forwardmove = ClampChar( cmd->forwardmove + cl.joystickAxis[AXIS_FORWARD] );
@@ -1038,7 +479,6 @@ void CL_MouseMove( usercmd_t *cmd ) {
 	float	accelSensitivity;
 	float	rate;
 	const float	speed = static_cast<float>(frame_msec);
-	const float pitch = cl_bUseFighterPitch?m_pitchVeh->value:m_pitch->value;
 
 	// allow mouse smoothing
 	if ( m_filter->integer ) {
@@ -1054,27 +494,9 @@ void CL_MouseMove( usercmd_t *cmd ) {
 	cl.mouseDy[cl.mouseIndex] = 0;
 
 	rate = SQRTFAST( mx * mx + my * my ) / speed;
-	if ( cl_mYawOverride || cl_mPitchOverride )
-	{//FIXME: different people have different speed mouses,
-		if ( cl_mSensitivityOverride )
-		{
-			//this will fuck things up for them, need to clamp 
-			//max input?
-			accelSensitivity = cl_mSensitivityOverride;
-		}
-		else
-		{
-			accelSensitivity = cl_sensitivity->value + rate * cl_mouseAccel->value;
-			// scale by FOV
-			accelSensitivity *= cl.cgameSensitivity;
-		}
-	}
-	else
-	{
-		accelSensitivity = cl_sensitivity->value + rate * cl_mouseAccel->value;
-		// scale by FOV
-		accelSensitivity *= cl.cgameSensitivity;
-	}
+	accelSensitivity = cl_sensitivity->value + rate * cl_mouseAccel->value;
+	// scale by FOV
+	accelSensitivity *= cl.cgameSensitivity;
 
 	if ( rate && cl_showMouseRate->integer ) {
 		Com_Printf( "%f : %f\n", rate, accelSensitivity );
@@ -1091,49 +513,18 @@ void CL_MouseMove( usercmd_t *cmd ) {
 	if ( in_strafe.active ) {
 		cmd->rightmove = ClampChar( cmd->rightmove + m_side->value * mx );
 	} else {
-		if ( cl_mYawOverride )
-		{
-			cl.viewangles[YAW] -= cl_mYawOverride * mx;
-		}
-		else
-		{
-			cl.viewangles[YAW] -= m_yaw->value * mx;
-		}
+		cl.viewangles[YAW] -= m_yaw->value * mx;
 	}
 
 	if ( (in_mlooking || cl_freelook->integer) && !in_strafe.active ) {
 		// VVFIXME - This is supposed to be a CVAR
 		const float cl_pitchSensitivity = 1.0f;
-		if ( cl_mPitchOverride )
-		{
-			if ( pitch > 0 )
-			{
-				cl.viewangles[PITCH] += cl_mPitchOverride * my * cl_pitchSensitivity;
-			}
-			else
-			{
-				cl.viewangles[PITCH] -= cl_mPitchOverride * my * cl_pitchSensitivity;
-			}
-		}
-		else
-		{
-			cl.viewangles[PITCH] += pitch * my * cl_pitchSensitivity;
-		}
+		cl.viewangles[PITCH] += m_pitch->value * my * cl_pitchSensitivity;
 	} else {
 		cmd->forwardmove = ClampChar( cmd->forwardmove - m_forward->value * my );
 	}
 }
 
-qboolean CL_NoUseableForce(void)
-{
-	if (!cgvm)
-	{ //ahh, no cgame loaded
-		return qfalse;
-	}
-
-	return (qboolean)VM_Call(cgvm, CG_GET_USEABLE_FORCE);
-}
-
 /*
 ==============
 CL_CmdButtons
@@ -1154,15 +545,6 @@ void CL_CmdButtons( usercmd_t *cmd ) {
 		in_buttons[i].wasPressed = qfalse;
 	}
 
-	if (cmd->buttons & BUTTON_FORCEPOWER)
-	{ //check for transferring a use force to a use inventory...
-		if ((cmd->buttons & BUTTON_USE) || CL_NoUseableForce())
-		{ //it's pushed, remap it!
-			cmd->buttons &= ~BUTTON_FORCEPOWER;
-			cmd->buttons |= BUTTON_USE_HOLDABLE;
-		}
-	}
-
 	if ( cls.keyCatchers ) {
 		cmd->buttons |= BUTTON_TALK;
 	}
@@ -1187,19 +569,12 @@ void CL_FinishMove( usercmd_t *cmd ) {
 
 	// copy the state that the cgame is currently sending
 	cmd->weapon = cl.cgameUserCmdValue;
-	cmd->forcesel = cl.cgameForceSelection;
-	cmd->invensel = cl.cgameInvenSelection;
 
 	if (cl.gcmdSendValue)
 	{
-		cmd->generic_cmd = cl.gcmdValue;
 		//cl.gcmdSendValue = qfalse;
 		cl.gcmdSentValue = qtrue;
 	}
-	else
-	{
-		cmd->generic_cmd = 0;
-	}
 
 	// send the current server time so the amount of movement
 	// can be determined without allowing cheating
@@ -1213,56 +588,11 @@ void CL_FinishMove( usercmd_t *cmd ) {
 		cl.cgameViewAngleForceTime = 0;
 	}
 
-	if ( cl_crazyShipControls )
-	{
-		float pitchSubtract, pitchDelta, yawDelta;
-
-		yawDelta = AngleSubtract(cl.viewangles[YAW],cl_lastViewAngles[YAW]);
-		//yawDelta *= (4.0f*pVeh->m_fTimeModifier);
-		cl_sendAngles[ROLL] -= yawDelta;
-
-		float nRoll = fabs(cl_sendAngles[ROLL]);
-
-		pitchDelta = AngleSubtract(cl.viewangles[PITCH],cl_lastViewAngles[PITCH]);
-		//pitchDelta *= (2.0f*pVeh->m_fTimeModifier);
-		pitchSubtract = pitchDelta * (nRoll/90.0f);
-		cl_sendAngles[PITCH] += pitchDelta-pitchSubtract;
-
-		//yaw-roll calc should be different
-		if (nRoll > 90.0f)
-		{
-			nRoll -= 180.0f;
-		}
-		if (nRoll < 0.0f)
-		{
-			nRoll = -nRoll;
-		}
-		pitchSubtract = pitchDelta * (nRoll/90.0f);
-		if ( cl_sendAngles[ROLL] > 0.0f )
-		{
-			cl_sendAngles[YAW] += pitchSubtract;
-		}
-		else
-		{
-			cl_sendAngles[YAW] -= pitchSubtract;
-		}
-		
-		cl_sendAngles[PITCH] = AngleNormalize180( cl_sendAngles[PITCH] );
-		cl_sendAngles[YAW] = AngleNormalize360( cl_sendAngles[YAW] );
-		cl_sendAngles[ROLL] = AngleNormalize180( cl_sendAngles[ROLL] );
-
-		for (i=0 ; i<3 ; i++) {
-			cmd->angles[i] = ANGLE2SHORT(cl_sendAngles[i]);
-		}
-	}
-	else
-	{
-		for (i=0 ; i<3 ; i++) {
-			cmd->angles[i] = ANGLE2SHORT(cl.viewangles[i]);
-		}
-		//in case we switch to the cl_crazyShipControls
-		VectorCopy( cl.viewangles, cl_sendAngles );
+	for (i=0 ; i<3 ; i++) {
+		cmd->angles[i] = ANGLE2SHORT(cl.viewangles[i]);
 	}
+	//in case we switch to the cl_crazyShipControls
+	VectorCopy( cl.viewangles, cl_sendAngles );
 	//always needed in for the cl_crazyShipControls
 	VectorCopy( cl.viewangles, cl_lastViewAngles );
 }
@@ -1591,8 +921,7 @@ CL_InitInput
 void CL_InitInput( void ) {
 	Cmd_AddCommand ("centerview",IN_CenterView);
 
-	//Cmd_AddCommand ("+taunt", IN_Button3Down);//gesture
-	//Cmd_AddCommand ("-taunt", IN_Button3Up);
+	//The button numbers are mapped to BUTTON_ defines
 	Cmd_AddCommand ("+moveup",IN_UpDown);
 	Cmd_AddCommand ("-moveup",IN_UpUp);
 	Cmd_AddCommand ("+movedown",IN_DownDown);
@@ -1603,6 +932,7 @@ void CL_InitInput( void ) {
 	Cmd_AddCommand ("-right",IN_RightUp);
 	Cmd_AddCommand ("+forward",IN_ForwardDown);
 	Cmd_AddCommand ("-forward",IN_ForwardUp);
+	//Cmd_AddCommand ("+autorun",IN_AutoRun);
 	Cmd_AddCommand ("+back",IN_BackDown);
 	Cmd_AddCommand ("-back",IN_BackUp);
 	Cmd_AddCommand ("+lookup", IN_LookupDown);
@@ -1617,94 +947,62 @@ void CL_InitInput( void ) {
 	Cmd_AddCommand ("-moveright", IN_MoverightUp);
 	Cmd_AddCommand ("+speed", IN_SpeedDown);
 	Cmd_AddCommand ("-speed", IN_SpeedUp);
-	Cmd_AddCommand ("+attack", IN_Button0Down);
+	Cmd_AddCommand ("+attack", IN_Button0Down);//attack
 	Cmd_AddCommand ("-attack", IN_Button0Up);
-	//Cmd_AddCommand ("+force_jump", IN_Button1Down);//force jump
-	//Cmd_AddCommand ("-force_jump", IN_Button1Up);
-	Cmd_AddCommand ("+use", IN_Button5Down);
+	Cmd_AddCommand ("+lean", IN_Button3Down);//lean
+	Cmd_AddCommand ("-lean", IN_Button3Up);
+	Cmd_AddCommand ("+use", IN_Button5Down);//use object
 	Cmd_AddCommand ("-use", IN_Button5Up);
-	Cmd_AddCommand ("+force_grip", IN_Button6Down);//force grip
-	Cmd_AddCommand ("-force_grip", IN_Button6Up);
 	Cmd_AddCommand ("+altattack", IN_Button7Down);//altattack
 	Cmd_AddCommand ("-altattack", IN_Button7Up);
-	Cmd_AddCommand ("+useforce", IN_Button9Down);//active force power
-	Cmd_AddCommand ("-useforce", IN_Button9Up);
-	Cmd_AddCommand ("+force_lightning", IN_Button10Down);//active force power
-	Cmd_AddCommand ("-force_lightning", IN_Button10Up);
-	Cmd_AddCommand ("+force_drain", IN_Button11Down);//active force power
-	Cmd_AddCommand ("-force_drain", IN_Button11Up);
+	Cmd_AddCommand ("+leanleft", IN_Button13Down);//lean left
+	Cmd_AddCommand ("-leanleft", IN_Button13Up);
+	Cmd_AddCommand ("+leanright", IN_Button12Down);//lean right
+	Cmd_AddCommand ("-leanright", IN_Button12Up);
+	Cmd_AddCommand ("+reload", IN_Button6Down);//reload
+	Cmd_AddCommand ("-reload", IN_Button6Up);
+	Cmd_AddCommand ("+zoomin", IN_Button9Down);//zoom in
+	Cmd_AddCommand ("-zoomin", IN_Button9Up);
+	Cmd_AddCommand ("+zoomout", IN_Button10Down);//zoom out
+	Cmd_AddCommand ("-zoomout", IN_Button10Up);
+	Cmd_AddCommand ("+firemode", IN_Button11Down);//firemode
+	Cmd_AddCommand ("-firemode", IN_Button11Up);
+	Cmd_AddCommand ("+goggles", IN_Button2Down);//goggles
+	Cmd_AddCommand ("-goggles", IN_Button2Up);
 	//buttons
 	Cmd_AddCommand ("+button0", IN_Button0Down);//attack
 	Cmd_AddCommand ("-button0", IN_Button0Up);
-	Cmd_AddCommand ("+button1", IN_Button1Down);//force jump
+	Cmd_AddCommand ("+button1", IN_Button1Down);//talk
 	Cmd_AddCommand ("-button1", IN_Button1Up);
-	Cmd_AddCommand ("+button2", IN_Button2Down);//use holdable (not used - change to use jedi power?)
+	Cmd_AddCommand ("+button2", IN_Button2Down);//goggles
 	Cmd_AddCommand ("-button2", IN_Button2Up);
-	Cmd_AddCommand ("+button3", IN_Button3Down);//gesture
+	Cmd_AddCommand ("+button3", IN_Button3Down);//lean
 	Cmd_AddCommand ("-button3", IN_Button3Up);
 	Cmd_AddCommand ("+button4", IN_Button4Down);//walking
 	Cmd_AddCommand ("-button4", IN_Button4Up);
 	Cmd_AddCommand ("+button5", IN_Button5Down);//use object
 	Cmd_AddCommand ("-button5", IN_Button5Up);
-	Cmd_AddCommand ("+button6", IN_Button6Down);//force grip
+	Cmd_AddCommand ("+button6", IN_Button6Down);//reload
 	Cmd_AddCommand ("-button6", IN_Button6Up);
 	Cmd_AddCommand ("+button7", IN_Button7Down);//altattack
 	Cmd_AddCommand ("-button7", IN_Button7Up);
 	Cmd_AddCommand ("+button8", IN_Button8Down);
 	Cmd_AddCommand ("-button8", IN_Button8Up);
-	Cmd_AddCommand ("+button9", IN_Button9Down);//active force power
+	Cmd_AddCommand ("+button9", IN_Button9Down);//zoom in
 	Cmd_AddCommand ("-button9", IN_Button9Up);
-	Cmd_AddCommand ("+button10", IN_Button10Down);//force lightning
+	Cmd_AddCommand ("+button10", IN_Button10Down);//zoom out
 	Cmd_AddCommand ("-button10", IN_Button10Up);
-	Cmd_AddCommand ("+button11", IN_Button11Down);//force drain
+	Cmd_AddCommand ("+button11", IN_Button11Down);//firemode
 	Cmd_AddCommand ("-button11", IN_Button11Up);
-	Cmd_AddCommand ("+button12", IN_Button12Down);
+	Cmd_AddCommand ("+button12", IN_Button12Down);//lean right
 	Cmd_AddCommand ("-button12", IN_Button12Up);
-	Cmd_AddCommand ("+button13", IN_Button13Down);
+	Cmd_AddCommand ("+button13", IN_Button13Down);//lean left
 	Cmd_AddCommand ("-button13", IN_Button13Up);
 	Cmd_AddCommand ("+button14", IN_Button14Down);
 	Cmd_AddCommand ("-button14", IN_Button14Up);
 	Cmd_AddCommand ("+mlook", IN_MLookDown);
 	Cmd_AddCommand ("-mlook", IN_MLookUp);
 
-	Cmd_AddCommand ("sv_saberswitch", IN_GenCMD1);
-	Cmd_AddCommand ("engage_duel", IN_GenCMD2);
-	Cmd_AddCommand ("force_heal", IN_GenCMD3);
-	Cmd_AddCommand ("force_speed", IN_GenCMD4);
-	Cmd_AddCommand ("force_pull", IN_GenCMD5);
-	Cmd_AddCommand ("force_distract", IN_GenCMD6);
-	Cmd_AddCommand ("force_rage", IN_GenCMD7);
-	Cmd_AddCommand ("force_protect", IN_GenCMD8);
-	Cmd_AddCommand ("force_absorb", IN_GenCMD9);
-	Cmd_AddCommand ("force_healother", IN_GenCMD10);
-	Cmd_AddCommand ("force_forcepowerother", IN_GenCMD11);
-	Cmd_AddCommand ("force_seeing", IN_GenCMD12);
-	Cmd_AddCommand ("use_seeker", IN_GenCMD13);
-	Cmd_AddCommand ("use_field", IN_GenCMD14);
-	Cmd_AddCommand ("use_bacta", IN_GenCMD15);
-	Cmd_AddCommand ("use_electrobinoculars", IN_GenCMD16);
-	Cmd_AddCommand ("zoom", IN_GenCMD17);
-	Cmd_AddCommand ("use_sentry", IN_GenCMD18);
-	Cmd_AddCommand ("use_jetpack", IN_GenCMD21);
-	Cmd_AddCommand ("use_bactabig", IN_GenCMD22);
-	Cmd_AddCommand ("use_healthdisp", IN_GenCMD23);
-	Cmd_AddCommand ("use_ammodisp", IN_GenCMD24);
-	Cmd_AddCommand ("use_eweb", IN_GenCMD25);
-	Cmd_AddCommand ("use_cloak", IN_GenCMD26);
-	Cmd_AddCommand ("taunt", IN_GenCMD27);
-	Cmd_AddCommand ("bow", IN_GenCMD28);
-	Cmd_AddCommand ("meditate", IN_GenCMD29);
-	Cmd_AddCommand ("flourish", IN_GenCMD30);
-	Cmd_AddCommand ("gloat", IN_GenCMD31);
-	Cmd_AddCommand ("saberAttackCycle", IN_GenCMD19);
-	Cmd_AddCommand ("force_throw", IN_GenCMD20);
-	Cmd_AddCommand ("useGivenForce", IN_UseGivenForce);
-
-
-	Cmd_AddCommand("automap_button", IN_AutoMapButton);
-	Cmd_AddCommand("automap_toggle", IN_AutoMapToggle);
-	Cmd_AddCommand("voicechat", IN_VoiceChatButton);
-
 	cl_nodelta = Cvar_Get ("cl_nodelta", "0", 0);
 	cl_debugMove = Cvar_Get ("cl_debugMove", "0", 0);
 }
diff --git a/codemp/client/cl_keys.cpp b/codemp/client/cl_keys.cpp
index fb55957..c10e485 100644
--- a/codemp/client/cl_keys.cpp
+++ b/codemp/client/cl_keys.cpp
@@ -2,7 +2,6 @@
 #include "qcommon/exe_headers.h"
 
 #include "client.h"
-#include "qcommon/stringed_ingame.h"
 /*
 
 key up events are sent even if in console mode
@@ -16,340 +15,135 @@ int			chat_playerNum;
 
 keyGlobals_t	kg;										
 
-// do NOT blithely change any of the key names (3rd field) here, since they have to match the key binds
-//	in the CFG files, they're also prepended with "KEYNAME_" when looking up StringEd references
-//
-keyname_t keynames[MAX_KEYS] =							
-{														
-	{ 0x00, 0x00, NULL, A_NULL, false									},					  
-	{ 0x01, 0x01, "SHIFT", A_SHIFT, false 								},					       
-	{ 0x02, 0x02, "CTRL", A_CTRL, false   								},					       
-	{ 0x03, 0x03, "ALT", A_ALT, false									},					       
-	{ 0x04, 0x04, "CAPSLOCK", A_CAPSLOCK, false							},					       
-	{ 0x05, 0x05, "KP_NUMLOCK", A_NUMLOCK, false						},					       
-	{ 0x06, 0x06, "SCROLLLOCK", A_SCROLLLOCK, false						},					       
-	{ 0x07, 0x07, "PAUSE", A_PAUSE, false								},					       
-	{ 0x08, 0x08, "BACKSPACE", A_BACKSPACE, false						},					       
-	{ 0x09, 0x09, "TAB", A_TAB, false									},					       
-	{ 0x0a, 0x0a, "ENTER", A_ENTER, false								},					       
-	{ 0x0b, 0x0b, "KP_PLUS", A_KP_PLUS, false							},					       
-	{ 0x0c, 0x0c, "KP_MINUS", A_KP_MINUS, false							},					       
-	{ 0x0d, 0x0d, "KP_ENTER", A_KP_ENTER, false							},					       
-	{ 0x0e, 0x0e, "KP_DEL", A_KP_PERIOD, false							},					       
-	{ 0x0f, 0x0f, NULL, A_PRINTSCREEN, false							},
-	{ 0x10, 0x10, "KP_INS", A_KP_0, false								},					       
-	{ 0x11, 0x11, "KP_END", A_KP_1, false								},					       
-	{ 0x12, 0x12, "KP_DOWNARROW", A_KP_2, false							},					       
-	{ 0x13, 0x13, "KP_PGDN", A_KP_3, false								},					       
-	{ 0x14, 0x14, "KP_LEFTARROW", A_KP_4, false							},					       
-	{ 0x15, 0x15, "KP_5", A_KP_5, false									},					       
-	{ 0x16, 0x16, "KP_RIGHTARROW", A_KP_6, false						},					       
-	{ 0x17, 0x17, "KP_HOME", A_KP_7, false								},					       
-	{ 0x18, 0x18, "KP_UPARROW", A_KP_8, false							},					       
-	{ 0x19, 0x19, "KP_PGUP", A_KP_9, false								},					       
-	{ 0x1a, 0x1a, "CONSOLE", A_CONSOLE, false 							},					       
-	{ 0x1b, 0x1b, "ESCAPE", A_ESCAPE, false								},					       
-	{ 0x1c, 0x1c, "F1", A_F1, true										},					       
-	{ 0x1d, 0x1d, "F2", A_F2, true										},					       
-	{ 0x1e, 0x1e, "F3", A_F3, true										},					       
-	{ 0x1f, 0x1f, "F4", A_F4, true										},					       
-			    													        
-	{ 0x20, 0x20, "SPACE", A_SPACE, false								},
-	{ (word)'!', (word)'!', NULL, A_PLING, false		  				},
-	{ (word)'"', (word)'"', NULL, A_DOUBLE_QUOTE, false  				},
-	{ (word)'#', (word)'#', NULL, A_HASH, false		  					},
-	{ (word)'$', (word)'$', NULL, A_STRING, false						},
-	{ (word)'%', (word)'%', NULL, A_PERCENT, false						},
-	{ (word)'&', (word)'&', NULL, A_AND, false							},
-	{ 0x27, 0x27, NULL, A_SINGLE_QUOTE, false							},
-	{ (word)'(', (word)'(', NULL, A_OPEN_BRACKET, false					},
-	{ (word)')', (word)')', NULL, A_CLOSE_BRACKET, false				},
-	{ (word)'*', (word)'*', NULL, A_STAR, false							},
-	{ (word)'+', (word)'+', NULL, A_PLUS, false							},
-	{ (word)',', (word)',', NULL, A_COMMA, false						},
-	{ (word)'-', (word)'-', NULL, A_MINUS, false						},
-	{ (word)'.', (word)'.', NULL, A_PERIOD, false						},
-	{ (word)'/', (word)'/', NULL, A_FORWARD_SLASH, false				},
-	{ (word)'0', (word)'0', NULL, A_0, false							},
-	{ (word)'1', (word)'1', NULL, A_1, false							},
-	{ (word)'2', (word)'2', NULL, A_2, false							},
-	{ (word)'3', (word)'3', NULL, A_3, false							},
-	{ (word)'4', (word)'4', NULL, A_4, false							},
-	{ (word)'5', (word)'5', NULL, A_5, false							},
-	{ (word)'6', (word)'6', NULL, A_6, false							},
-	{ (word)'7', (word)'7', NULL, A_7, false							},
-	{ (word)'8', (word)'8', NULL, A_8, false							},
-	{ (word)'9', (word)'9', NULL, A_9, false							},
-	{ (word)':', (word)':', NULL, A_COLON, false						},
-	{ (word)';', (word)';', "SEMICOLON", A_SEMICOLON, false				},
-	{ (word)'<', (word)'<', NULL, A_LESSTHAN, false						},
-	{ (word)'=', (word)'=', NULL, A_EQUALS, false						},
-	{ (word)'>', (word)'>', NULL, A_GREATERTHAN, false					},
-	{ (word)'?', (word)'?', NULL, A_QUESTION, false						},
-			    													
-	{ (word)'@', (word)'@', NULL, A_AT, false							},	   	            
-	{ (word)'A', (word)'a', NULL, A_CAP_A, false						},		            
-	{ (word)'B', (word)'b', NULL, A_CAP_B, false						},		            
-	{ (word)'C', (word)'c', NULL, A_CAP_C, false						},		            
-	{ (word)'D', (word)'d', NULL, A_CAP_D, false						},		            
-	{ (word)'E', (word)'e', NULL, A_CAP_E, false						},		            
-	{ (word)'F', (word)'f', NULL, A_CAP_F, false						},		            
-	{ (word)'G', (word)'g', NULL, A_CAP_G, false						},		            
-	{ (word)'H', (word)'h', NULL, A_CAP_H, false						},		            
-	{ (word)'I', (word)'i', NULL, A_CAP_I, false						},		            
-	{ (word)'J', (word)'j', NULL, A_CAP_J, false						},		            
-	{ (word)'K', (word)'k', NULL, A_CAP_K, false						},		            
-	{ (word)'L', (word)'l', NULL, A_CAP_L, false						},		            
-	{ (word)'M', (word)'m', NULL, A_CAP_M, false						},		            
-	{ (word)'N', (word)'n', NULL, A_CAP_N, false						},		            
-	{ (word)'O', (word)'o', NULL, A_CAP_O, false						},		            
-	{ (word)'P', (word)'p', NULL, A_CAP_P, false						},		            
-	{ (word)'Q', (word)'q', NULL, A_CAP_Q, false						},		            
-	{ (word)'R', (word)'r', NULL, A_CAP_R, false						},		            
-	{ (word)'S', (word)'s', NULL, A_CAP_S, false						},		            
-	{ (word)'T', (word)'t', NULL, A_CAP_T, false						},		            
-	{ (word)'U', (word)'u', NULL, A_CAP_U, false						},		            
-	{ (word)'V', (word)'v', NULL, A_CAP_V, false						},		            
-	{ (word)'W', (word)'w', NULL, A_CAP_W, false						},		            
-	{ (word)'X', (word)'x', NULL, A_CAP_X, false						},		            
-	{ (word)'Y', (word)'y', NULL, A_CAP_Y, false						},		            
-	{ (word)'Z', (word)'z', NULL, A_CAP_Z, false						},		            
-	{ (word)'[', (word)'[', NULL, A_OPEN_SQUARE, false					},					    
-	{ 0x5c, 0x5c, NULL, A_BACKSLASH, false								},					    
-	{ (word)']', (word)']', NULL, A_CLOSE_SQUARE, false 				},					    
-	{ (word)'^', (word)'^', NULL, A_CARET, false		 				},					    
-	{ (word)'_', (word)'_', NULL, A_UNDERSCORE, false					},					    
-			    													   
-	{ 0x60, 0x60, NULL, A_LEFT_SINGLE_QUOTE, false						},
-	{ (word)'A', (word)'a', NULL, A_LOW_A, false						},           
-	{ (word)'B', (word)'b', NULL, A_LOW_B, false						},           
-	{ (word)'C', (word)'c', NULL, A_LOW_C, false						},           
-	{ (word)'D', (word)'d', NULL, A_LOW_D, false						},           
-	{ (word)'E', (word)'e', NULL, A_LOW_E, false						},           
-	{ (word)'F', (word)'f', NULL, A_LOW_F, false						},           
-	{ (word)'G', (word)'g', NULL, A_LOW_G, false						},           
-	{ (word)'H', (word)'h', NULL, A_LOW_H, false						},           
-	{ (word)'I', (word)'i', NULL, A_LOW_I, false						},           
-	{ (word)'J', (word)'j', NULL, A_LOW_J, false						},           
-	{ (word)'K', (word)'k', NULL, A_LOW_K, false						},           
-	{ (word)'L', (word)'l', NULL, A_LOW_L, false						},           
-	{ (word)'M', (word)'m', NULL, A_LOW_M, false						},           
-	{ (word)'N', (word)'n', NULL, A_LOW_N, false						},           
-	{ (word)'O', (word)'o', NULL, A_LOW_O, false						},           
-	{ (word)'P', (word)'p', NULL, A_LOW_P, false						},           
-	{ (word)'Q', (word)'q', NULL, A_LOW_Q, false						},           
-	{ (word)'R', (word)'r', NULL, A_LOW_R, false						},           
-	{ (word)'S', (word)'s', NULL, A_LOW_S, false						},           
-	{ (word)'T', (word)'t', NULL, A_LOW_T, false						},           
-	{ (word)'U', (word)'u', NULL, A_LOW_U, false						},           
-	{ (word)'V', (word)'v', NULL, A_LOW_V, false						},           
-	{ (word)'W', (word)'w', NULL, A_LOW_W, false						},           
-	{ (word)'X', (word)'x', NULL, A_LOW_X, false						},           
-	{ (word)'Y', (word)'y', NULL, A_LOW_Y, false						},           
-	{ (word)'Z', (word)'z', NULL, A_LOW_Z, false						},           
-	{ (word)'{', (word)'{', NULL, A_OPEN_BRACE, false					},
-	{ (word)'|', (word)'|', NULL, A_BAR, false							},
-	{ (word)'}', (word)'}', NULL, A_CLOSE_BRACE, false					},
-	{ (word)'~', (word)'~', NULL, A_TILDE, false						},
-	{ 0x7f, 0x7f, "DEL", A_DELETE, false								},
-			    													               
-	{ 0x80, 0x80, "EURO", A_EURO, false  								},
-	{ 0x81, 0x81, "SHIFT", A_SHIFT2, false								},
-	{ 0x82, 0x82, "CTRL", A_CTRL2, false								},
-	{ 0x83, 0x83, "ALT", A_ALT2, false									},
-	{ 0x84, 0x84, "F5", A_F5, true										},
-	{ 0x85, 0x85, "F6", A_F6, true										},
-	{ 0x86, 0x86, "F7", A_F7, true										},
-	{ 0x87, 0x87, "F8", A_F8, true										},
-	{ 0x88, 0x88, "CIRCUMFLEX", A_CIRCUMFLEX, false  					},
-	{ 0x89, 0x89, "MWHEELUP", A_MWHEELUP, false							},
-	{ 0x8a, 0x9a, NULL, A_CAP_SCARON, false								},	// ******
-	{ 0x8b, 0x8b, "MWHEELDOWN", A_MWHEELDOWN, false						},
-	{ 0x8c, 0x9c, NULL, A_CAP_OE, false									},	// ******
-	{ 0x8d, 0x8d, "MOUSE1", A_MOUSE1, false								},
-	{ 0x8e, 0x8e, "MOUSE2", A_MOUSE2, false								},
-	{ 0x8f, 0x8f, "INS", A_INSERT, false								},
-	{ 0x90, 0x90, "HOME", A_HOME, false									},
-	{ 0x91, 0x91, "PGUP", A_PAGE_UP, false								},
-	{ 0x92, 0x92, NULL, A_RIGHT_SINGLE_QUOTE, false						},
-	{ 0x93, 0x93, NULL, A_LEFT_DOUBLE_QUOTE, false						},
-	{ 0x94, 0x94, NULL, A_RIGHT_DOUBLE_QUOTE, false						},
-	{ 0x95, 0x95, "F9", A_F9, true										},
-	{ 0x96, 0x96, "F10", A_F10, true									},
-	{ 0x97, 0x97, "F11", A_F11, true									},
-	{ 0x98, 0x98, "F12", A_F12, true									},
-	{ 0x99, 0x99, NULL, A_TRADEMARK, false								},
-	{ 0x8a, 0x9a, NULL, A_LOW_SCARON, false								},	// ******
-	{ 0x9b, 0x9b, "SHIFT_ENTER", A_ENTER, false							},
-	{ 0x8c, 0x9c, NULL, A_LOW_OE, false									},	// ******
-	{ 0x9d, 0x9d, "END", A_END, false									},
-	{ 0x9e, 0x9e, "PGDN", A_PAGE_DOWN, false							},
-	{ 0x9f, 0xff, NULL, A_CAP_YDIERESIS, false							},	// ******
-			    													
-	{ 0xa0, 0,	  "SHIFT_SPACE", A_SPACE, false							},
-	{ 0xa1, 0xa1, NULL, A_EXCLAMDOWN, false								},	// upside down '!' - undisplayable
-	{ (word)(byte)'¢', (word)(byte)'¢', NULL, A_CENT, false	  			},
-	{ (word)(byte)'£', (word)(byte)'£', NULL, A_POUND, false	  		},
-	{ 0xa4, 0,    "SHIFT_KP_ENTER", A_KP_ENTER, false					},
-	{ (word)(byte)'¥', (word)(byte)'¥', NULL, A_YEN, false		  		},
-	{ 0xa6, 0xa6, "MOUSE3", A_MOUSE3, false								},
-	{ 0xa7, 0xa7, "MOUSE4", A_MOUSE4, false								},
-	{ 0xa8, 0xa8, "MOUSE5", A_MOUSE5, false								},
-	{ (word)(byte)'©', (word)(byte)'©', NULL, A_COPYRIGHT, false 		},
-	{ 0xaa, 0xaa, "UPARROW", A_CURSOR_UP, false							},
-	{ 0xab, 0xab, "DOWNARROW", A_CURSOR_DOWN, false						},
-	{ 0xac, 0xac, "LEFTARROW", A_CURSOR_LEFT, false						},
-	{ 0xad, 0xad, "RIGHTARROW", A_CURSOR_RIGHT, false					},
-	{ (word)(byte)'®', (word)(byte)'®', NULL, A_REGISTERED, false		},
-	{ 0xaf, 0,	  NULL, A_UNDEFINED_7, false							},
-	{ 0xb0, 0,	  NULL, A_UNDEFINED_8, false							},
-	{ 0xb1, 0,	  NULL, A_UNDEFINED_9, false							},
-	{ 0xb2, 0,	  NULL, A_UNDEFINED_10, false							},
-	{ 0xb3, 0,	  NULL, A_UNDEFINED_11, false							},
-	{ 0xb4, 0,	  NULL, A_UNDEFINED_12, false							},
-	{ 0xb5, 0,	  NULL, A_UNDEFINED_13, false							},
-	{ 0xb6, 0,	  NULL, A_UNDEFINED_14, false							},
-	{ 0xb7, 0,	  NULL, A_UNDEFINED_15, false							},
-	{ 0xb8, 0,	  NULL, A_UNDEFINED_16, false							},
-	{ 0xb9, 0,	  NULL, A_UNDEFINED_17, false							},
-	{ 0xba, 0,	  NULL, A_UNDEFINED_18, false							},
-	{ 0xbb, 0,	  NULL, A_UNDEFINED_19, false							},
-	{ 0xbc, 0,	  NULL, A_UNDEFINED_20, false							},
-	{ 0xbd, 0,	  NULL, A_UNDEFINED_21, false							},
-	{ 0xbe, 0,	  NULL, A_UNDEFINED_22, false							},
-	{ (word)(byte)'¿', (word)(byte)'¿', NULL, A_QUESTION_DOWN, false	},
-			    		                       
-	{ (word)(byte)'À', (word)(byte)'à', NULL, A_CAP_AGRAVE, false		},
-	{ (word)(byte)'Á', (word)(byte)'á', NULL, A_CAP_AACUTE, false		},
-	{ (word)(byte)'Â', (word)(byte)'â', NULL, A_CAP_ACIRCUMFLEX, false	},
-	{ (word)(byte)'Ã', (word)(byte)'ã', NULL, A_CAP_ATILDE, false		},
-	{ (word)(byte)'Ä', (word)(byte)'ä', NULL, A_CAP_ADIERESIS, false	},
-	{ (word)(byte)'Å', (word)(byte)'å', NULL, A_CAP_ARING, false		},
-	{ (word)(byte)'Æ', (word)(byte)'æ', NULL, A_CAP_AE, false			},
-	{ (word)(byte)'Ç', (word)(byte)'ç', NULL, A_CAP_CCEDILLA, false		},
-	{ (word)(byte)'È', (word)(byte)'è', NULL, A_CAP_EGRAVE, false		},
-	{ (word)(byte)'É', (word)(byte)'é', NULL, A_CAP_EACUTE, false		},
-	{ (word)(byte)'Ê', (word)(byte)'ê', NULL, A_CAP_ECIRCUMFLEX, false	},
-	{ (word)(byte)'Ë', (word)(byte)'ë', NULL, A_CAP_EDIERESIS, false	},
-	{ (word)(byte)'Ì', (word)(byte)'ì', NULL, A_CAP_IGRAVE, false		},
-	{ (word)(byte)'Í', (word)(byte)'í', NULL, A_CAP_IACUTE, false		},
-	{ (word)(byte)'Î', (word)(byte)'î', NULL, A_CAP_ICIRCUMFLEX, false	},
-	{ (word)(byte)'Ï', (word)(byte)'ï', NULL, A_CAP_IDIERESIS, false	},
-	{ (word)(byte)'Ð', (word)(byte)'ð', NULL, A_CAP_ETH, false			},
-	{ (word)(byte)'Ñ', (word)(byte)'ñ', NULL, A_CAP_NTILDE, false		},
-	{ (word)(byte)'Ò', (word)(byte)'ò', NULL, A_CAP_OGRAVE, false		},
-	{ (word)(byte)'Ó', (word)(byte)'ó', NULL, A_CAP_OACUTE, false		},
-	{ (word)(byte)'Ô', (word)(byte)'ô', NULL, A_CAP_OCIRCUMFLEX, false	},
-	{ (word)(byte)'Õ', (word)(byte)'õ', NULL, A_CAP_OTILDE, false		},
-	{ (word)(byte)'Ö', (word)(byte)'ö', NULL, A_CAP_ODIERESIS, false	},
-	{ (word)(byte)'×', (word)(byte)'×', "KP_STAR", A_MULTIPLY, false 	},
-	{ (word)(byte)'Ø', (word)(byte)'ø', NULL, A_CAP_OSLASH, false		},  
-	{ (word)(byte)'Ù', (word)(byte)'ù', NULL, A_CAP_UGRAVE, false		},  
-	{ (word)(byte)'Ú', (word)(byte)'ú', NULL, A_CAP_UACUTE, false		},  
-	{ (word)(byte)'Û', (word)(byte)'û', NULL, A_CAP_UCIRCUMFLEX, false	},  
-	{ (word)(byte)'Ü', (word)(byte)'ü', NULL, A_CAP_UDIERESIS, false	},  
-	{ (word)(byte)'Ý', (word)(byte)'ý', NULL, A_CAP_YACUTE, false		},  
-	{ (word)(byte)'Þ', (word)(byte)'þ', NULL, A_CAP_THORN, false		},  
-	{ (word)(byte)'ß', (word)(byte)'ß', NULL, A_GERMANDBLS, false 		},
-			    		                       
-	{ (word)(byte)'À', (word)(byte)'à', NULL, A_LOW_AGRAVE, false		},		 
-	{ (word)(byte)'Á', (word)(byte)'á', NULL, A_LOW_AACUTE, false		},		 
-	{ (word)(byte)'Â', (word)(byte)'â', NULL, A_LOW_ACIRCUMFLEX, false	},		 
-	{ (word)(byte)'Ã', (word)(byte)'ã', NULL, A_LOW_ATILDE, false		},		 
-	{ (word)(byte)'Ä', (word)(byte)'ä', NULL, A_LOW_ADIERESIS, false	},		 
-	{ (word)(byte)'Å', (word)(byte)'å', NULL, A_LOW_ARING, false		},		 
-	{ (word)(byte)'Æ', (word)(byte)'æ', NULL, A_LOW_AE, false			},		 
-	{ (word)(byte)'Ç', (word)(byte)'ç', NULL, A_LOW_CCEDILLA, false		},		 
-	{ (word)(byte)'È', (word)(byte)'è', NULL, A_LOW_EGRAVE, false		},		 
-	{ (word)(byte)'É', (word)(byte)'é', NULL, A_LOW_EACUTE, false		},		 
-	{ (word)(byte)'Ê', (word)(byte)'ê', NULL, A_LOW_ECIRCUMFLEX, false	},		 
-	{ (word)(byte)'Ë', (word)(byte)'ë', NULL, A_LOW_EDIERESIS, false	},		 
-	{ (word)(byte)'Ì', (word)(byte)'ì', NULL, A_LOW_IGRAVE, false		},		 
-	{ (word)(byte)'Í', (word)(byte)'í', NULL, A_LOW_IACUTE, false		},		 
-	{ (word)(byte)'Î', (word)(byte)'î', NULL, A_LOW_ICIRCUMFLEX, false	},		 
-	{ (word)(byte)'Ï', (word)(byte)'ï', NULL, A_LOW_IDIERESIS, false	},		 
-	{ (word)(byte)'Ð', (word)(byte)'ð', NULL, A_LOW_ETH, false			},		 
-	{ (word)(byte)'Ñ', (word)(byte)'ñ', NULL, A_LOW_NTILDE, false		},		 
-	{ (word)(byte)'Ò', (word)(byte)'ò', NULL, A_LOW_OGRAVE, false		},		 
-	{ (word)(byte)'Ó', (word)(byte)'ó', NULL, A_LOW_OACUTE, false		},		 
-	{ (word)(byte)'Ô', (word)(byte)'ô', NULL, A_LOW_OCIRCUMFLEX, false	},		 
-	{ (word)(byte)'Õ', (word)(byte)'õ', NULL, A_LOW_OTILDE, false		},		 
-	{ (word)(byte)'Ö', (word)(byte)'ö', NULL, A_LOW_ODIERESIS, false	},		 
-	{ (word)(byte)'÷', (word)(byte)'÷', "KP_SLASH", A_DIVIDE, false 	},		 
-	{ (word)(byte)'Ø', (word)(byte)'ø', NULL, A_LOW_OSLASH, false		},		 
-	{ (word)(byte)'Ù', (word)(byte)'ù', NULL, A_LOW_UGRAVE, false		},		 
-	{ (word)(byte)'Ú', (word)(byte)'ú', NULL, A_LOW_UACUTE, false		},		 
-	{ (word)(byte)'Û', (word)(byte)'û', NULL, A_LOW_UCIRCUMFLEX, false	},		 
-	{ (word)(byte)'Ü', (word)(byte)'ü', NULL, A_LOW_UDIERESIS, false	},		 
-	{ (word)(byte)'Ý', (word)(byte)'ý', NULL, A_LOW_YACUTE, false		},		 
-	{ (word)(byte)'Þ', (word)(byte)'þ', NULL, A_LOW_THORN, false		},		 
-	{ 0x9f, 0xff, NULL, A_LOW_YDIERESIS, false							},	// *******
-																		
-	{ 0x100, 0x100, "JOY0", A_JOY0, false								},
-	{ 0x101, 0x101, "JOY1", A_JOY1, false								},
-	{ 0x102, 0x102, "JOY2", A_JOY2, false								},
-	{ 0x103, 0x103, "JOY3", A_JOY3, false								},
-	{ 0x104, 0x104, "JOY4", A_JOY4, false								},
-	{ 0x105, 0x105, "JOY5", A_JOY5, false								},
-	{ 0x106, 0x106, "JOY6", A_JOY6, false								},
-	{ 0x107, 0x107, "JOY7", A_JOY7, false								},
-	{ 0x108, 0x108, "JOY8", A_JOY8, false								},
-	{ 0x109, 0x109, "JOY9", A_JOY9, false								},
-	{ 0x10a, 0x10a, "JOY10", A_JOY10, false								},
-	{ 0x10b, 0x10b, "JOY11", A_JOY11, false								},
-	{ 0x10c, 0x10c, "JOY12", A_JOY12, false								},
-	{ 0x10d, 0x10d, "JOY13", A_JOY13, false								},
-	{ 0x10e, 0x10e, "JOY14", A_JOY14, false								},
-	{ 0x10f, 0x10f, "JOY15", A_JOY15, false								},
-	{ 0x110, 0x110, "JOY16", A_JOY16, false								},
-	{ 0x111, 0x111, "JOY17", A_JOY17, false								},
-	{ 0x112, 0x112, "JOY18", A_JOY18, false								},
-	{ 0x113, 0x113, "JOY19", A_JOY19, false								},
-	{ 0x114, 0x114, "JOY20", A_JOY20, false								},
-	{ 0x115, 0x115, "JOY21", A_JOY21, false								},
-	{ 0x116, 0x116, "JOY22", A_JOY22, false								},
-	{ 0x117, 0x117, "JOY23", A_JOY23, false								},
-	{ 0x118, 0x118, "JOY24", A_JOY24, false								},
-	{ 0x119, 0x119, "JOY25", A_JOY25, false								},
-	{ 0x11a, 0x11a, "JOY26", A_JOY26, false								},
-	{ 0x11b, 0x11b, "JOY27", A_JOY27, false								},
-	{ 0x11c, 0x11c, "JOY28", A_JOY28, false								},
-	{ 0x11d, 0x11d, "JOY29", A_JOY29, false								},
-	{ 0x11e, 0x11e, "JOY30", A_JOY30, false								},
-	{ 0x11f, 0x11f, "JOY31", A_JOY31, false								},
-		    	    												
-	{ 0x120, 0x120, "AUX0", A_AUX0, false								},
-	{ 0x121, 0x121, "AUX1", A_AUX1, false								},
-	{ 0x122, 0x122, "AUX2", A_AUX2, false								},
-	{ 0x123, 0x123, "AUX3", A_AUX3, false								},
-	{ 0x124, 0x124, "AUX4", A_AUX4, false								},
-	{ 0x125, 0x125, "AUX5", A_AUX5, false								},
-	{ 0x126, 0x126, "AUX6", A_AUX6, false								},
-	{ 0x127, 0x127, "AUX7", A_AUX7, false								},
-	{ 0x128, 0x128, "AUX8", A_AUX8, false								},
-	{ 0x129, 0x129, "AUX9", A_AUX9, false								},
-	{ 0x12a, 0x12a, "AUX10", A_AUX10, false								},
-	{ 0x12b, 0x12b, "AUX11", A_AUX11, false								},
-	{ 0x12c, 0x12c, "AUX12", A_AUX12, false								},
-	{ 0x12d, 0x12d, "AUX13", A_AUX13, false								},
-	{ 0x12e, 0x12e, "AUX14", A_AUX14, false								},
-	{ 0x12f, 0x12f, "AUX15", A_AUX15, false								},
-	{ 0x130, 0x130, "AUX16", A_AUX16, false								},
-	{ 0x131, 0x131, "AUX17", A_AUX17, false								},
-	{ 0x132, 0x132, "AUX18", A_AUX18, false								},
-	{ 0x133, 0x133, "AUX19", A_AUX19, false								},
-	{ 0x134, 0x134, "AUX20", A_AUX20, false								},
-	{ 0x135, 0x135, "AUX21", A_AUX21, false								},
-	{ 0x136, 0x136, "AUX22", A_AUX22, false								},
-	{ 0x137, 0x137, "AUX23", A_AUX23, false								},
-	{ 0x138, 0x138, "AUX24", A_AUX24, false								},
-	{ 0x139, 0x139, "AUX25", A_AUX25, false								},
-	{ 0x13a, 0x13a, "AUX26", A_AUX26, false								},
-	{ 0x13b, 0x13b, "AUX27", A_AUX27, false								},
-	{ 0x13c, 0x13c, "AUX28", A_AUX28, false								},
-	{ 0x13d, 0x13d, "AUX29", A_AUX29, false								},
-	{ 0x13e, 0x13e, "AUX30", A_AUX30, false								},
-	{ 0x13f, 0x13f, "AUX31", A_AUX31, false								}
+// names not in this list can either be lowercase ascii, or '0xnn' hex sequences
+keyname_t keynames[K_LAST_KEY] =							
+{			
+	{"TAB", K_TAB},
+	{"ENTER", K_ENTER},
+	{"ESCAPE", K_ESCAPE},
+	{"SPACE", K_SPACE},
+
+	{"BACKSPACE", K_BACKSPACE},
+
+	{"COMMAND", K_COMMAND},
+	{"CAPSLOCK", K_CAPSLOCK},
+	{"POWER", K_POWER},
+	{"PAUSE", K_PAUSE},
+
+	{"UPARROW", K_UPARROW},
+	{"DOWNARROW", K_DOWNARROW},
+	{"LEFTARROW", K_LEFTARROW},
+	{"RIGHTARROW", K_RIGHTARROW},
+
+	{"ALT", K_ALT},
+	{"CTRL", K_CTRL},
+	{"SHIFT", K_SHIFT},
+	{"INS", K_INS},
+	{"DEL", K_DEL},
+	{"PGDN", K_PGDN},
+	{"PGUP", K_PGUP},
+	{"HOME", K_HOME},
+	{"END", K_END},
+	
+	{"F1", K_F1},
+	{"F2", K_F2},
+	{"F3", K_F3},
+	{"F4", K_F4},
+	{"F5", K_F5},
+	{"F6", K_F6},
+	{"F7", K_F7},
+	{"F8", K_F8},
+	{"F9", K_F9},
+	{"F10", K_F10},
+	{"F11", K_F11},
+	{"F12", K_F12},
+	{"F13", K_F13},
+	{"F14", K_F14},
+	{"F15", K_F15},
+
+	{"SCROLL", K_SCROLL},
+
+	{"KP_HOME", K_KP_HOME },
+	{"KP_UPARROW", K_KP_UPARROW },
+	{"KP_PGUP", K_KP_PGUP },
+	{"KP_LEFTARROW", K_KP_LEFTARROW },
+	{"KP_5", K_KP_5 },
+	{"KP_RIGHTARROW", K_KP_RIGHTARROW },
+	{"KP_END", K_KP_END },
+	{"KP_DOWNARROW", K_KP_DOWNARROW },
+	{"KP_PGDN", K_KP_PGDN },
+	{"KP_ENTER",  K_KP_ENTER },
+	{"KP_INS", K_KP_INS },
+	{"KP_DEL", K_KP_DEL },
+	{"KP_SLASH", K_KP_SLASH },
+	{"KP_MINUS", K_KP_MINUS },
+	{"KP_PLUS", K_KP_PLUS },
+	{"KP_NUMLOCK", K_KP_NUMLOCK },
+	{"KP_STAR", K_KP_STAR },
+	{"KP_EQUALS", K_KP_EQUALS },
+	
+	{"MOUSE1", K_MOUSE1},
+	{"MOUSE2", K_MOUSE2},
+	{"MOUSE3", K_MOUSE3},
+	{"MOUSE4", K_MOUSE4},
+	{"MOUSE5", K_MOUSE5},
+
+	{"MWHEELUP",    K_MWHEELUP },
+	{"MWHEELDOWN",  K_MWHEELDOWN },
+
+	{"JOY1", K_JOY1},
+	{"JOY2", K_JOY2},
+	{"JOY3", K_JOY3},
+	{"JOY4", K_JOY4},
+	{"JOY5", K_JOY5},
+	{"JOY6", K_JOY6},
+	{"JOY7", K_JOY7},
+	{"JOY8", K_JOY8},
+	{"JOY9", K_JOY9},
+	{"JOY10", K_JOY10},
+	{"JOY11", K_JOY11},
+	{"JOY12", K_JOY12},
+	{"JOY13", K_JOY13},
+	{"JOY14", K_JOY14},
+	{"JOY15", K_JOY15},
+	{"JOY16", K_JOY16},
+	{"JOY17", K_JOY17},
+	{"JOY18", K_JOY18},
+	{"JOY19", K_JOY19},
+	{"JOY20", K_JOY20},
+	{"JOY21", K_JOY21},
+	{"JOY22", K_JOY22},
+	{"JOY23", K_JOY23},
+	{"JOY24", K_JOY24},
+	{"JOY25", K_JOY25},
+	{"JOY26", K_JOY26},
+	{"JOY27", K_JOY27},
+	{"JOY28", K_JOY28},
+	{"JOY29", K_JOY29},
+	{"JOY30", K_JOY30},
+	{"JOY31", K_JOY31},
+	{"JOY32", K_JOY32},
+
+	{"AUX1", K_AUX1},
+	{"AUX2", K_AUX2},
+	{"AUX3", K_AUX3},
+	{"AUX4", K_AUX4},
+	{"AUX5", K_AUX5},
+	{"AUX6", K_AUX6},
+	{"AUX7", K_AUX7},
+	{"AUX8", K_AUX8},
+	{"AUX9", K_AUX9},
+	{"AUX10", K_AUX10},
+	{"AUX11", K_AUX11},
+	{"AUX12", K_AUX12},
+	{"AUX13", K_AUX13},
+	{"AUX14", K_AUX14},
+	{"AUX15", K_AUX15},
+	{"AUX16", K_AUX16},
+
+	{"SEMICOLON", ';'},     // because a raw semicolon seperates commands
+
+	{NULL, 0}
 };
 
 
@@ -460,7 +254,7 @@ void Field_Draw( field_t *edit, int x, int y, int width, qboolean showCursor )
 
 void Field_BigDraw( field_t *edit, int x, int y, int width, qboolean showCursor ) 
 {
-	Field_VariableSizeDraw( edit, x, y, width, BIGCHAR_WIDTH, showCursor );
+	Field_VariableSizeDraw( edit, x, y, width, GIANTCHAR_HEIGHT/2, showCursor );
 }
 
 /*
@@ -501,14 +295,14 @@ void Field_KeyDownEvent( field_t *edit, int key ) {
 	int		len;
 
 	// shift-insert is paste
-	if ( ( ( key == A_INSERT ) || ( key == A_KP_0 ) ) && kg.keys[A_SHIFT].down ) {
+	if ( ( ( key == K_INS ) || ( key == K_KP_INS ) ) && kg.keys[K_SHIFT].down ) {
 		Field_Paste( edit );
 		return;
 	}
 
 	len = strlen( edit->buffer );
 
-	if ( key == A_DELETE ) {
+	if ( key == K_DEL ) {
 		if ( edit->cursor < len ) {
 			memmove( edit->buffer + edit->cursor, 
 				edit->buffer + edit->cursor + 1, len - edit->cursor );
@@ -516,7 +310,7 @@ void Field_KeyDownEvent( field_t *edit, int key ) {
 		return;
 	}
 
-	if ( key == A_CURSOR_RIGHT ) 
+	if ( key == K_RIGHTARROW ) 
 	{
 		if ( edit->cursor < len ) {
 			edit->cursor++;
@@ -529,7 +323,7 @@ void Field_KeyDownEvent( field_t *edit, int key ) {
 		return;
 	}
 
-	if ( key == A_CURSOR_LEFT ) 
+	if ( key == K_LEFTARROW ) 
 	{
 		if ( edit->cursor > 0 ) {
 			edit->cursor--;
@@ -541,19 +335,19 @@ void Field_KeyDownEvent( field_t *edit, int key ) {
 		return;
 	}
 
-	if ( key == A_HOME || ( keynames[key].lower == 'a' && kg.keys[A_CTRL].down ) ) 
+	if ( key == K_HOME || ( tolower(key) == 'a' && kg.keys[K_CTRL].down ) ) 
 	{
 		edit->cursor = 0;
 		return;
 	}
 
-	if ( key == A_END || ( keynames[key].lower == 'e' && kg.keys[A_CTRL].down ) ) 
+	if ( key == K_END || ( tolower(key) == 'e' && kg.keys[K_CTRL].down ) ) 
 	{
 		edit->cursor = len;
 		return;
 	}
 
-	if ( key == A_INSERT ) {
+	if ( key == K_INS ) {
 		kg.key_overstrikeMode = (qboolean)!kg.key_overstrikeMode;
 		return;
 	}
@@ -807,13 +601,13 @@ Handles history and console scrollback
 */
 void Console_Key (int key) {
 	// ctrl-L clears screen
-	if ( keynames[ key ].lower == 'l' && kg.keys[A_CTRL].down ) {
+	if ( tolower(key) == 'l' && kg.keys[K_CTRL].down ) {
 		Cbuf_AddText ("clear\n");
 		return;
 	}
 
 	// enter finishes the line
-	if ( key == A_ENTER || key == A_KP_ENTER ) {
+	if ( key == K_ENTER || key == K_KP_ENTER ) {
 		// if not in the game explicitly prepent a slash if needed
 		if ( cls.state != CA_ACTIVE && kg.g_consoleField.buffer[0] != '\\' 
 			&& kg.g_consoleField.buffer[0] != '/' ) {
@@ -832,29 +626,8 @@ void Console_Key (int key) {
 
 		// leading slash is an explicit command
 		if ( kg.g_consoleField.buffer[0] == '\\' || kg.g_consoleField.buffer[0] == '/' ) {
-			if (cgvm && cl.mSharedMemory)
-			{ //don't do this unless cgame is inited and shared memory is valid
-				const char *buf = (kg.g_consoleField.buffer+1);
-				TCGIncomingConsoleCommand *icc = (TCGIncomingConsoleCommand *)cl.mSharedMemory;
-
-				strcpy(icc->conCommand, buf);
-				
-				if (VM_Call(cgvm, CG_INCOMING_CONSOLE_COMMAND))
-				{ //rww - let mod authors filter client console messages so they can cut them off if they want.
-					Cbuf_AddText( kg.g_consoleField.buffer+1 );	// valid command
-					Cbuf_AddText ("\n");
-				}
-				else if (icc->conCommand[0])
-				{ //the vm call says to execute this command in place
-					Cbuf_AddText( icc->conCommand );
-					Cbuf_AddText ("\n");
-				}
-			}
-			else
-			{ //just exec it then
-				Cbuf_AddText( kg.g_consoleField.buffer+1 );	// valid command
-				Cbuf_AddText ("\n");
-			}
+			Cbuf_AddText( kg.g_consoleField.buffer+1 );	// valid command
+			Cbuf_AddText ("\n");
 		} else {
 			// other text will be chat messages
 			if ( !kg.g_consoleField.buffer[0] ) {
@@ -883,14 +656,14 @@ void Console_Key (int key) {
 
 	// command completion
 
-	if (key == A_TAB) {
+	if (key == K_TAB) {
 		CompleteCommand();
 		return;
 	}
 
 	// command history (ctrl-p ctrl-n for unix style)
 
-	if ( ( key == A_MWHEELUP && kg.keys[A_SHIFT].down ) || ( key == A_CURSOR_UP ) || ( key == A_KP_8 ) || ( ( keynames[ key ].lower == 'p' ) && kg.keys[A_CTRL].down ) ) 
+	if ( ( key == K_MWHEELUP && kg.keys[K_SHIFT].down ) || ( key == K_UPARROW ) || ( key == K_KP_UPARROW ) || ( ( tolower(key) == 'p' ) && kg.keys[K_CTRL].down ) ) 
 	{
 		if ( kg.nextHistoryLine - kg.historyLine < COMMAND_HISTORY && kg.historyLine > 0 ) 
 		{
@@ -900,7 +673,7 @@ void Console_Key (int key) {
 		return;
 	}
 
-	if ( ( key == A_MWHEELDOWN && kg.keys[A_SHIFT].down ) || ( key == A_CURSOR_DOWN ) || ( key == A_KP_2 ) || ( ( keynames[ key ].lower == 'n' ) && kg.keys[A_CTRL].down ) ) 
+	if ( ( key == K_MWHEELDOWN && kg.keys[K_SHIFT].down ) || ( key == K_DOWNARROW ) || ( key == K_KP_DOWNARROW ) || ( ( tolower(key) == 'n' ) && kg.keys[K_CTRL].down ) ) 
 	{
 		if (kg.historyLine == kg.nextHistoryLine)
 			return;
@@ -910,28 +683,28 @@ void Console_Key (int key) {
 	}
 
 	// console scrolling
-	if ( key == A_PAGE_UP ) {
+	if ( key == K_PGUP ) {
 		Con_PageUp();
 		return;
 	}
 
-	if ( key == A_PAGE_DOWN ) {
+	if ( key == K_PGDN ) {
 		Con_PageDown();
 		return;
 	}
 
-	if ( key == A_MWHEELUP ) {	//----(SA)	added some mousewheel functionality to the console
+	if ( key == K_MWHEELUP ) {	//----(SA)	added some mousewheel functionality to the console
 		Con_PageUp();
-		if(kg.keys[A_CTRL].down) {	// hold <ctrl> to accelerate scrolling
+		if(kg.keys[K_CTRL].down) {	// hold <ctrl> to accelerate scrolling
 			Con_PageUp();
 			Con_PageUp();
 		}
 		return;
 	}
 
-	if ( key == A_MWHEELDOWN ) {	//----(SA)	added some mousewheel functionality to the console
+	if ( key == K_MWHEELDOWN ) {	//----(SA)	added some mousewheel functionality to the console
 		Con_PageDown();
-		if(kg.keys[A_CTRL].down) {	// hold <ctrl> to accelerate scrolling
+		if(kg.keys[K_CTRL].down) {	// hold <ctrl> to accelerate scrolling
 			Con_PageDown();
 			Con_PageDown();
 		}
@@ -939,13 +712,13 @@ void Console_Key (int key) {
 	}
 
 	// ctrl-home = top of console
-	if ( key == A_HOME && kg.keys[A_CTRL].down ) {
+	if ( key == K_HOME && kg.keys[K_CTRL].down ) {
 		Con_Top();
 		return;
 	}
 
 	// ctrl-end = bottom of console
-	if ( key == A_END && kg.keys[A_CTRL].down ) {
+	if ( key == K_END && kg.keys[K_CTRL].down ) {
 		Con_Bottom();
 		return;
 	}
@@ -967,13 +740,13 @@ In game talk message
 void Message_Key( int key ) {
 	char	buffer[MAX_STRING_CHARS];
 
-	if (key == A_ESCAPE) {
+	if (key == K_ESCAPE) {
 		cls.keyCatchers &= ~KEYCATCH_MESSAGE;
 		Field_Clear( &chatField );
 		return;
 	}
 
-	if ( key == A_ENTER || key == A_KP_ENTER )
+	if ( key == K_ENTER || key == K_KP_ENTER )
 	{
 		if ( chatField.buffer[0] && cls.state == CA_ACTIVE ) {
 			if (chat_playerNum != -1 )
@@ -1016,7 +789,7 @@ qboolean Key_IsDown( int keynum ) {
 		return qfalse;
 	}
 
-	return kg.keys[ keynames[keynum].upper ].down;
+	return kg.keys[keynum].down;
 }
 
 
@@ -1033,7 +806,7 @@ to be configured even if they don't have defined names.
 ===================
 */
 int Key_StringToKeynum( char *str ) {
-	int			i;
+	keyname_t	*kn;
 	
 	if ( !str || !str[0] ) 
 	{
@@ -1042,15 +815,15 @@ int Key_StringToKeynum( char *str ) {
 	// If single char bind, presume ascii char bind
 	if ( !str[1] ) 
 	{
-		return keynames[ (unsigned char)str[0] ].upper;
+		return str[0];
 	}
 
 	// scan for a text match
-	for ( i = 0 ; i < MAX_KEYS ; i++ ) 
+	for ( kn=keynames ; kn->name ; kn++ ) 
 	{
-		if ( keynames[i].name && !stricmp( str, keynames[i].name ) )
+		if ( !stricmp( str, kn->name ) )
 		{
-			return keynames[i].keynum;
+			return kn->keynum;
 		}
 	}
 
@@ -1100,45 +873,13 @@ static const char *Key_KeynumValid( int keynum )
 	{
 		return "<KEY NOT FOUND>";
 	}
-	if ( keynum < 0 || keynum >= MAX_KEYS ) 
+	if ( keynum < 0 || keynum >= K_LAST_KEY ) 
 	{
 		return "<OUT OF RANGE>";
 	}
 	return NULL;
 }
 
-static const char *Key_KeyToName( int keynum )
-{
-	return keynames[keynum].name;
-}
-
-
-static const char *Key_KeyToAscii( int keynum )
-{
-	if(!keynames[keynum].lower)
-	{
-		return(NULL);
-	}
-	if(keynum == A_SPACE)
-	{
-		tinyString[0] = (char)A_SHIFT_SPACE;
-	}
-	else if(keynum == A_ENTER)
-	{
-		tinyString[0] = (char)A_SHIFT_ENTER;
-	}
-	else if(keynum == A_KP_ENTER)
-	{
-		tinyString[0] = (char)A_SHIFT_KP_ENTER;
-	}
-	else
-	{
-		tinyString[0] = keynames[keynum].upper;
-	}
-	tinyString[1] = 0;
-	return tinyString;
-}
-
 static const char *Key_KeyToHex( int keynum )
 {
 	int		i, j;
@@ -1155,32 +896,6 @@ static const char *Key_KeyToHex( int keynum )
 	return tinyString;
 }
 
-// Returns the ascii code of the keynum
-const char *Key_KeynumToAscii( int keynum ) 
-{
-	const char	*name;
-
-	name = Key_KeynumValid(keynum);
-
-	// check for printable ascii
-	if ( !name && keynum > 0 && keynum < 256 ) 
-	{
-		name = Key_KeyToAscii(keynum);
-	}
-	// Check for name (for JOYx and AUXx buttons)
-	if ( !name )
-	{
-		name = Key_KeyToName(keynum);
-	}
-	// Fallback to hex number
-	if ( !name )
-	{
-		name = Key_KeyToHex(keynum);
-	}
-	return name;
-}
-
-
 /*
 ===================
 Key_KeynumToString
@@ -1192,19 +907,27 @@ given keynum.
 // Returns a console/config file friendly name for the key
 const char *Key_KeynumToString( int keynum ) 
 {
+	keyname_t   *kn;
 	const char	*name;
 
 	name = Key_KeynumValid(keynum);
 
-	// Check for friendly name
-	if ( !name )
+	// check for printable ascii
+	if ( !name && keynum > 32 && keynum < 127) 
 	{
-		name = Key_KeyToName(keynum);
+		tinyString[0] = keynum;
+		tinyString[1] = 0;
+		return tinyString;
 	}
-	// check for printable ascii
-	if ( !name && keynum > 0 && keynum < 256) 
+	// Check for friendly name
+	if ( !name )
 	{
-		name = Key_KeyToAscii(keynum);
+		for ( kn=keynames ; kn->name ; kn++ ) {
+			if (keynum == kn->keynum) {
+				name = kn->name;
+				break;
+			}
+		}
 	}
 	// Fallback to hex number
 	if ( !name )
@@ -1227,15 +950,15 @@ void Key_SetBinding( int keynum, const char *binding ) {
 	}
 
 	// free old bindings
-	if ( kg.keys[ keynames[keynum].upper ].binding ) {
-		Z_Free( kg.keys[ keynames[keynum].upper ].binding );
-		kg.keys[ keynames[keynum].upper ].binding = NULL;
+	if ( kg.keys[keynum].binding ) {
+		Z_Free( kg.keys[keynum].binding );
+		kg.keys[keynum].binding = NULL;
 	}
 			
 	// allocate memory for new binding
 	if (binding)
 	{
-		kg.keys[ keynames[keynum].upper ].binding = CopyString( binding );
+		kg.keys[keynum].binding = CopyString( binding );
 	}
 
 	// consider this like modifying an archived cvar, so the
@@ -1310,7 +1033,7 @@ void Key_Unbindall_f (void)
 {
 	int		i;
 	
-	for (i = 0; i < MAX_KEYS ; i++)
+	for (i = 0; i < K_LAST_KEY ; i++)
 	{
 		if (kg.keys[i].binding)
 		{
@@ -1377,7 +1100,7 @@ void Key_WriteBindings( fileHandle_t f ) {
 	int		i;
 
 	FS_Printf (f, "unbindall\n" );
-	for (i=0 ; i<MAX_KEYS ; i++) {
+	for (i=0 ; i<K_LAST_KEY ; i++) {
 		if (kg.keys[i].binding && kg.keys[i].binding[0] ) {
 			const char *name = Key_KeynumToString(i);
 
@@ -1401,9 +1124,9 @@ Key_Bindlist_f
 void Key_Bindlist_f( void ) {
 	int		i;
 
-	for ( i = 0 ; i < MAX_KEYS ; i++ ) {
+	for ( i = 0 ; i < K_LAST_KEY ; i++ ) {
 		if ( kg.keys[i].binding && kg.keys[i].binding[0] ) {
-			Com_Printf( "Key : %s (%s) \"%s\"\n", Key_KeynumToAscii(i), Key_KeynumToString(i), kg.keys[i].binding );
+			Com_Printf( "Key : %s \"%s\"\n", Key_KeynumToString(i), kg.keys[i].binding );
 		}
 	}
 }
@@ -1477,11 +1200,11 @@ void CL_KeyEvent (int key, qboolean down, unsigned time) {
 	char	cmd[1024];
 
 	// update auto-repeat status and BUTTON_ANY status
-	kg.keys[ keynames[key].upper ].down = down;
+	kg.keys[key].down = down;
 	if (down)
 	{
-		kg.keys[ keynames[key].upper ].repeats++;
-		if ( kg.keys[ keynames[key].upper ].repeats == 1 && key != A_SCROLLLOCK && key != A_NUMLOCK && key != A_CAPSLOCK )
+		kg.keys[key].repeats++;
+		if ( kg.keys[key].repeats == 1 && key != K_KP_NUMLOCK && key != K_CAPSLOCK )
 		{
 			kg.anykeydown = qtrue;
 			kg.keyDownCount++;
@@ -1489,8 +1212,8 @@ void CL_KeyEvent (int key, qboolean down, unsigned time) {
 	}
 	else
 	{
-		kg.keys[ keynames[key].upper ].repeats = 0;
-		if( key != A_SCROLLLOCK && key != A_NUMLOCK && key != A_CAPSLOCK )
+		kg.keys[key].repeats = 0;
+		if( key != K_KP_NUMLOCK && key != K_CAPSLOCK )
 			kg.keyDownCount--;
 		if(kg.keyDownCount <= 0)
 		{
@@ -1500,7 +1223,7 @@ void CL_KeyEvent (int key, qboolean down, unsigned time) {
 	}
 
 	// console key is hardcoded, so the user can never unbind it
-	if (key == A_CONSOLE || ( kg.keys[A_SHIFT].down && key == A_ESCAPE ) ) {
+	if (key == K_CONSOLE || ( kg.keys[K_SHIFT].down && key == K_ESCAPE ) ) {
 		if (!down) {
 			return;
 		}
@@ -1509,18 +1232,18 @@ void CL_KeyEvent (int key, qboolean down, unsigned time) {
 	}
 
 	// kg.keys can still be used for bound actions
-	if ( down && /*( key < 128 || key == A_MOUSE1 ) && */
+	if ( down && ( key < 128 || key == K_MOUSE1 ) && 
 		( cls.state == CA_CINEMATIC ) &&
 		!cls.keyCatchers) {
 
 		if (Cvar_VariableValue ("com_cameraMode") == 0) {
 			Cvar_Set ("nextdemo","");
-			key = A_ESCAPE;
+			key = K_ESCAPE;
 		}
 	}
 
 	// escape is always handled special
-	if ( key == A_ESCAPE && down ) {
+	if ( key == K_ESCAPE && down ) {
 		if ( cls.keyCatchers & KEYCATCH_MESSAGE ) {
 			// clear message mode
 			Message_Key( key );
@@ -1557,7 +1280,7 @@ void CL_KeyEvent (int key, qboolean down, unsigned time) {
 	// an action started before a mode switch.
 	//
 	if (!down) {
-		kb = kg.keys[ keynames[key].upper ].binding;
+		kb = kg.keys[key].binding;
 
 		CL_AddKeyUpCommands( key, kb );
 
@@ -1588,7 +1311,7 @@ void CL_KeyEvent (int key, qboolean down, unsigned time) {
 		Console_Key( key );
 	} else {
 		// send the bound action
-		kb = kg.keys[ keynames[key].upper ].binding;
+		kb = kg.keys[key].binding;
 		if (kb)
 		{
 			if (kb[0] == '+') {	
@@ -1620,28 +1343,8 @@ void CL_KeyEvent (int key, qboolean down, unsigned time) {
 				}
 			} else {
 				// down-only command
-				if (cgvm && cl.mSharedMemory)
-				{ //don't do this unless cgame is inited and shared memory is valid
-					TCGIncomingConsoleCommand *icc = (TCGIncomingConsoleCommand *)cl.mSharedMemory;
-
-					strcpy(icc->conCommand, kb);
-					
-					if (VM_Call(cgvm, CG_INCOMING_CONSOLE_COMMAND))
-					{ //rww - let mod authors filter client console messages so they can cut them off if they want.
-						Cbuf_AddText (kb);
-						Cbuf_AddText ("\n");
-					}
-					else if (icc->conCommand[0])
-					{ //the vm call says to execute this command in place
-						Cbuf_AddText( icc->conCommand );
-						Cbuf_AddText ("\n");
-					}
-				}
-				else
-				{ //otherwise just add it
-					Cbuf_AddText (kb);
-					Cbuf_AddText ("\n");
-				}
+				Cbuf_AddText (kb);
+				Cbuf_AddText ("\n");
 			}
 		}
 	}
@@ -1698,8 +1401,8 @@ void Key_ClearStates (void)
 
 	kg.anykeydown = qfalse;
 
-	for ( i=0 ; i < MAX_KEYS ; i++ ) {
-		if (i == A_SCROLLLOCK || i == A_NUMLOCK || i == A_CAPSLOCK)
+	for ( i=0 ; i < K_LAST_KEY ; i++ ) {
+		if (i == K_KP_NUMLOCK || i == K_CAPSLOCK)
 			continue;
 
 		if ( kg.keys[i].down ) {
diff --git a/codemp/client/cl_main.cpp b/codemp/client/cl_main.cpp
index e82bd00..544548b 100644
--- a/codemp/client/cl_main.cpp
+++ b/codemp/client/cl_main.cpp
@@ -4,7 +4,6 @@
 // cl_main.c  -- client main loop
 
 #include "client.h"
-#include "qcommon/stringed_ingame.h"
 #include <limits.h>
 #include "snd_local.h"
 
@@ -55,7 +54,6 @@ cvar_t	*cl_sensitivity;
 cvar_t	*cl_mouseAccel;
 cvar_t	*cl_showMouseRate;
 
-cvar_t	*m_pitchVeh;
 cvar_t	*m_pitch;
 cvar_t	*m_yaw;
 cvar_t	*m_forward;
@@ -74,8 +72,6 @@ cvar_t	*cl_inGameVideo;
 cvar_t	*cl_serverStatusResendTime;
 cvar_t	*cl_framerate;
 
-cvar_t	*cl_autolodscale;
-
 vec3_t cl_windVec;
 
 
@@ -506,7 +502,7 @@ void CL_PlayDemo_f( void ) {
 	char		*arg;
 
 	if (Cmd_Argc() != 2) {
-		Com_Printf ("playdemo <demoname>\n");
+		Com_Printf ("demo <demoname>\n");
 		return;
 	}
 
@@ -533,7 +529,7 @@ void CL_PlayDemo_f( void ) {
 	if (!clc.demofile) {
 		if (!Q_stricmp(arg, "(null)"))
 		{
-			Com_Error( ERR_DROP, SE_GetString("CON_TEXT_NO_DEMO_SELECTED") );
+			Com_Error( ERR_DROP, "Server was killed" );
 		}
 		else
 		{
@@ -1098,7 +1094,6 @@ we also have to reload the UI and CGame because the renderer
 doesn't know what graphics to reload
 =================
 */
-extern bool g_nOverrideChecked;
 void CL_Vid_Restart_f( void ) {
 	// Settings may have changed so stop recording now
 	if( CL_VideoRecording( ) ) {
@@ -1108,11 +1103,6 @@ void CL_Vid_Restart_f( void ) {
 	if(clc.demorecording)
 		CL_StopRecord_f();
 
-	//rww - sort of nasty, but when a user selects a mod
-	//from the menu all it does is a vid_restart, so we
-	//have to check for new net overrides for the mod then.
-	g_nOverrideChecked = false;
-
 	// don't let them loop during the restart
 	S_StopAllSounds();
 	// shutdown the UI
@@ -1561,12 +1551,10 @@ void CL_InitServerInfo( serverInfo_t *server, serverAddress_t *address ) {
 	server->minPing = 0;
 	server->netType = 0;
 	server->needPassword = qfalse;
-	server->trueJedi = 0;
-	server->weaponDisable = 0;
-	server->forceDisable = 0;
 	server->ping = -1;
 	server->game[0] = '\0';
-	server->gameType = 0;
+	server->gameType[0] = '\0';
+	server->allowAnonymous = 0;
 	//server->pure = qfalse;
 }
 
@@ -1592,10 +1580,6 @@ void CL_ServersResponsePacket( netadr_t from, msg_t *msg ) {
 		cls.numGlobalServerAddresses = 0;
 	}
 
-	if (cls.nummplayerservers == -1) {
-		cls.nummplayerservers = 0;
-	}
-
 	// parse through server response string
 	numservers = 0;
 	buffptr    = msg->data;
@@ -1646,17 +1630,12 @@ void CL_ServersResponsePacket( netadr_t from, msg_t *msg ) {
 		}
 	}
 
-	if (cls.masterNum == 0) {
-		count = cls.numglobalservers;
-		max = MAX_GLOBAL_SERVERS;
-	} else {
-		count = cls.nummplayerservers;
-		max = MAX_OTHER_SERVERS;
-	}
+	count = cls.numglobalservers;
+	max = MAX_GLOBAL_SERVERS;
 
 	for (i = 0; i < numservers && count < max; i++) {
 		// build net address
-		serverInfo_t *server = (cls.masterNum == 0) ? &cls.globalServers[count] : &cls.mplayerServers[count];
+		serverInfo_t *server = &cls.globalServers[count];
 
 		CL_InitServerInfo( server, &addresses[i] );
 		// advance to next slot
@@ -1680,90 +1659,12 @@ void CL_ServersResponsePacket( netadr_t from, msg_t *msg ) {
 		}
 	}
 
-	if (cls.masterNum == 0) {
-		cls.numglobalservers = count;
-		total = count + cls.numGlobalServerAddresses;
-	} else {
-		cls.nummplayerservers = count;
-		total = count;
-	}
+	cls.numglobalservers = count;
+	total = count + cls.numGlobalServerAddresses;
 
 	Com_Printf("%d servers parsed (total %d)\n", numservers, total);
 }
 
-#ifndef MAX_STRINGED_SV_STRING
-#define MAX_STRINGED_SV_STRING 1024
-#endif
-static void CL_CheckSVStringEdRef(char *buf, const char *str)
-{ //I don't really like doing this. But it utilizes the system that was already in place.
-	int i = 0;
-	int b = 0;
-	int strLen = 0;
-	qboolean gotStrip = qfalse;
-
-	if (!str || !str[0])
-	{
-		if (str)
-		{
-			strcpy(buf, str);
-		}
-		return;
-	}
-
-	strcpy(buf, str);
-
-	strLen = strlen(str);
-
-	if (strLen >= MAX_STRINGED_SV_STRING)
-	{
-		return;
-	}
-
-	while (i < strLen && str[i])
-	{
-		gotStrip = qfalse;
-
-		if (str[i] == '@' && (i+1) < strLen)
-		{
-			if (str[i+1] == '@' && (i+2) < strLen)
-			{
-				if (str[i+2] == '@' && (i+3) < strLen)
-				{ //@@@ should mean to insert a stringed reference here, so insert it into buf at the current place
-					char stripRef[MAX_STRINGED_SV_STRING];
-					int r = 0;
-
-					while (i < strLen && str[i] == '@')
-					{
-						i++;
-					}
-
-					while (i < strLen && str[i] && str[i] != ' ' && str[i] != ':' && str[i] != '.' && str[i] != '\n')
-					{
-						stripRef[r] = str[i];
-						r++;
-						i++;
-					}
-					stripRef[r] = 0;
-
-					buf[b] = 0;
-					Q_strcat(buf, MAX_STRINGED_SV_STRING, SE_GetString(va("MP_SVGAME_%s", stripRef)));
-					b = strlen(buf);
-				}
-			}
-		}
-
-		if (!gotStrip)
-		{
-			buf[b] = str[i];
-			b++;
-		}
-		i++;
-	}
-
-	buf[b] = 0;
-}
-
-
 /*
 =================
 CL_ConnectionlessPacket
@@ -1885,12 +1786,9 @@ void CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {
 		// NOTE: we may have to add exceptions for auth and update servers
 		if (NET_CompareAdr(from, clc.serverAddress) || NET_CompareAdr(from, rcon_address))
 		{
-			char sTemp[MAX_STRINGED_SV_STRING];
-
 			s = MSG_ReadString( msg );
-			CL_CheckSVStringEdRef(sTemp, s);
-			Q_strncpyz( clc.serverMessage, sTemp, sizeof( clc.serverMessage ) );
-			Com_Printf( "%s", sTemp );
+			Q_strncpyz( clc.serverMessage, s, sizeof( clc.serverMessage ) );
+			Com_Printf( "%s", s );
 		}
 		return;
 	}
@@ -1980,9 +1878,7 @@ void CL_CheckTimeout( void ) {
 		&& cls.state >= CA_CONNECTED && cls.state != CA_CINEMATIC
 	    && cls.realtime - clc.lastPacketTime > cl_timeout->value*1000) {
 		if (++cl.timeoutcount > 5) {	// timeoutcount saves debugger
-			const char *psTimedOut = SE_GetString("MP_SVGAME_SERVER_CONNECTION_TIMED_OUT");
-			Com_Printf ("\n%s\n",psTimedOut);
-			Com_Error(ERR_DROP, psTimedOut);
+			Com_Error(ERR_DROP, "Server connection timed out.");
 			//CL_Disconnect( qtrue );
 			return;
 		}
@@ -2041,16 +1937,12 @@ CL_Frame
 */
 static unsigned int frameCount;
 static float avgFrametime=0.0;
-extern void SE_CheckForLanguageUpdates(void);
 void CL_Frame ( int msec ) {
 
 	if ( !com_cl_running->integer ) {
 		return;
 	}
 
-	SE_CheckForLanguageUpdates();	// will take zero time to execute unless language changes, then will reload strings.
-									//	of course this still doesn't work for menus...
-
 	if ( cls.state == CA_DISCONNECTED && !( cls.keyCatchers & KEYCATCH_UI )
 		&& !com_sv_running->integer ) {
 		// if disconnected, bring up the menu
@@ -2193,10 +2085,10 @@ void CL_InitRenderer( void ) {
 	re.BeginRegistration( &cls.glconfig );
 
 	// load character sets
-	cls.charSetShader = re.RegisterShaderNoMip("gfx/2d/charsgrid_med");
+	cls.charSetShader = re.RegisterShaderNoMip("gfx/2d/bigchars");
 
 	cls.whiteShader = re.RegisterShader( "white" );
-	cls.consoleShader = re.RegisterShader( "console" );
+	cls.consoleShader = re.RegisterShader( "gfx/menus/console/console_mp" );
 	g_console_field_width = cls.glconfig.vidWidth / SMALLCHAR_WIDTH - 2;
 	kg.g_consoleField.widthInChars = g_console_field_width;
 }
@@ -2335,7 +2227,6 @@ void CL_InitRef( void ) {
 	ri.Cvar_VariableValue = Cvar_VariableValue;
 	ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;
 	ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;
-	ri.SE_GetString = SE_GetString;
 	ri.FS_FreeFile = FS_FreeFile;
 	ri.FS_FreeFileList = FS_FreeFileList;
 	ri.FS_Read = FS_Read;
@@ -2444,10 +2335,6 @@ void CL_SetModel_f( void ) {
 	}
 }
 
-void CL_SetForcePowers_f( void ) {
-	return;
-}
-
 /*
 ===============
 CL_Video_f
@@ -2524,7 +2411,7 @@ CL_Init
 ====================
 */
 void CL_Init( void ) {
-//	Com_Printf( "----- Client Initialization -----\n" );
+	Com_Printf( "----- Client Initialization -----\n" );
 
 	Con_Init ();	
 
@@ -2576,8 +2463,6 @@ void CL_Init( void ) {
 	cl_allowDownload = Cvar_Get ("cl_allowDownload", "0", CVAR_ARCHIVE);
 	cl_allowAltEnter = Cvar_Get ("cl_allowAltEnter", "0", CVAR_ARCHIVE);
 
-	cl_autolodscale = Cvar_Get( "cl_autolodscale", "1", CVAR_ARCHIVE );
-
 	cl_conXOffset = Cvar_Get ("cl_conXOffset", "0", 0);
 #ifdef MACOS_X
         // In game video is REALLY slow in Mac OS X right now due to driver slowness
@@ -2592,7 +2477,6 @@ void CL_Init( void ) {
 	// if the cgame hasn't been started
 	Cvar_Get ("cg_autoswitch", "1", CVAR_ARCHIVE);
 
-	m_pitchVeh = Cvar_Get ("m_pitchVeh", "0.022", CVAR_ARCHIVE);
 	m_pitch = Cvar_Get ("m_pitch", "0.022", CVAR_ARCHIVE);
 	m_yaw = Cvar_Get ("m_yaw", "0.022", CVAR_ARCHIVE);
 	m_forward = Cvar_Get ("m_forward", "0.25", CVAR_ARCHIVE);
@@ -2613,27 +2497,10 @@ void CL_Init( void ) {
 	Cvar_Get ("name", "Padawan", CVAR_USERINFO | CVAR_ARCHIVE );
 	Cvar_Get ("rate", "25000", CVAR_USERINFO | CVAR_ARCHIVE );
 	Cvar_Get ("snaps", "40", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("model", "kyle/default", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("forcepowers", "7-1-032330000000001333", CVAR_USERINFO | CVAR_ARCHIVE );
-//	Cvar_Get ("g_redTeam", "Empire", CVAR_SERVERINFO | CVAR_ARCHIVE);
-//	Cvar_Get ("g_blueTeam", "Rebellion", CVAR_SERVERINFO | CVAR_ARCHIVE);
-	Cvar_Get ("color1",  "4", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("color2", "4", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("handicap", "100", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("teamtask", "0", CVAR_USERINFO );
-	Cvar_Get ("sex", "male", CVAR_USERINFO | CVAR_ARCHIVE );
+	Cvar_Get ("identity", "snowsoldier1", CVAR_USERINFO | CVAR_ARCHIVE );
 	Cvar_Get ("password", "", CVAR_USERINFO);
 	Cvar_Get ("cg_predictItems", "1", CVAR_USERINFO | CVAR_ARCHIVE );
 
-	//default sabers
-	Cvar_Get ("saber1",  "single_1", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("saber2",  "none", CVAR_USERINFO | CVAR_ARCHIVE );
-
-	//skin color
-	Cvar_Get ("char_color_red",  "255", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("char_color_green",  "255", CVAR_USERINFO | CVAR_ARCHIVE );
-	Cvar_Get ("char_color_blue",  "255", CVAR_USERINFO | CVAR_ARCHIVE );
-
 	// cgame might not be initialized before menu is used
 	Cvar_Get ("cg_viewsize", "100", CVAR_ARCHIVE );
 
@@ -2661,7 +2528,6 @@ void CL_Init( void ) {
 	Cmd_AddCommand ("fs_openedList", CL_OpenedPK3List_f );
 	Cmd_AddCommand ("fs_referencedList", CL_ReferencedPK3List_f );
 	Cmd_AddCommand ("model", CL_SetModel_f );
-	Cmd_AddCommand ("forcepowers", CL_SetForcePowers_f );
 	Cmd_AddCommand ("video", CL_Video_f );
 	Cmd_AddCommand ("stopvideo", CL_StopVideo_f );
 
@@ -2675,7 +2541,7 @@ void CL_Init( void ) {
 
 	G2VertSpaceClient = new CMiniHeap(G2_VERT_SPACE_CLIENT_SIZE * 1024);
 
-//	Com_Printf( "----- Client Initialization Complete -----\n" );
+	Com_Printf( "----- Client Initialization Complete -----\n" );
 }
 
 
@@ -2728,7 +2594,6 @@ void CL_Shutdown( void ) {
 	Cmd_RemoveCommand ("serverstatus");
 	Cmd_RemoveCommand ("showip");
 	Cmd_RemoveCommand ("model");
-	Cmd_RemoveCommand ("forcepowers");
 	Cmd_RemoveCommand ("video");
 	Cmd_RemoveCommand ("stopvideo");
 
@@ -2750,19 +2615,17 @@ static void CL_SetServerInfo(serverInfo_t *server, const char *info, int ping) {
 			Q_strncpyz(server->mapName, Info_ValueForKey(info, "mapname"), MAX_NAME_LENGTH);
 			server->maxClients = atoi(Info_ValueForKey(info, "sv_maxclients"));
 			Q_strncpyz(server->game,Info_ValueForKey(info, "game"), MAX_NAME_LENGTH);
-			server->gameType = atoi(Info_ValueForKey(info, "gametype"));
+			Q_strncpyz(server->gameType,Info_ValueForKey(info, "gametype"), MAX_NAME_LENGTH);
 			server->netType = atoi(Info_ValueForKey(info, "nettype"));
 			server->minPing = atoi(Info_ValueForKey(info, "minping"));
 			server->maxPing = atoi(Info_ValueForKey(info, "maxping"));
-//			server->allowAnonymous = atoi(Info_ValueForKey(info, "sv_allowAnonymous"));
+			server->allowAnonymous = atoi(Info_ValueForKey(info, "sv_allowAnonymous"));
 			server->needPassword = (qboolean)atoi(Info_ValueForKey(info, "needpass" ));
-			server->trueJedi = atoi(Info_ValueForKey(info, "truejedi" ));
-			server->weaponDisable = atoi(Info_ValueForKey(info, "wdisable" ));
-			server->forceDisable = atoi(Info_ValueForKey(info, "fdisable" ));
 //			server->pure = (qboolean)atoi(Info_ValueForKey(info, "pure" ));
 		}
 		server->ping = ping;
 	}
+
 }
 
 static void CL_SetServerInfoByAddress(netadr_t from, const char *info, int ping) {
@@ -2774,12 +2637,6 @@ static void CL_SetServerInfoByAddress(netadr_t from, const char *info, int ping)
 		}
 	}
 
-	for (i = 0; i < MAX_OTHER_SERVERS; i++) {
-		if (NET_CompareAdr(from, cls.mplayerServers[i].adr)) {
-			CL_SetServerInfo(&cls.mplayerServers[i], info, ping);
-		}
-	}
-
 	for (i = 0; i < MAX_GLOBAL_SERVERS; i++) {
 		if (NET_CompareAdr(from, cls.globalServers[i].adr)) {
 			CL_SetServerInfo(&cls.globalServers[i], info, ping);
@@ -2888,13 +2745,10 @@ void CL_ServerInfoPacket( netadr_t from, msg_t *msg ) {
 	cls.localServers[i].minPing = 0;
 	cls.localServers[i].netType = from.type;
 	cls.localServers[i].needPassword = qfalse;
-	cls.localServers[i].trueJedi = 0;
-	cls.localServers[i].weaponDisable = 0;
-	cls.localServers[i].forceDisable = 0;
 	cls.localServers[i].ping = -1;
 	cls.localServers[i].game[0] = '\0';
-	cls.localServers[i].gameType = 0;
-//	cls.localServers[i].allowAnonymous = 0;
+	cls.localServers[i].gameType[0] = '\0';
+	cls.localServers[i].allowAnonymous = 0;
 //	cls.localServers[i].pure = qfalse;
 
 	Q_strncpyz( info, MSG_ReadString( msg ), MAX_INFO_STRING );
@@ -3424,10 +3278,6 @@ qboolean CL_UpdateVisiblePings_f(int source) {
 				server = &cls.localServers[0];
 				max = cls.numlocalservers;
 			break;
-			case AS_MPLAYER :
-				server = &cls.mplayerServers[0];
-				max = cls.nummplayerservers;
-			break;
 			case AS_GLOBAL :
 				server = &cls.globalServers[0];
 				max = cls.numglobalservers;
diff --git a/codemp/client/cl_parse.cpp b/codemp/client/cl_parse.cpp
index a19991c..426eb43 100644
--- a/codemp/client/cl_parse.cpp
+++ b/codemp/client/cl_parse.cpp
@@ -4,7 +4,6 @@
 // cl_parse.c  -- parse a message received from the server
 
 #include "client.h"
-#include "qcommon/stringed_ingame.h"
 //#include "ghoul2/G2_local.h"
 #ifdef _DONETPROFILE_
 #include "qcommon/INetProfile.h"
@@ -23,7 +22,6 @@ char *svc_strings[256] = {
 	"svc_serverCommand",
 	"svc_download",
 	"svc_snapshot",
-	"svc_setgame",
 	"svc_mapchange",
 };
 
@@ -261,16 +259,8 @@ void CL_ParseSnapshot( msg_t *msg ) {
 	SHOWNET( msg, "playerstate" );
 	if ( old ) {
 		MSG_ReadDeltaPlayerstate( msg, &old->ps, &newSnap.ps );
-		if (newSnap.ps.m_iVehicleNum)
-		{ //this means we must have written our vehicle's ps too
-			MSG_ReadDeltaPlayerstate( msg, &old->vps, &newSnap.vps, qtrue );
-		}
 	} else {
 		MSG_ReadDeltaPlayerstate( msg, NULL, &newSnap.ps );
-		if (newSnap.ps.m_iVehicleNum)
-		{ //this means we must have written our vehicle's ps too
-			MSG_ReadDeltaPlayerstate( msg, NULL, &newSnap.vps, qtrue );			
-		}
 	}
 
 	// read packet entities
@@ -318,50 +308,6 @@ void CL_ParseSnapshot( msg_t *msg ) {
 	cl.newSnapshots = qtrue;
 }
 
-
-/*
-================
-CL_ParseSetGame
-
-rww - Update fs_game, this message is so we can use the ext_data
-*_overrides.txt files for mods.
-================
-*/
-void MSG_CheckNETFPSFOverrides(qboolean psfOverrides);
-void FS_UpdateGamedir(void);
-void CL_ParseSetGame( msg_t *msg )
-{
-	char newGameDir[MAX_QPATH];
-	int i = 0;
-	char next;
-
-	while (i < MAX_QPATH)
-	{
-		next = MSG_ReadByte( msg );
-
-		if (next)
-		{ //if next is 0 then we have finished reading to the end of the message
-			newGameDir[i] = next;
-		}
-		else
-		{
-			break;
-		}
-		i++;
-	}
-	newGameDir[i] = 0;
-
-	Cvar_Set("fs_game", newGameDir);
-
-	//Update the search path for the mod dir
-	FS_UpdateGamedir();
-
-	//Now update the overrides manually
-	MSG_CheckNETFPSFOverrides(qfalse);
-	MSG_CheckNETFPSFOverrides(qtrue);
-}
-
-
 //=====================================================================
 
 int cl_connectedToPureServer;
@@ -478,10 +424,14 @@ void CL_ParseAutomapSymbols ( msg_t* msg )
 void CL_ParseRMG ( msg_t* msg )
 {
 	clc.rmgHeightMapSize = (unsigned short)MSG_ReadShort ( msg );
+	//SOF2 TODO
+	MSG_ReadLong ( msg );
 	if ( !clc.rmgHeightMapSize )
 	{
 		return;
 	}
+	//SOF2 TODO
+	Com_Error (ERR_DROP,"RMG maps are currently not supported\n");
 
 	z_stream zdata;
 	int		 size;
@@ -558,11 +508,6 @@ void CL_ParseGamestate( msg_t *msg ) {
 	// wipe local client state
 	CL_ClearState();
 
-#ifdef _DONETPROFILE_
-	int startBytes,endBytes;
-	startBytes=msg->readcount;
-#endif
-
 	// a gamestate always marks a server command sequence
 	clc.serverCommandSequence = MSG_ReadLong( msg );
 
@@ -576,51 +521,13 @@ void CL_ParseGamestate( msg_t *msg ) {
 		}
 		
 		if ( cmd == svc_configstring ) {
-			int		len, start;
-
-			start = msg->readcount;
+			int		len;
 
 			i = MSG_ReadShort( msg );
 			if ( i < 0 || i >= MAX_CONFIGSTRINGS ) {
 				Com_Error( ERR_DROP, "configstring > MAX_CONFIGSTRINGS" );
 			}
 			s = MSG_ReadBigString( msg );
-
-			if (cl_shownet->integer >= 2)
-			{
-				Com_Printf("%3i: %d: %s\n", start, i, s);
-			}
-
-			/*
-			if (i == CS_SERVERINFO)
-			{ //get the special value here
-				char *f = strstr(s, "g_debugMelee");
-				if (f)
-				{
-					while (*f && *f != '\\')
-					{ //find the \ after it
-						f++;
-					}
-					if (*f == '\\')
-					{ //got it
-						int i = 0;
-
-						f++;
-						while (*f && *f != '\\' && i < 128)
-						{
-							hiddenCvarVal[i] = *f;
-							i++;
-							f++;
-						}
-						hiddenCvarVal[i] = 0;
-
-						//resume here
-						s = f;
-					}
-				}
-			}
-			*/
-
 			len = strlen( s );
 
 			if ( len + 1 + cl.gameState.dataCount > MAX_GAMESTATE_CHARS ) {
@@ -650,11 +557,6 @@ void CL_ParseGamestate( msg_t *msg ) {
 
 	CL_ParseRMG ( msg ); //rwwRMG - get info for it from the server
 
-#ifdef _DONETPROFILE_
-	endBytes=msg->readcount;
-//	ClReadProf().AddField("svc_gamestate",endBytes-startBytes);
-#endif
-
 	// parse serverId and other cvars
 	CL_SystemInfoChanged();
 
@@ -787,16 +689,8 @@ void CL_ParseCommandString( msg_t *msg ) {
 	int		seq;
 	int		index;
 
-#ifdef _DONETPROFILE_
-	int startBytes,endBytes;
-	startBytes=msg->readcount;
-#endif
 	seq = MSG_ReadLong( msg );
 	s = MSG_ReadString( msg );
-#ifdef _DONETPROFILE_
-	endBytes=msg->readcount;
-	ClReadProf().AddField("svc_serverCommand",endBytes-startBytes);
-#endif
 	// see if we have already executed stored it off
 	if ( clc.serverCommandSequence >= seq ) {
 		return;
@@ -918,9 +812,6 @@ void CL_ParseServerMessage( msg_t *msg ) {
 		case svc_snapshot:
 			CL_ParseSnapshot( msg );
 			break;
-		case svc_setgame:
-			CL_ParseSetGame( msg );
-			break;
 		case svc_download:
 			CL_ParseDownload( msg );
 			break;
diff --git a/codemp/client/cl_scrn.cpp b/codemp/client/cl_scrn.cpp
index 6976a0f..ebeae1a 100644
--- a/codemp/client/cl_scrn.cpp
+++ b/codemp/client/cl_scrn.cpp
@@ -91,7 +91,7 @@ static void SCR_DrawChar( int x, int y, float size, int ch ) {
 
 	frow = row*0.0625;
 	fcol = col*0.0625;
-	size = 0.03125;
+	size = 0.0625;
 	size2 = 0.0625;
 
 	re.DrawStretchPic( ax, ay, aw, ah,
@@ -127,11 +127,7 @@ void SCR_DrawSmallChar( int x, int y, int ch ) {
 	frow = row*0.0625;
 	fcol = col*0.0625;
 
-#ifdef _JK2
-	size = 0.03125;
-#else
 	size = 0.0625;
-#endif
 	size2 = 0.0625;
 
 	re.DrawStretchPic( x * con.xadjust, y * con.yadjust, 
@@ -168,7 +164,10 @@ void SCR_DrawStringExt( int x, int y, float size, const char *string, float *set
 			s += 2;
 			continue;
 		}
+		SCR_DrawChar( xx-2, y-2, size, *s );
+		SCR_DrawChar( xx-2, y+2, size, *s );
 		SCR_DrawChar( xx+2, y+2, size, *s );
+		SCR_DrawChar( xx+2, y-2, size, *s );
 		xx += size;
 		s++;
 	}
@@ -201,11 +200,11 @@ void SCR_DrawBigString( int x, int y, const char *s, float alpha ) {
 
 	color[0] = color[1] = color[2] = 1.0;
 	color[3] = alpha;
-	SCR_DrawStringExt( x, y, BIGCHAR_WIDTH, s, color, qfalse );
+	SCR_DrawStringExt( x, y, GIANTCHAR_HEIGHT/2, s, color, qfalse );
 }
 
 void SCR_DrawBigStringColor( int x, int y, const char *s, vec4_t color ) {
-	SCR_DrawStringExt( x, y, BIGCHAR_WIDTH, s, color, qtrue );
+	SCR_DrawStringExt( x, y, GIANTCHAR_HEIGHT/2, s, color, qtrue );
 }
 
 
@@ -245,35 +244,6 @@ void SCR_DrawSmallStringExt( int x, int y, const char *string, float *setColor,
 	re.SetColor( NULL );
 }
 
-
-
-/*
-** SCR_Strlen -- skips color escape codes
-*/
-static int SCR_Strlen( const char *str ) {
-	const char *s = str;
-	int count = 0;
-
-	while ( *s ) {
-		if ( Q_IsColorString( s ) ) {
-			s += 2;
-		} else {
-			count++;
-			s++;
-		}
-	}
-
-	return count;
-}
-
-/*
-** SCR_GetBigStringWidth
-*/ 
-int	SCR_GetBigStringWidth( const char *str ) {
-	return SCR_Strlen( str ) * 16;
-}
-
-
 //===============================================================================
 
 /*
@@ -415,7 +385,7 @@ void SCR_DrawScreenField( stereoFrame_t stereoFrame ) {
 	// don't need to render anything under it
 	//actually, yes you do, unless you want clients to cycle out their reliable
 	//commands from sitting in the menu. -rww
-	if ( (uivm && !uiFullscreen) || (!(cls.framecount&7) && cls.state == CA_ACTIVE) ) {
+	if ( !uiFullscreen || (!(cls.framecount&7) && cls.state == CA_ACTIVE) ) {
 	//if ( !VM_Call( uivm, UI_IS_FULLSCREEN ) || (!(cls.framecount&7) && cls.state == CA_ACTIVE)) {
 		switch( cls.state ) {
 		default:
@@ -456,7 +426,7 @@ void SCR_DrawScreenField( stereoFrame_t stereoFrame ) {
 	}
 
 	// the menu draws next
-	if ( cls.keyCatchers & KEYCATCH_UI && uivm ) {
+	if ( cls.keyCatchers & KEYCATCH_UI ) {
 		VM_Call( uivm, UI_REFRESH, cls.realtime );
 	}
 
diff --git a/codemp/client/cl_ui.cpp b/codemp/client/cl_ui.cpp
index 005e9a4..0768231 100644
--- a/codemp/client/cl_ui.cpp
+++ b/codemp/client/cl_ui.cpp
@@ -4,7 +4,6 @@
 #include "client.h"
 
 #include "botlib/botlib.h"
-#include "qcommon/stringed_ingame.h"
 
 /*
 Ghoul2 Insert Start
@@ -22,11 +21,16 @@ Ghoul2 Insert End
 #include "renderer/tr_lightmanager.h"
 #endif
 
+#if !defined(GENERICPARSER2_H_INC)
+#include "qcommon/GenericParser2.h"
+#endif
+
 extern	botlib_export_t	*botlib_export;
 void SP_Register(const char *Package);
 
 vm_t *uivm;
 
+
 /*
 ====================
 GetClientState
@@ -49,19 +53,17 @@ LAN_LoadCachedServers
 void LAN_LoadCachedServers( ) {
 	int size;
 	fileHandle_t fileIn;
-	cls.numglobalservers = cls.nummplayerservers = cls.numfavoriteservers = 0;
+	cls.numglobalservers = cls.numfavoriteservers = 0;
 	cls.numGlobalServerAddresses = 0;
 	if (FS_SV_FOpenFileRead("servercache.dat", &fileIn)) {
 		FS_Read(&cls.numglobalservers, sizeof(int), fileIn);
-		FS_Read(&cls.nummplayerservers, sizeof(int), fileIn);
 		FS_Read(&cls.numfavoriteservers, sizeof(int), fileIn);
 		FS_Read(&size, sizeof(int), fileIn);
-		if (size == sizeof(cls.globalServers) + sizeof(cls.favoriteServers) + sizeof(cls.mplayerServers)) {
+		if (size == sizeof(cls.globalServers) + sizeof(cls.favoriteServers)) {
 			FS_Read(&cls.globalServers, sizeof(cls.globalServers), fileIn);
-			FS_Read(&cls.mplayerServers, sizeof(cls.mplayerServers), fileIn);
 			FS_Read(&cls.favoriteServers, sizeof(cls.favoriteServers), fileIn);
 		} else {
-			cls.numglobalservers = cls.nummplayerservers = cls.numfavoriteservers = 0;
+			cls.numglobalservers = cls.numfavoriteservers = 0;
 			cls.numGlobalServerAddresses = 0;
 		}
 		FS_FCloseFile(fileIn);
@@ -77,12 +79,10 @@ void LAN_SaveServersToCache( ) {
 	int size;
 	fileHandle_t fileOut = FS_SV_FOpenFileWrite("servercache.dat");
 	FS_Write(&cls.numglobalservers, sizeof(int), fileOut);
-	FS_Write(&cls.nummplayerservers, sizeof(int), fileOut);
 	FS_Write(&cls.numfavoriteservers, sizeof(int), fileOut);
-	size = sizeof(cls.globalServers) + sizeof(cls.favoriteServers) + sizeof(cls.mplayerServers);
+	size = sizeof(cls.globalServers) + sizeof(cls.favoriteServers);
 	FS_Write(&size, sizeof(int), fileOut);
 	FS_Write(&cls.globalServers, sizeof(cls.globalServers), fileOut);
-	FS_Write(&cls.mplayerServers, sizeof(cls.mplayerServers), fileOut);
 	FS_Write(&cls.favoriteServers, sizeof(cls.favoriteServers), fileOut);
 	FS_FCloseFile(fileOut);
 }
@@ -103,10 +103,6 @@ static void LAN_ResetPings(int source) {
 			servers = &cls.localServers[0];
 			count = MAX_OTHER_SERVERS;
 			break;
-		case AS_MPLAYER :
-			servers = &cls.mplayerServers[0];
-			count = MAX_OTHER_SERVERS;
-			break;
 		case AS_GLOBAL :
 			servers = &cls.globalServers[0];
 			count = MAX_GLOBAL_SERVERS;
@@ -140,10 +136,6 @@ static int LAN_AddServer(int source, const char *name, const char *address) {
 			count = &cls.numlocalservers;
 			servers = &cls.localServers[0];
 			break;
-		case AS_MPLAYER :
-			count = &cls.nummplayerservers;
-			servers = &cls.mplayerServers[0];
-			break;
 		case AS_GLOBAL :
 			max = MAX_GLOBAL_SERVERS;
 			count = &cls.numglobalservers;
@@ -196,10 +188,6 @@ static void LAN_RemoveServer(int source, const char *addr) {
 			count = &cls.numlocalservers;
 			servers = &cls.localServers[0];
 			break;
-		case AS_MPLAYER :
-			count = &cls.nummplayerservers;
-			servers = &cls.mplayerServers[0];
-			break;
 		case AS_GLOBAL :
 			count = &cls.numglobalservers;
 			servers = &cls.globalServers[0];
@@ -237,9 +225,6 @@ static int LAN_GetServerCount( int source ) {
 		case AS_LOCAL :
 			return cls.numlocalservers;
 			break;
-		case AS_MPLAYER :
-			return cls.nummplayerservers;
-			break;
 		case AS_GLOBAL :
 			return cls.numglobalservers;
 			break;
@@ -263,12 +248,6 @@ static void LAN_GetServerAddressString( int source, int n, char *buf, int buflen
 				return;
 			}
 			break;
-		case AS_MPLAYER :
-			if (n >= 0 && n < MAX_OTHER_SERVERS) {
-				Q_strncpyz(buf, NET_AdrToString( cls.mplayerServers[n].adr) , buflen );
-				return;
-			}
-			break;
 		case AS_GLOBAL :
 			if (n >= 0 && n < MAX_GLOBAL_SERVERS) {
 				Q_strncpyz(buf, NET_AdrToString( cls.globalServers[n].adr) , buflen );
@@ -300,11 +279,6 @@ static void LAN_GetServerInfo( int source, int n, char *buf, int buflen ) {
 				server = &cls.localServers[n];
 			}
 			break;
-		case AS_MPLAYER :
-			if (n >= 0 && n < MAX_OTHER_SERVERS) {
-				server = &cls.mplayerServers[n];
-			}
-			break;
 		case AS_GLOBAL :
 			if (n >= 0 && n < MAX_GLOBAL_SERVERS) {
 				server = &cls.globalServers[n];
@@ -327,13 +301,10 @@ static void LAN_GetServerInfo( int source, int n, char *buf, int buflen ) {
 		Info_SetValueForKey( info, "maxping", va("%i",server->maxPing));
 		Info_SetValueForKey( info, "nettype", va("%i",server->netType));
 		Info_SetValueForKey( info, "needpass", va("%i", server->needPassword ) );
-		Info_SetValueForKey( info, "truejedi", va("%i", server->trueJedi ) );
-		Info_SetValueForKey( info, "wdisable", va("%i", server->weaponDisable ) );
-		Info_SetValueForKey( info, "fdisable", va("%i", server->forceDisable ) );
 		Info_SetValueForKey( info, "game", server->game);
-		Info_SetValueForKey( info, "gametype", va("%i",server->gameType));
+		Info_SetValueForKey( info, "gametype", server->gameType);
 		Info_SetValueForKey( info, "addr", NET_AdrToString(server->adr));
-//		Info_SetValueForKey( info, "sv_allowAnonymous", va("%i", server->allowAnonymous));
+		Info_SetValueForKey( info, "sv_allowAnonymous", va("%i", server->allowAnonymous));
 //		Info_SetValueForKey( info, "pure", va("%i", server->pure ) );
 		Q_strncpyz(buf, info, buflen);
 	} else {
@@ -356,11 +327,6 @@ static int LAN_GetServerPing( int source, int n ) {
 				server = &cls.localServers[n];
 			}
 			break;
-		case AS_MPLAYER :
-			if (n >= 0 && n < MAX_OTHER_SERVERS) {
-				server = &cls.mplayerServers[n];
-			}
-			break;
 		case AS_GLOBAL :
 			if (n >= 0 && n < MAX_GLOBAL_SERVERS) {
 				server = &cls.globalServers[n];
@@ -390,11 +356,6 @@ static serverInfo_t *LAN_GetServerPtr( int source, int n ) {
 				return &cls.localServers[n];
 			}
 			break;
-		case AS_MPLAYER :
-			if (n >= 0 && n < MAX_OTHER_SERVERS) {
-				return &cls.mplayerServers[n];
-			}
-			break;
 		case AS_GLOBAL :
 			if (n >= 0 && n < MAX_GLOBAL_SERVERS) {
 				return &cls.globalServers[n];
@@ -527,9 +488,6 @@ static void LAN_MarkServerVisible(int source, int n, qboolean visible ) {
 			case AS_LOCAL :
 				server = &cls.localServers[0];
 				break;
-			case AS_MPLAYER :
-				server = &cls.mplayerServers[0];
-				break;
 			case AS_GLOBAL :
 				server = &cls.globalServers[0];
 				count = MAX_GLOBAL_SERVERS;
@@ -551,11 +509,6 @@ static void LAN_MarkServerVisible(int source, int n, qboolean visible ) {
 					cls.localServers[n].visible = visible;
 				}
 				break;
-			case AS_MPLAYER :
-				if (n >= 0 && n < MAX_OTHER_SERVERS) {
-					cls.mplayerServers[n].visible = visible;
-				}
-				break;
 			case AS_GLOBAL :
 				if (n >= 0 && n < MAX_GLOBAL_SERVERS) {
 					cls.globalServers[n].visible = visible;
@@ -583,11 +536,6 @@ static int LAN_ServerIsVisible(int source, int n ) {
 				return cls.localServers[n].visible;
 			}
 			break;
-		case AS_MPLAYER :
-			if (n >= 0 && n < MAX_OTHER_SERVERS) {
-				return cls.mplayerServers[n].visible;
-			}
-			break;
 		case AS_GLOBAL :
 			if (n >= 0 && n < MAX_GLOBAL_SERVERS) {
 				return cls.globalServers[n].visible;
@@ -660,12 +608,7 @@ Key_KeynumToStringBuf
 void Key_KeynumToStringBuf( int keynum, char *buf, int buflen ) 
 {
 	const char *psKeyName = Key_KeynumToString( keynum/*, qtrue */);
-
-	// see if there's a more friendly (or localised) name...
-	//
-	const char *psKeyNameFriendly = SE_GetString( va("KEYNAMES_KEYNAME_%s",psKeyName) );
-
-	Q_strncpyz( buf, (psKeyNameFriendly && psKeyNameFriendly[0]) ? psKeyNameFriendly : psKeyName, buflen );
+	Q_strncpyz( buf, psKeyName, buflen );
 }
 
 
@@ -754,6 +697,7 @@ CL_UISystemCalls
 The ui module is making a system call
 ====================
 */
+void VM_Shift2(void ** mem);
 int CL_UISystemCalls( int *args ) {
 	switch( args[0] ) {
 	//rww - alright, DO NOT EVER add a GAME/CGAME/UI generic call without adding a trap to match, and
@@ -877,26 +821,12 @@ int CL_UISystemCalls( int *args ) {
 		return re.RegisterModel( (const char *)VMA(1) );
 
 	case UI_R_REGISTERSKIN:
-		return re.RegisterSkin( (const char *)VMA(1) );
+		//SOF2 TODO
+		return re.RegisterSkin( (const char *)VMA(1), 0, NULL );
 
 	case UI_R_REGISTERSHADERNOMIP:
 		return re.RegisterShaderNoMip( (const char *)VMA(1) );
 
-	case UI_R_SHADERNAMEFROMINDEX:
-		{
-			char *gameMem = (char *)VMA(1);
-			const char *retMem = re.ShaderNameFromIndex(args[2]);
-			if (retMem)
-			{
-				strcpy(gameMem, retMem);
-			}
-			else
-			{
-				gameMem[0] = 0;
-			}
-		}
-		return 0;
-
 	case UI_R_CLEARSCENE:
 		re.ClearScene();
 		return 0;
@@ -906,6 +836,7 @@ int CL_UISystemCalls( int *args ) {
 		return 0;
 
 	case UI_R_ADDPOLYTOSCENE:
+		//SOF2 TODO
 		re.AddPolyToScene( args[1], args[2], (const polyVert_t *)VMA(3), 1 );
 		return 0;
 
@@ -926,15 +857,26 @@ int CL_UISystemCalls( int *args ) {
 		return 0;
 
 	case UI_R_DRAWSTRETCHPIC:
-		re.DrawStretchPic( VMF(1), VMF(2), VMF(3), VMF(4), VMF(5), VMF(6), VMF(7), VMF(8), args[9] );
+		re.DrawStretchPic( VMF(1), VMF(2), VMF(3), VMF(4), VMF(5), VMF(6), VMF(7), VMF(8), args[10] );
 		return 0;
 
-  case UI_R_MODELBOUNDS:
+	case UI_R_MODELBOUNDS:
 		re.ModelBounds( args[1], (float *)VMA(2), (float *)VMA(3) );
 		return 0;
 
 	case UI_UPDATESCREEN:
-		SCR_UpdateScreen();
+		if ( args[1] )
+		{
+			// draw loading screen
+			VM_Call( uivm, UI_REFRESH, cls.realtime );
+			VM_Call( uivm, UI_DRAW_LOADING_SCREEN );
+			re.BeginFrame( STEREO_CENTER );
+			re.EndFrame( NULL, NULL );
+		}
+		else
+		{
+			SCR_UpdateScreen();
+		}
 		return 0;
 
 	case UI_CM_LERPTAG:
@@ -996,6 +938,9 @@ int CL_UISystemCalls( int *args ) {
 	case UI_GETCONFIGSTRING:
 		return GetConfigString( args[1], (char *)VMA(2), args[3] );
 
+	case UI_NET_AVAILABLE:
+		return qtrue;
+
 	case UI_LAN_LOADCACHEDSERVERS:
 		LAN_LoadCachedServers();
 		return 0;
@@ -1066,27 +1011,19 @@ int CL_UISystemCalls( int *args ) {
 	case UI_R_REGISTERFONT:
 		return re.RegisterFont( (const char *)VMA(1) );
 
-	case UI_R_FONT_STRLENPIXELS:
-		return re.Font_StrLenPixels( (const char *)VMA(1), args[2], VMF(3) );
+	case UI_R_GETTEXTWIDTH:
+		return re.Font_StrLenPixels((const char *)VMA(1), args[2], VMF(3));
 
-	case UI_R_FONT_STRLENCHARS:
-		return re.Font_StrLenChars( (const char *)VMA(1) );
-
-	case UI_R_FONT_STRHEIGHTPIXELS:
-		return re.Font_HeightPixels( args[1], VMF(2) );
-
-	case UI_R_FONT_DRAWSTRING:
-		re.Font_DrawString( args[1], args[2], (const char *)VMA(3), (const float *) VMA(4), args[5], args[6], VMF(7) );
+	case UI_R_GETTEXTHEIGHT:
+		return re.Font_HeightPixels(args[2], VMF(3));
+		
+	case UI_R_DRAWTEXTWITHCURSOR:
+		re.Font_DrawString(args[1], args[2], args[3], VMF(4), (vec_t *)VMA(5), (const char *)VMA(6), args[7], args[8], args[9], args[10]);
 		return 0;
 
-	case UI_LANGUAGE_ISASIAN:
-		return re.Language_IsAsian();
-
-	case UI_LANGUAGE_USESSPACES:
-		return re.Language_UsesSpaces();
-
-	case UI_ANYLANGUAGE_READCHARFROMSTRING:
-		return re.AnyLanguage_ReadCharFromString( (const char *)VMA(1), (int *) VMA(2), (qboolean *) VMA(3) );
+	case UI_R_DRAWTEXT:
+		re.Font_DrawString(args[1], args[2], args[3], VMF(4), (vec_t *)VMA(5), (const char *)VMA(6), args[7], args[8], 0, 0);
+		return 0;
 
 	case UI_PC_ADD_GLOBAL_DEFINE:
 		return botlib_export->PC_AddGlobalDefine( (char *)VMA(1) );
@@ -1136,29 +1073,6 @@ int CL_UISystemCalls( int *args ) {
 		re.RemapShader( (const char *)VMA(1), (const char *)VMA(2), (const char *)VMA(3) );
 		return 0;
 
-	case UI_SP_GETNUMLANGUAGES:
-		return SE_GetNumLanguages();
-
-	case UI_SP_GETLANGUAGENAME:
-		char *languageName,*holdName;
-
-		holdName = ((char *)VMA(2));
-		languageName = (char *) SE_GetLanguageName((const int)VMA(1));
-		Q_strncpyz( holdName, languageName,128 );
-		return 0;
-
-	case UI_SP_GETSTRINGTEXTSTRING:
-		const char* text;
-
-		assert(VMA(1));
-		assert(VMA(2));
-		text = SE_GetString((const char *) VMA(1));
-		Q_strncpyz( (char *) VMA(2), text, args[3] );
-		return qtrue;
-
-/*
-Ghoul2 Insert Start
-*/
 /*
 Ghoul2 Insert Start
 */
@@ -1181,7 +1095,7 @@ Ghoul2 Insert Start
 	case UI_G2_GETBOLT:
 		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
 
-	case UI_G2_GETBOLT_NOREC:
+	/*case UI_G2_GETBOLT_NOREC:
 		re.G2API_BoltMatrixReconstruction( qfalse );//gG2_GBMNoReconstruct = qtrue;
 		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
 
@@ -1189,7 +1103,7 @@ Ghoul2 Insert Start
 		//RAZFIXME: cgame reconstructs bolt matrix, why is this different?
 		re.G2API_BoltMatrixReconstruction( qfalse );//gG2_GBMNoReconstruct = qtrue;
 		re.G2API_BoltMatrixSPMethod( qtrue );//gG2_GBMUseSPMethod = qtrue;
-		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
+		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));*/
 
 	case UI_G2_INITGHOUL2MODEL:
 #ifdef _FULL_G2_LEAK_CHECKING
@@ -1199,9 +1113,9 @@ Ghoul2 Insert Start
 									  (qhandle_t) args[5], args[6], args[7]);
 
 
-	case UI_G2_COLLISIONDETECT:
+	/*case UI_G2_COLLISIONDETECT:
 	case UI_G2_COLLISIONDETECTCACHE:
-		return 0; //not supported for ui
+		return 0; //not supported for ui*/
 
 	case UI_G2_ANGLEOVERRIDE:
 		return re.G2API_SetBoneAngles(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3), (float *)VMA(4), args[5],
@@ -1213,14 +1127,13 @@ Ghoul2 Insert Start
 		g_G2AllocServer = 0;
 #endif
 		re.G2API_CleanGhoul2Models((CGhoul2Info_v **)VMA(1));
-	//	re.G2API_CleanGhoul2Models((CGhoul2Info_v **)args[1]);
 		return 0;
 
 	case UI_G2_PLAYANIM:
 		return re.G2API_SetBoneAnim(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3), args[4], args[5],
 								args[6], VMF(7), args[8], VMF(9), args[10]);
 
-	case UI_G2_GETBONEANIM:
+	/*case UI_G2_GETBONEANIM:
 		{
 			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
 			int modelIndex = args[10];
@@ -1238,21 +1151,11 @@ Ghoul2 Insert Start
 
 			return re.G2API_GetBoneAnim(&g2[modelIndex], (const char*)VMA(2), args[3], (float *)VMA(4), &iDontCare1,
 								&iDontCare2, &iDontCare3, &fDontCare1, (int *)VMA(5));
-		}
+		}*/
 
 	case UI_G2_GETGLANAME:
-		//	return (int)G2API_GetGLAName(*((CGhoul2Info_v *)VMA(1)), args[2]);
-		{
-			char *point = ((char *)VMA(3));
-			char *local;
-			local = re.G2API_GetGLAName(*((CGhoul2Info_v *)args[1]), args[2]);
-			if (local)
-			{
-				strcpy(point, local);
-			}
-		}
-		return 0;
-
+		return (int)re.G2API_GetGLAName(*((CGhoul2Info_v *)args[1]), args[2]);
+		
 	case UI_G2_COPYGHOUL2INSTANCE:
 		return (int)re.G2API_CopyGhoul2Instance(*((CGhoul2Info_v *)args[1]), *((CGhoul2Info_v *)args[2]), args[3]);
 
@@ -1267,76 +1170,38 @@ Ghoul2 Insert Start
 		re.G2API_DuplicateGhoul2Instance(*((CGhoul2Info_v *)args[1]), (CGhoul2Info_v **)VMA(2));
 		return 0;
 
-	case UI_G2_HASGHOUL2MODELONINDEX:
-		return (int)re.G2API_HasGhoul2ModelOnIndex((CGhoul2Info_v **)VMA(1), args[2]);
-		//return (int)G2API_HasGhoul2ModelOnIndex((CGhoul2Info_v **)args[1], args[2]);
-
 	case UI_G2_REMOVEGHOUL2MODEL:
 #ifdef _FULL_G2_LEAK_CHECKING
 		g_G2AllocServer = 0;
 #endif
 		return (int)re.G2API_RemoveGhoul2Model((CGhoul2Info_v **)VMA(1), args[2]);
-		//return (int)G2API_RemoveGhoul2Model((CGhoul2Info_v **)args[1], args[2]);
 
 	case UI_G2_ADDBOLT:
 		return re.G2API_AddBolt(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3));
 
-//	case UI_G2_REMOVEBOLT:
-//		return G2API_RemoveBolt(*((CGhoul2Info_v *)VMA(1)), args[2]);
+	case UI_G2_REMOVEBOLT:
+		{
+			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
+			int modelIndex = args[2];
+			return re.G2API_RemoveBolt(&g2[modelIndex], args[3]);
+		}
 
-	case UI_G2_SETBOLTON:
+	/*case UI_G2_SETBOLTON:
 		re.G2API_SetBoltInfo(*((CGhoul2Info_v *)args[1]), args[2], args[3]);
-		return 0;
+		return 0;*/
 
 #ifdef _SOF2	
 	case UI_G2_ADDSKINGORE:
 		re.G2API_AddSkinGore(*((CGhoul2Info_v *)args[1]),*(SSkinGoreData *)VMA(2));
 		return 0;
 #endif // _SOF2
-/*
-Ghoul2 Insert End
-*/
-	case UI_G2_SETROOTSURFACE:
-		return re.G2API_SetRootSurface(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3));
+	/*case UI_G2_SETROOTSURFACE:
+		return re.G2API_SetRootSurface(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3));*/
 
 	case UI_G2_SETSURFACEONOFF:
-		return re.G2API_SetSurfaceOnOff(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), /*(const int)VMA(3)*/args[3]);
-
-	case UI_G2_SETNEWORIGIN:
-		return re.G2API_SetNewOrigin(*((CGhoul2Info_v *)args[1]), /*(const int)VMA(2)*/args[2]);
-
-	case UI_G2_GETTIME:
-		return re.G2API_GetTime(0);
-
-	case UI_G2_SETTIME:
-		re.G2API_SetTime(args[1], args[2]);
-		return 0;
-
-	case UI_G2_SETRAGDOLL:
-		return 0; //not supported for ui
-		break;
-	case UI_G2_ANIMATEG2MODELS:
-		return 0; //not supported for ui
-		break;
-
-	case UI_G2_SETBONEIKSTATE:
-		return re.G2API_SetBoneIKState(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3), args[4], (sharedSetBoneIKStateParams_t *)VMA(5));
-	case UI_G2_IKMOVE:
-		return re.G2API_IKMove(*((CGhoul2Info_v *)args[1]), args[2], (sharedIKMoveParams_t *)VMA(3));
-
-	case UI_G2_GETSURFACENAME:
-		{ //Since returning a pointer in such a way to a VM seems to cause MASSIVE FAILURE<tm>, we will shove data into the pointer the vm passes instead
-			char *point = ((char *)VMA(4));
-			char *local;
-			int modelindex = args[3];
-
+		{
 			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
-
-			local = re.G2API_GetSurfaceName(&g2[modelindex], args[2]);
-			if (local)
-			{
-				strcpy(point, local);
-			}
+			return re.G2API_SetSurfaceOnOff(g2, args[2], (const char *)VMA(3), args[4]);
 		}
 
 		return 0;
@@ -1344,8 +1209,7 @@ Ghoul2 Insert End
 		{
 			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
 			int modelIndex = args[2];
-			
-			return re.G2API_SetSkin(&g2[modelIndex], args[3], args[4]);
+			return re.G2API_SetSkin(&g2[modelIndex], args[3], 0);
 		}
 
 	case UI_G2_ATTACHG2MODEL:
@@ -1355,11 +1219,121 @@ Ghoul2 Insert End
 			
 			return re.G2API_AttachG2Model(*g2From, args[2], *g2To, args[4], args[5]);
 		}
+	case UI_G2_GETANIMFILENAMEINDEX:
+		{
+			CGhoul2Info_v &ghoul2 = *((CGhoul2Info_v *)args[1]);
+			qhandle_t modelIndex = (qhandle_t) args[2];
+			char * srcFilename;
+			qboolean retval = re.G2API_GetAnimFileName(&ghoul2[modelIndex], &srcFilename);
+			strncpy((char *) VMA(3), srcFilename, MAX_QPATH);
+			return (int) retval;
+		}
+
+	case UI_G2_REGISTERSKIN:
+		return re.RegisterSkin((const char *)VMA(1), args[2], (char *)VMA(3) );
 /*
 Ghoul2 Insert End
 */
+
+	case UI_GP_PARSE:
+		return (int)GP_Parse((char **) VMA(1), (bool) args[2], (bool) args[3]);
+	case UI_GP_PARSE_FILE:
+		{
+			char * data;
+			FS_ReadFile((char *) VMA(1), (void **) &data);
+			return (int)GP_Parse(&data, (bool) args[2], (bool) args[3]);
+		}
+	case UI_GP_CLEAN:
+		GP_Clean((TGenericParser2) args[1]);
+		return 0;
+	case UI_GP_DELETE:
+		GP_Delete((TGenericParser2 *) VMA(1));
+		return 0;
+	case UI_GP_GET_BASE_PARSE_GROUP:
+		return (int)GP_GetBaseParseGroup((TGenericParser2) args[1]);
+
+	case UI_VM_LOCALALLOC:
+		return (int)VM_Local_Alloc(args[1]);
+	case UI_VM_LOCALALLOCUNALIGNED:
+		return (int)VM_Local_AllocUnaligned(args[1]);
+	case UI_VM_LOCALTEMPALLOC:
+		return (int)VM_Local_TempAlloc(args[1]);
+	case UI_VM_LOCALTEMPFREE:
+		VM_Local_TempFree(args[1]);
+		return 0;
+	case UI_VM_LOCALSTRINGALLOC:
+		return (int)VM_Local_StringAlloc((char *) VMA(1));
+
+	case UI_GET_CDKEY:
+		return 0;
+	case UI_SET_CDKEY:
+		return 0;
+	case UI_VERIFY_CDKEY:
+		return 1;
+
+	case UI_GPG_GET_NAME:
+		return (int)GPG_GetName((TGPGroup) args[1], (char *) VMA(2));
+	case UI_GPG_GET_NEXT:
+		return (int)GPG_GetNext((TGPGroup) args[1]);
+	case UI_GPG_GET_INORDER_NEXT:
+		return (int)GPG_GetInOrderNext((TGPGroup) args[1]);
+	case UI_GPG_GET_INORDER_PREVIOUS:
+		return (int)GPG_GetInOrderPrevious((TGPGroup) args[1]);
+	case UI_GPG_GET_PAIRS:
+		return (int)GPG_GetPairs((TGPGroup) args[1]);
+	case UI_GPG_GET_INORDER_PAIRS:
+		return (int)GPG_GetInOrderPairs((TGPGroup) args[1]);
+	case UI_GPG_GET_SUBGROUPS:
+		return (int)GPG_GetSubGroups((TGPGroup) args[1]);
+	case UI_GPG_GET_INORDER_SUBGROUPS:
+		return (int)GPG_GetInOrderSubGroups((TGPGroup) args[1]);
+	case UI_GPG_FIND_SUBGROUP:
+		return (int)GPG_FindSubGroup((TGPGroup) args[1], (char *) VMA(2));
+	case UI_GPG_FIND_PAIR:
+		return (int)GPG_FindPair((TGPGroup) args[1], (const char *) VMA(2));
+	case UI_GPG_FIND_PAIRVALUE:
+		return (int)GPG_FindPairValue((TGPGroup) args[1], (const char *) VMA(2), (const char *) VMA(3), (char *) VMA(4));
+		
+	case UI_GPV_GET_NAME:
+		return (int)GPV_GetName((TGPValue) args[1], (char *) VMA(2));
+	case UI_GPV_GET_NEXT:
+		return (int)GPV_GetNext((TGPValue) args[1]);
+	case UI_GPV_GET_INORDER_NEXT:
+		return (int)GPV_GetInOrderNext((TGPValue) args[1]);
+	case UI_GPV_GET_INORDER_PREVIOUS:
+		return (int)GPV_GetInOrderPrevious((TGPValue) args[1]);
+
+	case UI_GPV_IS_LIST:
+		return (int)GPV_IsList((TGPValue) args[1]);
+	case UI_GPV_GET_TOP_VALUE:
+		{
+			const char * topValue = GPV_GetTopValue((TGPValue) args[1]);
+			if (topValue)
+			{
+				strcpy((char *) VMA(2), topValue);
+			}
+			return 0;
+		}
+	case UI_GPV_GET_LIST:
+		return (int)GPV_GetList((TGPValue) args[1]);
+
+	case UI_PB_ISENABLED:
+	case UI_PB_ENABLE:
+	case UI_PB_DISABLE:
+		return qfalse;
+
+	case UI_GET_TEAM_COUNT:
+		//arg1 = int team
+		//TODO SOF2
+		return 1;
+	case UI_GET_TEAM_SCORE:
+		//arg1 = int team
+		//TODO SOF2
+		return 1;
+
 	default:
-		Com_Error( ERR_DROP, "Bad UI system trap: %i", args[0] );
+		Com_Printf("Bad UI system trap: %i", args[0] );
+		//Com_Error( ERR_DROP, "Bad UI system trap: %i", args[0] );
 
 	}
 
@@ -1378,7 +1352,7 @@ void CL_ShutdownUI( void ) {
 		return;
 	}
 	VM_Call( uivm, UI_SHUTDOWN );
-	VM_Call( uivm, UI_MENU_RESET );
+	//VM_Call( uivm, UI_MENU_RESET );
 	VM_Free( uivm );
 	uivm = NULL;
 }
@@ -1405,7 +1379,7 @@ void CL_InitUI( void ) {
 	else {
 		interpret = (vmInterpret_t)(int)Cvar_VariableValue( "vm_ui" );
 	}
-	uivm = VM_Create( "ui", CL_UISystemCalls, interpret );
+	uivm = VM_Create( "sof2mp_ui", CL_UISystemCalls, interpret );
 	if ( !uivm ) {
 		Com_Error( ERR_FATAL, "VM_Create on UI failed" );
 	}
diff --git a/codemp/client/client.h b/codemp/client/client.h
index 0791104..752e8e6 100644
--- a/codemp/client/client.h
+++ b/codemp/client/client.h
@@ -31,7 +31,6 @@ typedef struct {
 
 	int				cmdNum;			// the next cmdNum the server is expecting
 	playerState_t	ps;						// complete information about the current player at this time
-	playerState_t	vps; //vehicle I'm riding's playerstate (if applicable) -rww
 
 	int				numEntities;			// all of the entities that need to be presented
 	int				parseEntitiesNum;		// at the time of this snapshot
@@ -94,9 +93,6 @@ typedef struct {
 	int			cgameViewAngleForceTime;
 	float		cgameSensitivity;
 
-	int			cgameForceSelection;
-	int			cgameInvenSelection;
-
 	qboolean	gcmdSendValue;
 	qboolean	gcmdSentValue;
 	byte		gcmdValue;
@@ -247,18 +243,15 @@ typedef struct {
 	char	  	mapName[MAX_NAME_LENGTH];
 	char	  	game[MAX_NAME_LENGTH];
 	int			netType;
-	int			gameType;
+	char		gameType[MAX_NAME_LENGTH];
 	int		  	clients;
 	int		  	maxClients;
 	int			minPing;
 	int			maxPing;
 	int			ping;
 	qboolean	visible;
-//	int			allowAnonymous;
+	int			allowAnonymous;
 	qboolean	needPassword;
-	int			trueJedi;
-	int			weaponDisable;
-	int			forceDisable;
 //	qboolean	pure;
 } serverInfo_t;
 
@@ -298,9 +291,6 @@ typedef struct {
 	int			numfavoriteservers;
 	serverInfo_t	favoriteServers[MAX_OTHER_SERVERS];
 
-	int			nummplayerservers;
-	serverInfo_t	mplayerServers[MAX_OTHER_SERVERS];
-
 	int pingUpdateSource;		// source currently pinging or updating
 
 	int masterNum;
@@ -380,7 +370,6 @@ extern	cvar_t	*cl_freelook;
 extern	cvar_t	*cl_mouseAccel;
 extern	cvar_t	*cl_showMouseRate;
 
-extern	cvar_t	*m_pitchVeh;
 extern	cvar_t	*m_pitch;
 extern	cvar_t	*m_yaw;
 extern	cvar_t	*m_forward;
@@ -513,8 +502,6 @@ void	SCR_UpdateScreen (void);
 
 void	SCR_DebugGraph (float value, int color);
 
-int		SCR_GetBigStringWidth( const char *str );	// returns in virtual 640x480 coordinates
-
 void	SCR_FillRect( float x, float y, float width, float height, 
 					 const float *color );
 void	SCR_DrawPic( float x, float y, float width, float height, qhandle_t hShader );
diff --git a/codemp/client/keys.h b/codemp/client/keys.h
index f7c433b..c55151a 100644
--- a/codemp/client/keys.h
+++ b/codemp/client/keys.h
@@ -29,21 +29,18 @@ typedef struct keyGlobals_s
 	qboolean	key_overstrikeMode;
 	int			keyDownCount;
 
-	qkey_t		keys[MAX_KEYS];
+	qkey_t		keys[K_LAST_KEY];
 } keyGlobals_t;
 
 
 typedef struct 
 {
-	word	upper;
-	word	lower;
 	char	*name;
 	int		keynum;
-	bool	menukey;
 } keyname_t;
 
 extern keyGlobals_t	kg;
-extern keyname_t	keynames[MAX_KEYS];
+extern keyname_t	keynames[K_LAST_KEY];
 
 
 void Field_Clear( field_t *edit );
diff --git a/codemp/client/materials.cpp b/codemp/client/materials.cpp
new file mode 100644
index 0000000..812d81d
--- /dev/null
+++ b/codemp/client/materials.cpp
@@ -0,0 +1,208 @@
+#include "materials.h"
+
+#include "client/snd_public.h"
+#include "renderer/tr_types.h"
+#include "client/FXExport.h"
+
+#include "qcommon/qcommon.h"
+#include "qcommon/GenericParser2.h"
+
+#include <list>
+#include <string>
+#include <utility>
+#include <vector>
+
+using std::list;
+using std::pair;
+using std::string;
+using std::vector;
+
+//-----------------------------------------------------------------
+//
+// Sounds, copy of CMediaHandles
+//
+// Primitive templates might want to use a list of sounds, shaders 
+//	or models to get a bit more variation in their effects.
+//
+//-----------------------------------------------------------------
+class Sounds {
+	vector<int> _mediaList;
+public:
+	void addHandle(int item) {
+		_mediaList.push_back(item);
+	}
+
+	int	getHandle() const {
+		if (_mediaList.empty()) {
+			return 0;
+		}
+		return _mediaList[irand(0, _mediaList.size() - 1)];
+	}
+
+	void operator=(const Sounds &that ) {
+		_mediaList.clear();
+		std::copy(that._mediaList.begin(), that._mediaList.end(), _mediaList.begin());
+	}
+};
+
+/// Material class keeping info about a specific material and it's sounds and effects
+class Material {
+	typedef pair<string, Sounds> SoundPair;
+	typedef pair<string, qhandle_t> EffectPair;
+
+	list<SoundPair> _sounds;
+	list<EffectPair> _effects;
+
+	Material(const Material&); // don't allow copying
+public:
+	Material(CGPGroup * const group);
+
+	sfxHandle_t getSound(const char * key) const;
+	qhandle_t getEffect(const char * key) const;
+};
+
+/// Create a material from the given group read from a file.
+Material::Material(CGPGroup * const materialGroup) {
+	// groups are footstep, land, bouncemetal0, ..., ammoTypes
+	for (CGPGroup * group = materialGroup->GetSubGroups(); group != NULL; group = group->GetNext()) {
+		const char * keyName = group->GetName();
+
+		CGPValue * value = group->FindPair("sound");
+		if (value) { // add the sound(s)
+			Sounds sounds;
+
+			const char * const path = value->GetTopValue();
+			sfxHandle_t sound = S_RegisterSound(path);
+			if (sound) {
+				// Found our base sound.
+				sounds.addHandle(sound);
+				this->_sounds.push_back(SoundPair(keyName, sounds));
+				continue;
+			}
+
+			// Try to find some variations, add 0 and 1 to the end.
+			for (char soundNr = 48; soundNr < 50; ++soundNr) {
+				char localPath[MAX_QPATH];
+				sprintf(localPath, "%s%c\0", path, soundNr);
+				sfxHandle_t sound = S_RegisterSound(localPath);
+				if (sound) {
+					sounds.addHandle(sound);
+				}
+			}
+
+			this->_sounds.push_back(SoundPair(keyName, sounds));
+		} else if (!strcmp(keyName, "ammoTypes")) {
+			// parse the ammo types
+			for (CGPGroup * ammoType = group->GetSubGroups(); ammoType != NULL; ammoType = ammoType->GetNext()) {
+				CGPValue * value = ammoType->FindPair("effect");
+				if (value) { // add the ffect
+					qhandle_t effect = FX_RegisterEffect(value->GetTopValue());
+					this->_effects.push_back(EffectPair(ammoType->GetName(), effect));
+				}
+			}
+		}
+	}
+}
+
+/// Get the sound for the given key.
+sfxHandle_t Material::getSound(const char * key) const {
+	for (list<SoundPair>::const_iterator it = this->_sounds.begin(); it != this->_sounds.end(); ++it) {
+		if (!stricmp(key, it->first.c_str())) {
+			return it->second.getHandle();
+		}
+	}
+	return 0;
+}
+
+/// Get the effect for the given key.
+qhandle_t Material::getEffect(const char * key) const {
+	for (list<EffectPair>::const_iterator it = this->_effects.begin(); it != this->_effects.end(); ++it) {
+		if (!stricmp(key, it->first.c_str())) {
+			return it->second;
+		}
+	}
+	return 0;
+}
+
+const char * materialNames[MATERIAL_LAST] = { MATERIALS };
+Material * materials[MATERIAL_LAST] = { NULL };
+Material * materialDefault = NULL;
+
+/// Parse and initialize our materials.
+void Mat_Init(void) {
+	char * buffer;
+	FS_ReadFile("ext_data/generic.material", (void **) &buffer);
+
+	CGenericParser2 parser;
+	if (parser.Parse(buffer)) {
+		CGPGroup * baseGroup = parser.GetBaseParseGroup();
+		for (int i = 0; i < MATERIAL_LAST; ++i) {
+			CGPGroup * materialGroup = baseGroup->FindSubGroup(materialNames[i]);
+
+			if (materials[i]) {
+				delete materials[i];
+			}
+			materials[i] = new Material(materialGroup);
+		}
+
+		if (materialDefault) {
+			delete materialDefault;
+		}
+		materialDefault = new Material(baseGroup->FindSubGroup("default"));
+	}
+
+	parser.Clean();
+
+	FS_FreeFile((void *) buffer);
+}
+
+/// Clear all materials.
+void Mat_Reset(void) {
+	// Do nothing as Mat_Reset is called after Mat_Init so we can't use it to clean up our materials.
+}
+
+/// Get the sound for the given key and material.
+sfxHandle_t Mat_GetSound(char * key, int material) {
+	Material * const mat = materials[material];
+	if (mat) {
+		sfxHandle_t sound = mat->getSound(key);
+		if (!sound) {
+			return materialDefault->getSound(key);
+		}
+		return sound;
+	}
+	return 0;
+}
+
+/// Not used
+qhandle_t Mat_GetDecal(char * key, int material) {
+	return 0;
+}
+
+/// Not used
+const float Mat_GetDecalScale(char * key, int material) {
+	return 0;
+}
+
+/// Get the effect for the given key and material.
+qhandle_t Mat_GetEffect(char * key, int material) {
+	Material * const mat = materials[material];
+	if (mat) {
+		qhandle_t effect = mat->getEffect(key);
+		if (!effect) {
+			return materialDefault->getEffect(key);
+		}
+		return effect;
+	}
+	return 0;
+}
+
+/// Not used
+qhandle_t Mat_GetDebris(char * key, int material) {
+	return 0;
+}
+
+/// Not used
+const float Mat_GetDebrisScale(char * key, int material) {
+	return 0;
+}
\ No newline at end of file
diff --git a/codemp/client/materials.h b/codemp/client/materials.h
new file mode 100644
index 0000000..7a229ac
--- /dev/null
+++ b/codemp/client/materials.h
@@ -0,0 +1,10 @@
+#include "qcommon\q_shared.h"
+
+void Mat_Init(void);
+void Mat_Reset(void);
+sfxHandle_t Mat_GetSound(char *key, int material);
+qhandle_t Mat_GetDecal(char *key, int material);
+const float Mat_GetDecalScale(char *key, int material);
+qhandle_t Mat_GetEffect(char *key, int material);
+qhandle_t Mat_GetDebris(char *key, int material);
+const float Mat_GetDebrisScale(char *key, int material);
\ No newline at end of file
diff --git a/codemp/client/snd_dma.cpp b/codemp/client/snd_dma.cpp
index d9373d6..db76ea4 100644
--- a/codemp/client/snd_dma.cpp
+++ b/codemp/client/snd_dma.cpp
@@ -125,7 +125,6 @@ static char			sInfoOnly_CurrentDynamicMusicSet[64];	// any old reasonable size,
 #define		SOUND_FULLVOLUME	256
 
 #define		SOUND_ATTENUATE		0.0008f
-#define		VOICE_ATTENUATE		0.004f
 
 const float	SOUND_FMAXVOL=0.75;//1.0;
 const int	SOUND_MAXVOL=255;
@@ -1084,7 +1083,7 @@ static sboolean S_CheckChannelStomp( int chan1, int chan2 )
 		}
 	}
 
-	if ( ( chan1 == CHAN_VOICE || chan1 == CHAN_VOICE_ATTEN || chan1 == CHAN_VOICE_GLOBAL  ) && ( chan2 == CHAN_VOICE || chan2 == CHAN_VOICE_ATTEN || chan2 == CHAN_VOICE_GLOBAL ) )
+	if ( ( chan1 == CHAN_VOICE/* || chan1 == CHAN_VOICE_ATTEN || chan1 == CHAN_VOICE_GLOBAL */ ) && ( chan2 == CHAN_VOICE/* || chan2 == CHAN_VOICE_ATTEN || chan2 == CHAN_VOICE_GLOBAL*/ ) )
 	{
 		return qtrue;
 	}
@@ -1123,11 +1122,11 @@ channel_t *S_PickChannel(int entnum, int entchannel)
 
     firstToDie = &s_channels[0];
 
-	for ( int pass = 0; (pass < ((entchannel == CHAN_AUTO || entchannel == CHAN_LESS_ATTEN)?1:2)) && !foundChan; pass++ )
+	for ( int pass = 0; (pass < ((entchannel == CHAN_AUTO/* || entchannel == CHAN_LESS_ATTEN*/)?1:2)) && !foundChan; pass++ )
 	{
 		for (ch_idx = 0, ch = &s_channels[0]; ch_idx < MAX_CHANNELS ; ch_idx++, ch++ ) 
 		{
-			if ( entchannel == CHAN_AUTO || entchannel == CHAN_LESS_ATTEN || pass > 0 )
+			if ( entchannel == CHAN_AUTO/* || entchannel == CHAN_LESS_ATTEN*/ || pass > 0 )
 			{//if we're on the second pass, just find the first open chan
 				if ( !ch->thesfx )
 				{//grab the first open channel
@@ -1383,7 +1382,7 @@ void S_SpatializeOrigin (const vec3_t origin, float master_vol, int *left_vol, i
 		dist -= SOUND_FULLVOLUME * 3.0f;
 //		dist_mult = VOICE_ATTENUATE;	// tweak added (this fixes an NPC dialogue "in your ears" bug, but we're not sure if it'll make a bunch of others fade too early. Too close to shipping...)
 	}
-	else if ( channel == CHAN_LESS_ATTEN )
+	/*else if ( channel == CHAN_LESS_ATTEN )
 	{
 		dist -= SOUND_FULLVOLUME * 8.0f; // maybe is too large
 	}
@@ -1395,7 +1394,7 @@ void S_SpatializeOrigin (const vec3_t origin, float master_vol, int *left_vol, i
 	else if ( channel == CHAN_VOICE_GLOBAL )
 	{
 		dist = -1;
-	}
+	}*/
 	else	// use normal attenuation.
 	{
 		dist -= SOUND_FULLVOLUME;
@@ -1562,8 +1561,10 @@ if pos is NULL, the sound will be dynamically sourced from the entity
 Entchannel 0 will never override a playing sound
 ====================
 */
-void S_StartSound(const vec3_t origin, int entityNum, int entchannel, sfxHandle_t sfxHandle ) 
+void S_StartSound(const vec3_t origin, int entityNum, int entchannel, sfxHandle_t sfxHandle, int volume=-1, int radius=-1 ) 
 {
+	//SOF2 TODO
+	//implement radius
 	int i;
 	channel_t	*ch;
 	/*const*/ sfx_t *sfx;
@@ -1643,7 +1644,7 @@ void S_StartSound(const vec3_t origin, int entityNum, int entchannel, sfxHandle_
 		ch->fixed_origin = qfalse;
 	}
 
-	ch->master_vol = SOUND_MAXVOL;	//FIXME: Um.. control?
+	ch->master_vol = (volume == -1 ? SOUND_MAXVOL : volume);
 	ch->entnum = entityNum;
 	ch->entchannel = entchannel;
 	ch->thesfx = sfx;
@@ -1655,7 +1656,7 @@ void S_StartSound(const vec3_t origin, int entityNum, int entchannel, sfxHandle_
 	if (entchannel < CHAN_AMBIENT && entityNum == listener_number) {	//only do it for body sounds not local sounds
 		ch->master_vol = SOUND_MAXVOL * SOUND_FMAXVOL;	//this won't be attenuated so let it scale down
 	}
-	if ( entchannel == CHAN_VOICE || entchannel == CHAN_VOICE_ATTEN || entchannel == CHAN_VOICE_GLOBAL ) 
+	if ( entchannel == CHAN_VOICE/* || entchannel == CHAN_VOICE_ATTEN || entchannel == CHAN_VOICE_GLOBAL*/ ) 
 	{
 		s_entityWavVol[ ch->entnum ] = -1;	//we've started the sound but it's silent for now
 	}
@@ -1706,7 +1707,7 @@ void S_StartLocalLoopingSound( sfxHandle_t sfxHandle) {
 		Com_Error( ERR_DROP, "S_StartLocalLoopingSound: handle %i out of range", sfxHandle );
 	}
 
-	S_AddLoopingSound( listener_number, nullVec, nullVec, sfxHandle );
+	S_AddLoopingSound( listener_number, nullVec, nullVec, 0, sfxHandle );
 
 }
 
@@ -1826,7 +1827,7 @@ void S_StopSounds(void)
 	}
 
 	// stop looping sounds
-	S_ClearLoopingSounds();
+	S_ClearLoopingSounds(qtrue);
 
 #ifdef _WIN32
 	// clear all the s_channels
@@ -1889,14 +1890,17 @@ S_ClearLoopingSounds
 
 ==================
 */
-void S_ClearLoopingSounds( void )
+void S_ClearLoopingSounds( qboolean killall )
 {
 	int i;
 
 	if (s_UseOpenAL)
 	{
-		for (i = 0; i < MAX_LOOP_SOUNDS; i++)
-			loopSounds[i].bProcessed = false;
+		for (i = 0; i < MAX_LOOP_SOUNDS; i++) {
+			if (killall || loopSounds[i].bProcessed == true || (loopSounds[i].sfx && loopSounds[i].sfx->iSoundLengthInSamples == 0)) {
+				loopSounds[i].bProcessed = false;
+			}
+		}
 	}
 	numLoopSounds = 0;
 
@@ -1938,7 +1942,9 @@ Called during entity generation for a frame
 Include velocity in case I get around to doing doppler...
 ==================
 */
-void S_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfxHandle ) {
+void S_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, float radius, sfxHandle_t sfxHandle ) {
+	//SOF2 TODO
+	//implement radius
 	/*const*/ sfx_t *sfx;
 
   	if ( !s_soundStarted || s_soundMuted ) {
@@ -2332,7 +2338,7 @@ void S_UpdateEntityPosition( int entityNum, const vec3_t origin )
 			if ((s_channels[i].bPlaying) & (s_channels[i].entnum == entityNum) & (!s_channels[i].bLooping))
 			{
 				// Ignore position updates for CHAN_VOICE_GLOBAL
-				if (ch->entchannel != CHAN_VOICE_GLOBAL && ch->entchannel != CHAN_ANNOUNCER)
+				if (/*ch->entchannel != CHAN_VOICE_GLOBAL && */ch->entchannel != CHAN_ANNOUNCER)
 				{
 					pos[0] = origin[0];
 					pos[1] = origin[2];
@@ -2631,7 +2637,7 @@ void S_Respatialize( int entityNum, const vec3_t head, vec3_t axis[3], int inwat
 
 			//NOTE: Made it so that voice sounds keep playing, even out of range
 			//		so that tasks waiting for sound completion keep proper timing
-			if ( !( ch->entchannel == CHAN_VOICE || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL ) && !ch->leftvol && !ch->rightvol ) {
+			if ( !( ch->entchannel == CHAN_VOICE/* || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL*/ ) && !ch->leftvol && !ch->rightvol ) {
 				Channel_Clear(ch);	// memset (ch, 0, sizeof(*ch));
 				continue;
 			}
@@ -2712,7 +2718,7 @@ void S_DoLipSynchs( const unsigned s_oldpaintedtime )
 
 		// if we are playing a sample that should override the lip texture on its owning model, lets figure out
 		// what the amplitude is, stick it in a table, then return it 
-		if ( ch->entchannel == CHAN_VOICE || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL )
+		if ( ch->entchannel == CHAN_VOICE/* || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL*/ )
 		{
 			// go away and work out amplitude for this sound we are playing right now.
 			s_entityWavVol[ ch->entnum ] = S_CheckAmplitude( ch, s_oldpaintedtime );
@@ -2855,7 +2861,7 @@ void S_Update_(void) {
 
 			source = ch - s_channels;
 
-			if (ch->entchannel == CHAN_VOICE_GLOBAL || ch->entchannel == CHAN_ANNOUNCER)
+			if (/*ch->entchannel == CHAN_VOICE_GLOBAL || */ch->entchannel == CHAN_ANNOUNCER)
 			{
 				// Always play these sounds at 0,0,-1 (in front of listener)
 				pos[0] = 0.0f;
@@ -2921,7 +2927,7 @@ void S_Update_(void) {
 					alSourcef(s_channels[source].alSource, AL_REFERENCE_DISTANCE, DEFAULT_VOICE_REF_DISTANCE);
 					alSourcef(s_channels[source].alSource, AL_GAIN, ((float)(ch->master_vol) * s_volumeVoice->value) / 255.0f);
 				}
-				else if (ch->entchannel == CHAN_VOICE_ATTEN)
+				/*else if (ch->entchannel == CHAN_VOICE_ATTEN)
 				{
 					// Normal fall-off, affected by Voice Volume
 					alSourcef(s_channels[source].alSource, AL_REFERENCE_DISTANCE, DEFAULT_REF_DISTANCE);
@@ -2932,7 +2938,7 @@ void S_Update_(void) {
 					// Reduced fall-off, affected by Sound Effect Volume
 					alSourcef(s_channels[source].alSource, AL_REFERENCE_DISTANCE, DEFAULT_VOICE_REF_DISTANCE);
 					alSourcef(s_channels[source].alSource, AL_GAIN, ((float)(ch->master_vol) * s_volume->value) / 255.f);
-				}
+				}*/
 				else
 				{
 					// Normal fall-off, affect by Sound Effect Volume
@@ -2967,7 +2973,7 @@ void S_Update_(void) {
 					{
 						nBytesDecoded = C_MP3Stream_Decode(&ch->MP3StreamHeader, 0);	// added ,0 ?
 						memcpy(ch->buffers[i].Data + nTotalBytesDecoded, ch->MP3StreamHeader.bDecodeBuffer, nBytesDecoded);
-						if (ch->entchannel == CHAN_VOICE || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL )
+						if (ch->entchannel == CHAN_VOICE/* || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL */)
 						{
 							if (ch->thesfx->lipSyncData)
 							{
@@ -3020,7 +3026,7 @@ void S_Update_(void) {
 
 				ch->bStreaming = true;
 
-				if ( ch->entchannel == CHAN_VOICE || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL )
+				if ( ch->entchannel == CHAN_VOICE/* || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL*/ )
 				{
 					if (ch->thesfx->lipSyncData)
 					{
@@ -3054,7 +3060,7 @@ void S_Update_(void) {
 				if (alGetError() == AL_NO_ERROR)
 					s_channels[source].bPlaying = true;
 
-				if ( ch->entchannel == CHAN_VOICE || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL )
+				if ( ch->entchannel == CHAN_VOICE/* || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL*/ )
 				{
 					if (ch->thesfx->lipSyncData)
 					{
@@ -3216,7 +3222,7 @@ void UpdateSingleShotSounds()
 								{
 									memcpy(ch->buffers[j].Data + nTotalBytesDecoded, ch->MP3StreamHeader.bDecodeBuffer, nBytesDecoded);
 
-									if (ch->entchannel == CHAN_VOICE || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL )
+									if (ch->entchannel == CHAN_VOICE/* || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL*/ )
 									{
 										if (ch->thesfx->lipSyncData)
 										{
@@ -3655,7 +3661,7 @@ void S_SetLipSyncs()
 		if ((!ch->thesfx)||(!ch->bPlaying))
 			continue;
 		
-		if ( ch->entchannel == CHAN_VOICE || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL )
+		if ( ch->entchannel == CHAN_VOICE/* || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL*/ )
 		{
 			// Calculate how much time has passed since the sample was started
 			timePlayed = currentTime - ch->iStartTime;
@@ -6353,7 +6359,7 @@ void UpdateEAXBuffer(channel_t *ch)
 			OutputDebugString("UpdateEAXBuffer : Failed to set exclusion to -1000\n");
 	}
 
-	if ((ch->entchannel == CHAN_VOICE) || (ch->entchannel == CHAN_VOICE_ATTEN) || (ch->entchannel == CHAN_VOICE_GLOBAL))
+	if ((ch->entchannel == CHAN_VOICE)/* || (ch->entchannel == CHAN_VOICE_ATTEN) || (ch->entchannel == CHAN_VOICE_GLOBAL)*/)
 	{
 		// Remove any Occlusion + Obstruction
 		eaxOBProp.lObstruction = EAXSOURCE_DEFAULTOBSTRUCTION;
diff --git a/codemp/client/snd_mix.cpp b/codemp/client/snd_mix.cpp
index 47d31ae..ac24bf3 100644
--- a/codemp/client/snd_mix.cpp
+++ b/codemp/client/snd_mix.cpp
@@ -427,7 +427,7 @@ void S_PaintChannels( int endtime ) {
 				continue;
 			}
 
-			if ( ch->entchannel == CHAN_VOICE || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL )
+			if ( ch->entchannel == CHAN_VOICE/* || ch->entchannel == CHAN_VOICE_ATTEN || ch->entchannel == CHAN_VOICE_GLOBAL */)
 				snd_vol = voice_vol;
 			else
 				snd_vol = normal_vol;
diff --git a/codemp/client/snd_public.h b/codemp/client/snd_public.h
index c49231c..e929d6f 100644
--- a/codemp/client/snd_public.h
+++ b/codemp/client/snd_public.h
@@ -8,7 +8,7 @@ void S_Shutdown( void );
 void S_AddAmbientLoopingSound( const vec3_t origin, unsigned char volume, sfxHandle_t sfxHandle );
 void S_StartAmbientSound( const vec3_t origin, int entityNum, unsigned char volume, sfxHandle_t sfxHandle );
 void S_MuteSound(int entityNum, int entchannel);
-void S_StartSound( const vec3_t origin, int entnum, int entchannel, sfxHandle_t sfx );
+void S_StartSound( const vec3_t origin, int entnum, int entchannel, sfxHandle_t sfx, int volume, int radius );
 void S_StartLocalSound( sfxHandle_t sfx, int channelNum );
 void S_StartLocalLoopingSound( sfxHandle_t sfx);
 
@@ -30,9 +30,9 @@ void S_StopAllSounds( void );
 void S_MP3_CalcVols_f( void );
 
 // all continuous looping sounds must be added before calling S_Update
-void S_ClearLoopingSounds( void );
+void S_ClearLoopingSounds( qboolean killall );
 void S_StopLoopingSound( int entityNum );
-void S_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfx );
+void S_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, float radius, sfxHandle_t sfx );
 
 // recompute the reletive volumes for all running sounds
 // relative to the given entityNum / orientation
diff --git a/codemp/dedicated.vcxproj b/codemp/dedicated.vcxproj
index 98531b1..f8832c8 100644
--- a/codemp/dedicated.vcxproj
+++ b/codemp/dedicated.vcxproj
@@ -12,18 +12,21 @@
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectName>dedicated</ProjectName>
+    <ProjectGuid>{D1AF49E8-2E0B-4CF8-858B-40D72A6C041B}</ProjectGuid>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>NotSet</CharacterSet>
+    <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>
     </CharacterSet>
+    <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
@@ -295,7 +298,6 @@
     <ClCompile Include="server\sv_snapshot.cpp" />
     <ClCompile Include="server\sv_world.cpp" />
     <ClCompile Include="server\NPCNav\gameCallbacks.cpp" />
-    <ClCompile Include="server\NPCNav\navigator.cpp" />
     <ClCompile Include="null\null_client.cpp" />
     <ClCompile Include="null\null_input.cpp" />
     <ClCompile Include="null\null_renderer.cpp" />
@@ -336,7 +338,6 @@
     <ClCompile Include="icarus\instance.cpp" />
     <ClCompile Include="icarus\interface.cpp" />
     <ClCompile Include="icarus\memory.cpp" />
-    <ClCompile Include="icarus\q3_interface.cpp" />
     <ClCompile Include="icarus\q3_registers.cpp" />
     <ClCompile Include="icarus\sequence.cpp" />
     <ClCompile Include="icarus\sequencer.cpp" />
diff --git a/codemp/game/anims.h b/codemp/game/anims.h
index 8ad06f5..b8a0335 100644
--- a/codemp/game/anims.h
+++ b/codemp/game/anims.h
@@ -5,1793 +5,128 @@
 
 typedef enum //# animNumber_e
 {
-	//=================================================
-	//HEAD ANIMS
-	//=================================================
-	//# #sep Head-only anims
-	FACE_TALK0,			//# silent
-	FACE_TALK1,			//# quiet
-	FACE_TALK2,			//# semi-quiet
-	FACE_TALK3,			//# semi-loud
-	FACE_TALK4,			//# loud
-	FACE_ALERT,				//# 
-	FACE_SMILE,				//# 
-	FACE_FROWN,				//# 
-	FACE_DEAD,				//# 
-
-	//=================================================
-	//ANIMS IN WHICH UPPER AND LOWER OBJECTS ARE IN MD3
-	//=================================================
-	//# #sep BOTH_ DEATHS
-	BOTH_DEATH1,		//# First Death anim
-	BOTH_DEATH2,			//# Second Death anim
-	BOTH_DEATH3,			//# Third Death anim
-	BOTH_DEATH4,			//# Fourth Death anim
-	BOTH_DEATH5,			//# Fifth Death anim
-	BOTH_DEATH6,			//# Sixth Death anim
-	BOTH_DEATH7,			//# Seventh Death anim
-	BOTH_DEATH8,			//# 
-	BOTH_DEATH9,			//# 
-	BOTH_DEATH10,			//# 
-	BOTH_DEATH11,			//#
-	BOTH_DEATH12,			//# 
-	BOTH_DEATH13,			//# 
-	BOTH_DEATH14,			//# 
-	BOTH_DEATH15,			//# 
-	BOTH_DEATH16,			//# 
-	BOTH_DEATH17,			//# 
-	BOTH_DEATH18,			//# 
-	BOTH_DEATH19,			//# 
-	BOTH_DEATH20,			//# 
-	BOTH_DEATH21,			//# 
-	BOTH_DEATH22,			//# 
-	BOTH_DEATH23,			//# 
-	BOTH_DEATH24,			//# 
-	BOTH_DEATH25,			//# 
-
-	BOTH_DEATHFORWARD1,		//# First Death in which they get thrown forward
-	BOTH_DEATHFORWARD2,		//# Second Death in which they get thrown forward
-	BOTH_DEATHFORWARD3,		//# Tavion's falling in cin# 23
-	BOTH_DEATHBACKWARD1,	//# First Death in which they get thrown backward
-	BOTH_DEATHBACKWARD2,	//# Second Death in which they get thrown backward
-
-	BOTH_DEATH1IDLE,		//# Idle while close to death
-	BOTH_LYINGDEATH1,		//# Death to play when killed lying down
-	BOTH_STUMBLEDEATH1,		//# Stumble forward and fall face first death
-	BOTH_FALLDEATH1,		//# Fall forward off a high cliff and splat death - start
-	BOTH_FALLDEATH1INAIR,	//# Fall forward off a high cliff and splat death - loop
-	BOTH_FALLDEATH1LAND,	//# Fall forward off a high cliff and splat death - hit bottom
-	BOTH_DEATH_ROLL,		//# Death anim from a roll
-	BOTH_DEATH_FLIP,		//# Death anim from a flip
-	BOTH_DEATH_SPIN_90_R,	//# Death anim when facing 90 degrees right
-	BOTH_DEATH_SPIN_90_L,	//# Death anim when facing 90 degrees left
-	BOTH_DEATH_SPIN_180,	//# Death anim when facing backwards
-	BOTH_DEATH_LYING_UP,	//# Death anim when lying on back
-	BOTH_DEATH_LYING_DN,	//# Death anim when lying on front
-	BOTH_DEATH_FALLING_DN,	//# Death anim when falling on face
-	BOTH_DEATH_FALLING_UP,	//# Death anim when falling on back
-	BOTH_DEATH_CROUCHED,	//# Death anim when crouched
-	//# #sep BOTH_ DEAD POSES # Should be last frame of corresponding previous anims
-	BOTH_DEAD1,				//# First Death finished pose
-	BOTH_DEAD2,				//# Second Death finished pose
-	BOTH_DEAD3,				//# Third Death finished pose
-	BOTH_DEAD4,				//# Fourth Death finished pose
-	BOTH_DEAD5,				//# Fifth Death finished pose
-	BOTH_DEAD6,				//# Sixth Death finished pose
-	BOTH_DEAD7,				//# Seventh Death finished pose
-	BOTH_DEAD8,				//# 
-	BOTH_DEAD9,				//# 
-	BOTH_DEAD10,			//# 
-	BOTH_DEAD11,			//#
-	BOTH_DEAD12,			//# 
-	BOTH_DEAD13,			//# 
-	BOTH_DEAD14,			//# 
-	BOTH_DEAD15,			//# 
-	BOTH_DEAD16,			//# 
-	BOTH_DEAD17,			//# 
-	BOTH_DEAD18,			//# 
-	BOTH_DEAD19,			//# 
-	BOTH_DEAD20,			//# 
-	BOTH_DEAD21,			//# 
-	BOTH_DEAD22,			//# 
-	BOTH_DEAD23,			//# 
-	BOTH_DEAD24,			//# 
-	BOTH_DEAD25,			//# 
-	BOTH_DEADFORWARD1,		//# First thrown forward death finished pose
-	BOTH_DEADFORWARD2,		//# Second thrown forward death finished pose
-	BOTH_DEADBACKWARD1,		//# First thrown backward death finished pose
-	BOTH_DEADBACKWARD2,		//# Second thrown backward death finished pose
-	BOTH_LYINGDEAD1,		//# Killed lying down death finished pose
-	BOTH_STUMBLEDEAD1,		//# Stumble forward death finished pose
-	BOTH_FALLDEAD1LAND,		//# Fall forward and splat death finished pose
-	//# #sep BOTH_ DEAD TWITCH/FLOP # React to being shot from death poses
-	BOTH_DEADFLOP1,		//# React to being shot from First Death finished pose
-	BOTH_DEADFLOP2,		//# React to being shot from Second Death finished pose
-	BOTH_DISMEMBER_HEAD1,	//#
-	BOTH_DISMEMBER_TORSO1,	//#
-	BOTH_DISMEMBER_LLEG,	//#
-	BOTH_DISMEMBER_RLEG,	//#
-	BOTH_DISMEMBER_RARM,	//#
-	BOTH_DISMEMBER_LARM,	//#
-	//# #sep BOTH_ PAINS
-	BOTH_PAIN1,				//# First take pain anim
-	BOTH_PAIN2,				//# Second take pain anim
-	BOTH_PAIN3,				//# Third take pain anim
-	BOTH_PAIN4,				//# Fourth take pain anim
-	BOTH_PAIN5,				//# Fifth take pain anim - from behind
-	BOTH_PAIN6,				//# Sixth take pain anim - from behind
-	BOTH_PAIN7,				//# Seventh take pain anim - from behind
-	BOTH_PAIN8,				//# Eigth take pain anim - from behind
-	BOTH_PAIN9,				//# 
-	BOTH_PAIN10,			//# 
-	BOTH_PAIN11,			//# 
-	BOTH_PAIN12,			//# 
-	BOTH_PAIN13,			//# 
-	BOTH_PAIN14,			//# 
-	BOTH_PAIN15,			//# 
-	BOTH_PAIN16,			//# 
-	BOTH_PAIN17,			//# 
-	BOTH_PAIN18,			//# 
-
-	//# #sep BOTH_ ATTACKS
-	BOTH_ATTACK1,			//# Attack with stun baton
-	BOTH_ATTACK2,			//# Attack with one-handed pistol
-	BOTH_ATTACK3,			//# Attack with blaster rifle
-	BOTH_ATTACK4,			//# Attack with disruptor
-	BOTH_ATTACK5,			//# Another Rancor Attack
-	BOTH_ATTACK6,			//# Yet Another Rancor Attack
-	BOTH_ATTACK7,			//# Yet Another Rancor Attack
-	BOTH_ATTACK10,			//# Attack with thermal det
-	BOTH_ATTACK11,			//# "Attack" with tripmine and detpack
-	BOTH_MELEE1,			//# First melee attack
-	BOTH_MELEE2,			//# Second melee attack
-	BOTH_THERMAL_READY,		//# pull back with thermal
-	BOTH_THERMAL_THROW,		//# throw thermal
-	//* #sep BOTH_ SABER ANIMS
-	//Saber attack anims - power level 1
-	BOTH_A1_T__B_,	//# Fast weak vertical attack top to bottom
-	BOTH_A1__L__R,	//# Fast weak horizontal attack left to right
-	BOTH_A1__R__L,	//# Fast weak horizontal attack right to left
-	BOTH_A1_TL_BR,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A1_BR_TL,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A1_BL_TR,	//# Fast weak diagonal attack bottom left to top right
-	BOTH_A1_TR_BL,	//# Fast weak diagonal attack bottom left to right
-	//Saber Arc and Spin Transitions
-	BOTH_T1_BR__R,	//# Fast arc bottom right to right
-	BOTH_T1_BR_TL,	//# Fast weak spin bottom right to top left
-	BOTH_T1_BR__L,	//# Fast weak spin bottom right to left
-	BOTH_T1_BR_BL,	//# Fast weak spin bottom right to bottom left
-	BOTH_T1__R_TR,	//# Fast arc right to top right
-	BOTH_T1__R_TL,	//# Fast arc right to top left
-	BOTH_T1__R__L,	//# Fast weak spin right to left
-	BOTH_T1__R_BL,	//# Fast weak spin right to bottom left
-	BOTH_T1_TR_BR,	//# Fast arc top right to bottom right
-	BOTH_T1_TR_TL,	//# Fast arc top right to top left
-	BOTH_T1_TR__L,	//# Fast arc top right to left
-	BOTH_T1_TR_BL,	//# Fast weak spin top right to bottom left
-	BOTH_T1_T__BR,	//# Fast arc top to bottom right
-	BOTH_T1_T___R,	//# Fast arc top to right
-	BOTH_T1_T__TR,	//# Fast arc top to top right
-	BOTH_T1_T__TL,	//# Fast arc top to top left
-	BOTH_T1_T___L,	//# Fast arc top to left
-	BOTH_T1_T__BL,	//# Fast arc top to bottom left
-	BOTH_T1_TL_BR,	//# Fast weak spin top left to bottom right
-	BOTH_T1_TL_BL,	//# Fast arc top left to bottom left
-	BOTH_T1__L_BR,	//# Fast weak spin left to bottom right
-	BOTH_T1__L__R,	//# Fast weak spin left to right
-	BOTH_T1__L_TL,	//# Fast arc left to top left
-	BOTH_T1_BL_BR,	//# Fast weak spin bottom left to bottom right
-	BOTH_T1_BL__R,	//# Fast weak spin bottom left to right
-	BOTH_T1_BL_TR,	//# Fast weak spin bottom left to top right
-	BOTH_T1_BL__L,	//# Fast arc bottom left to left
-	//Saber Arc Transitions that use existing animations played backwards
-	BOTH_T1_BR_TR,	//# Fast arc bottom right to top right		(use: BOTH_T1_TR_BR)
-	BOTH_T1_BR_T_,	//# Fast arc bottom right to top			(use: BOTH_T1_T__BR)
-	BOTH_T1__R_BR,	//# Fast arc right to bottom right			(use: BOTH_T1_BR__R)
-	BOTH_T1__R_T_,	//# Fast ar right to top				(use: BOTH_T1_T___R)
-	BOTH_T1_TR__R,	//# Fast arc top right to right			(use: BOTH_T1__R_TR)
-	BOTH_T1_TR_T_,	//# Fast arc top right to top				(use: BOTH_T1_T__TR)
-	BOTH_T1_TL__R,	//# Fast arc top left to right			(use: BOTH_T1__R_TL)
-	BOTH_T1_TL_TR,	//# Fast arc top left to top right			(use: BOTH_T1_TR_TL)
-	BOTH_T1_TL_T_,	//# Fast arc top left to top				(use: BOTH_T1_T__TL)
-	BOTH_T1_TL__L,	//# Fast arc top left to left				(use: BOTH_T1__L_TL)
-	BOTH_T1__L_TR,	//# Fast arc left to top right			(use: BOTH_T1_TR__L)
-	BOTH_T1__L_T_,	//# Fast arc left to top				(use: BOTH_T1_T___L)
-	BOTH_T1__L_BL,	//# Fast arc left to bottom left			(use: BOTH_T1_BL__L)
-	BOTH_T1_BL_T_,	//# Fast arc bottom left to top			(use: BOTH_T1_T__BL)
-	BOTH_T1_BL_TL,	//# Fast arc bottom left to top left		(use: BOTH_T1_TL_BL)
-	//Saber Attack Start Transitions
-	BOTH_S1_S1_T_,	//# Fast plain transition from stance1 to top-to-bottom Fast weak attack
-	BOTH_S1_S1__L,	//# Fast plain transition from stance1 to left-to-right Fast weak attack
-	BOTH_S1_S1__R,	//# Fast plain transition from stance1 to right-to-left Fast weak attack
-	BOTH_S1_S1_TL,	//# Fast plain transition from stance1 to top-left-to-bottom-right Fast weak attack
-	BOTH_S1_S1_BR,	//# Fast plain transition from stance1 to bottom-right-to-top-left Fast weak attack
-	BOTH_S1_S1_BL,	//# Fast plain transition from stance1 to bottom-left-to-top-right Fast weak attack
-	BOTH_S1_S1_TR,	//# Fast plain transition from stance1 to top-right-to-bottom-left Fast weak attack
-	//Saber Attack Return Transitions
-	BOTH_R1_B__S1,	//# Fast plain transition from top-to-bottom Fast weak attack to stance1
-	BOTH_R1__L_S1,	//# Fast plain transition from left-to-right Fast weak attack to stance1
-	BOTH_R1__R_S1,	//# Fast plain transition from right-to-left Fast weak attack to stance1
-	BOTH_R1_TL_S1,	//# Fast plain transition from top-left-to-bottom-right Fast weak attack to stance1
-	BOTH_R1_BR_S1,	//# Fast plain transition from bottom-right-to-top-left Fast weak attack to stance1
-	BOTH_R1_BL_S1,	//# Fast plain transition from bottom-left-to-top-right Fast weak attack to stance1
-	BOTH_R1_TR_S1,	//# Fast plain transition from top-right-to-bottom-left Fast weak attack
-	//Saber Attack Bounces (first 4 frames of an attack, played backwards)
-	BOTH_B1_BR___,	//# Bounce-back if attack from BR is blocked
-	BOTH_B1__R___,	//# Bounce-back if attack from R is blocked
-	BOTH_B1_TR___,	//# Bounce-back if attack from TR is blocked
-	BOTH_B1_T____,	//# Bounce-back if attack from T is blocked
-	BOTH_B1_TL___,	//# Bounce-back if attack from TL is blocked
-	BOTH_B1__L___,	//# Bounce-back if attack from L is blocked
-	BOTH_B1_BL___,	//# Bounce-back if attack from BL is blocked
-	//Saber Attack Deflections (last 4 frames of an attack)
-	BOTH_D1_BR___,	//# Deflection toward BR
-	BOTH_D1__R___,	//# Deflection toward R
-	BOTH_D1_TR___,	//# Deflection toward TR
-	BOTH_D1_TL___,	//# Deflection toward TL
-	BOTH_D1__L___,	//# Deflection toward L
-	BOTH_D1_BL___,	//# Deflection toward BL
-	BOTH_D1_B____,	//# Deflection toward B
-	//Saber attack anims - power level 2
-	BOTH_A2_T__B_,	//# Fast weak vertical attack top to bottom
-	BOTH_A2__L__R,	//# Fast weak horizontal attack left to right
-	BOTH_A2__R__L,	//# Fast weak horizontal attack right to left
-	BOTH_A2_TL_BR,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A2_BR_TL,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A2_BL_TR,	//# Fast weak diagonal attack bottom left to top right
-	BOTH_A2_TR_BL,	//# Fast weak diagonal attack bottom left to right
-	//Saber Arc and Spin Transitions
-	BOTH_T2_BR__R,	//# Fast arc bottom right to right
-	BOTH_T2_BR_TL,	//# Fast weak spin bottom right to top left
-	BOTH_T2_BR__L,	//# Fast weak spin bottom right to left
-	BOTH_T2_BR_BL,	//# Fast weak spin bottom right to bottom left
-	BOTH_T2__R_TR,	//# Fast arc right to top right
-	BOTH_T2__R_TL,	//# Fast arc right to top left
-	BOTH_T2__R__L,	//# Fast weak spin right to left
-	BOTH_T2__R_BL,	//# Fast weak spin right to bottom left
-	BOTH_T2_TR_BR,	//# Fast arc top right to bottom right
-	BOTH_T2_TR_TL,	//# Fast arc top right to top left
-	BOTH_T2_TR__L,	//# Fast arc top right to left
-	BOTH_T2_TR_BL,	//# Fast weak spin top right to bottom left
-	BOTH_T2_T__BR,	//# Fast arc top to bottom right
-	BOTH_T2_T___R,	//# Fast arc top to right
-	BOTH_T2_T__TR,	//# Fast arc top to top right
-	BOTH_T2_T__TL,	//# Fast arc top to top left
-	BOTH_T2_T___L,	//# Fast arc top to left
-	BOTH_T2_T__BL,	//# Fast arc top to bottom left
-	BOTH_T2_TL_BR,	//# Fast weak spin top left to bottom right
-	BOTH_T2_TL_BL,	//# Fast arc top left to bottom left
-	BOTH_T2__L_BR,	//# Fast weak spin left to bottom right
-	BOTH_T2__L__R,	//# Fast weak spin left to right
-	BOTH_T2__L_TL,	//# Fast arc left to top left
-	BOTH_T2_BL_BR,	//# Fast weak spin bottom left to bottom right
-	BOTH_T2_BL__R,	//# Fast weak spin bottom left to right
-	BOTH_T2_BL_TR,	//# Fast weak spin bottom left to top right
-	BOTH_T2_BL__L,	//# Fast arc bottom left to left
-	//Saber Arc Transitions that use existing animations played backwards
-	BOTH_T2_BR_TR,	//# Fast arc bottom right to top right		(use: BOTH_T2_TR_BR)
-	BOTH_T2_BR_T_,	//# Fast arc bottom right to top			(use: BOTH_T2_T__BR)
-	BOTH_T2__R_BR,	//# Fast arc right to bottom right			(use: BOTH_T2_BR__R)
-	BOTH_T2__R_T_,	//# Fast ar right to top				(use: BOTH_T2_T___R)
-	BOTH_T2_TR__R,	//# Fast arc top right to right			(use: BOTH_T2__R_TR)
-	BOTH_T2_TR_T_,	//# Fast arc top right to top				(use: BOTH_T2_T__TR)
-	BOTH_T2_TL__R,	//# Fast arc top left to right			(use: BOTH_T2__R_TL)
-	BOTH_T2_TL_TR,	//# Fast arc top left to top right			(use: BOTH_T2_TR_TL)
-	BOTH_T2_TL_T_,	//# Fast arc top left to top				(use: BOTH_T2_T__TL)
-	BOTH_T2_TL__L,	//# Fast arc top left to left				(use: BOTH_T2__L_TL)
-	BOTH_T2__L_TR,	//# Fast arc left to top right			(use: BOTH_T2_TR__L)
-	BOTH_T2__L_T_,	//# Fast arc left to top				(use: BOTH_T2_T___L)
-	BOTH_T2__L_BL,	//# Fast arc left to bottom left			(use: BOTH_T2_BL__L)
-	BOTH_T2_BL_T_,	//# Fast arc bottom left to top			(use: BOTH_T2_T__BL)
-	BOTH_T2_BL_TL,	//# Fast arc bottom left to top left		(use: BOTH_T2_TL_BL)
-	//Saber Attack Start Transitions
-	BOTH_S2_S1_T_,	//# Fast plain transition from stance1 to top-to-bottom Fast weak attack
-	BOTH_S2_S1__L,	//# Fast plain transition from stance1 to left-to-right Fast weak attack
-	BOTH_S2_S1__R,	//# Fast plain transition from stance1 to right-to-left Fast weak attack
-	BOTH_S2_S1_TL,	//# Fast plain transition from stance1 to top-left-to-bottom-right Fast weak attack
-	BOTH_S2_S1_BR,	//# Fast plain transition from stance1 to bottom-right-to-top-left Fast weak attack
-	BOTH_S2_S1_BL,	//# Fast plain transition from stance1 to bottom-left-to-top-right Fast weak attack
-	BOTH_S2_S1_TR,	//# Fast plain transition from stance1 to top-right-to-bottom-left Fast weak attack
-	//Saber Attack Return Transitions
-	BOTH_R2_B__S1,	//# Fast plain transition from top-to-bottom Fast weak attack to stance1
-	BOTH_R2__L_S1,	//# Fast plain transition from left-to-right Fast weak attack to stance1
-	BOTH_R2__R_S1,	//# Fast plain transition from right-to-left Fast weak attack to stance1
-	BOTH_R2_TL_S1,	//# Fast plain transition from top-left-to-bottom-right Fast weak attack to stance1
-	BOTH_R2_BR_S1,	//# Fast plain transition from bottom-right-to-top-left Fast weak attack to stance1
-	BOTH_R2_BL_S1,	//# Fast plain transition from bottom-left-to-top-right Fast weak attack to stance1
-	BOTH_R2_TR_S1,	//# Fast plain transition from top-right-to-bottom-left Fast weak attack
-	//Saber Attack Bounces (first 4 frames of an attack, played backwards)
-	BOTH_B2_BR___,	//# Bounce-back if attack from BR is blocked
-	BOTH_B2__R___,	//# Bounce-back if attack from R is blocked
-	BOTH_B2_TR___,	//# Bounce-back if attack from TR is blocked
-	BOTH_B2_T____,	//# Bounce-back if attack from T is blocked
-	BOTH_B2_TL___,	//# Bounce-back if attack from TL is blocked
-	BOTH_B2__L___,	//# Bounce-back if attack from L is blocked
-	BOTH_B2_BL___,	//# Bounce-back if attack from BL is blocked
-	//Saber Attack Deflections (last 4 frames of an attack)
-	BOTH_D2_BR___,	//# Deflection toward BR
-	BOTH_D2__R___,	//# Deflection toward R
-	BOTH_D2_TR___,	//# Deflection toward TR
-	BOTH_D2_TL___,	//# Deflection toward TL
-	BOTH_D2__L___,	//# Deflection toward L
-	BOTH_D2_BL___,	//# Deflection toward BL
-	BOTH_D2_B____,	//# Deflection toward B
-	//Saber attack anims - power level 3
-	BOTH_A3_T__B_,	//# Fast weak vertical attack top to bottom
-	BOTH_A3__L__R,	//# Fast weak horizontal attack left to right
-	BOTH_A3__R__L,	//# Fast weak horizontal attack right to left
-	BOTH_A3_TL_BR,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A3_BR_TL,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A3_BL_TR,	//# Fast weak diagonal attack bottom left to top right
-	BOTH_A3_TR_BL,	//# Fast weak diagonal attack bottom left to right
-	//Saber Arc and Spin Transitions
-	BOTH_T3_BR__R,	//# Fast arc bottom right to right
-	BOTH_T3_BR_TL,	//# Fast weak spin bottom right to top left
-	BOTH_T3_BR__L,	//# Fast weak spin bottom right to left
-	BOTH_T3_BR_BL,	//# Fast weak spin bottom right to bottom left
-	BOTH_T3__R_TR,	//# Fast arc right to top right
-	BOTH_T3__R_TL,	//# Fast arc right to top left
-	BOTH_T3__R__L,	//# Fast weak spin right to left
-	BOTH_T3__R_BL,	//# Fast weak spin right to bottom left
-	BOTH_T3_TR_BR,	//# Fast arc top right to bottom right
-	BOTH_T3_TR_TL,	//# Fast arc top right to top left
-	BOTH_T3_TR__L,	//# Fast arc top right to left
-	BOTH_T3_TR_BL,	//# Fast weak spin top right to bottom left
-	BOTH_T3_T__BR,	//# Fast arc top to bottom right
-	BOTH_T3_T___R,	//# Fast arc top to right
-	BOTH_T3_T__TR,	//# Fast arc top to top right
-	BOTH_T3_T__TL,	//# Fast arc top to top left
-	BOTH_T3_T___L,	//# Fast arc top to left
-	BOTH_T3_T__BL,	//# Fast arc top to bottom left
-	BOTH_T3_TL_BR,	//# Fast weak spin top left to bottom right
-	BOTH_T3_TL_BL,	//# Fast arc top left to bottom left
-	BOTH_T3__L_BR,	//# Fast weak spin left to bottom right
-	BOTH_T3__L__R,	//# Fast weak spin left to right
-	BOTH_T3__L_TL,	//# Fast arc left to top left
-	BOTH_T3_BL_BR,	//# Fast weak spin bottom left to bottom right
-	BOTH_T3_BL__R,	//# Fast weak spin bottom left to right
-	BOTH_T3_BL_TR,	//# Fast weak spin bottom left to top right
-	BOTH_T3_BL__L,	//# Fast arc bottom left to left
-	//Saber Arc Transitions that use existing animations played backwards
-	BOTH_T3_BR_TR,	//# Fast arc bottom right to top right		(use: BOTH_T3_TR_BR)
-	BOTH_T3_BR_T_,	//# Fast arc bottom right to top			(use: BOTH_T3_T__BR)
-	BOTH_T3__R_BR,	//# Fast arc right to bottom right			(use: BOTH_T3_BR__R)
-	BOTH_T3__R_T_,	//# Fast ar right to top				(use: BOTH_T3_T___R)
-	BOTH_T3_TR__R,	//# Fast arc top right to right			(use: BOTH_T3__R_TR)
-	BOTH_T3_TR_T_,	//# Fast arc top right to top				(use: BOTH_T3_T__TR)
-	BOTH_T3_TL__R,	//# Fast arc top left to right			(use: BOTH_T3__R_TL)
-	BOTH_T3_TL_TR,	//# Fast arc top left to top right			(use: BOTH_T3_TR_TL)
-	BOTH_T3_TL_T_,	//# Fast arc top left to top				(use: BOTH_T3_T__TL)
-	BOTH_T3_TL__L,	//# Fast arc top left to left				(use: BOTH_T3__L_TL)
-	BOTH_T3__L_TR,	//# Fast arc left to top right			(use: BOTH_T3_TR__L)
-	BOTH_T3__L_T_,	//# Fast arc left to top				(use: BOTH_T3_T___L)
-	BOTH_T3__L_BL,	//# Fast arc left to bottom left			(use: BOTH_T3_BL__L)
-	BOTH_T3_BL_T_,	//# Fast arc bottom left to top			(use: BOTH_T3_T__BL)
-	BOTH_T3_BL_TL,	//# Fast arc bottom left to top left		(use: BOTH_T3_TL_BL)
-	//Saber Attack Start Transitions
-	BOTH_S3_S1_T_,	//# Fast plain transition from stance1 to top-to-bottom Fast weak attack
-	BOTH_S3_S1__L,	//# Fast plain transition from stance1 to left-to-right Fast weak attack
-	BOTH_S3_S1__R,	//# Fast plain transition from stance1 to right-to-left Fast weak attack
-	BOTH_S3_S1_TL,	//# Fast plain transition from stance1 to top-left-to-bottom-right Fast weak attack
-	BOTH_S3_S1_BR,	//# Fast plain transition from stance1 to bottom-right-to-top-left Fast weak attack
-	BOTH_S3_S1_BL,	//# Fast plain transition from stance1 to bottom-left-to-top-right Fast weak attack
-	BOTH_S3_S1_TR,	//# Fast plain transition from stance1 to top-right-to-bottom-left Fast weak attack
-	//Saber Attack Return Transitions
-	BOTH_R3_B__S1,	//# Fast plain transition from top-to-bottom Fast weak attack to stance1
-	BOTH_R3__L_S1,	//# Fast plain transition from left-to-right Fast weak attack to stance1
-	BOTH_R3__R_S1,	//# Fast plain transition from right-to-left Fast weak attack to stance1
-	BOTH_R3_TL_S1,	//# Fast plain transition from top-left-to-bottom-right Fast weak attack to stance1
-	BOTH_R3_BR_S1,	//# Fast plain transition from bottom-right-to-top-left Fast weak attack to stance1
-	BOTH_R3_BL_S1,	//# Fast plain transition from bottom-left-to-top-right Fast weak attack to stance1
-	BOTH_R3_TR_S1,	//# Fast plain transition from top-right-to-bottom-left Fast weak attack
-	//Saber Attack Bounces (first 4 frames of an attack, played backwards)
-	BOTH_B3_BR___,	//# Bounce-back if attack from BR is blocked
-	BOTH_B3__R___,	//# Bounce-back if attack from R is blocked
-	BOTH_B3_TR___,	//# Bounce-back if attack from TR is blocked
-	BOTH_B3_T____,	//# Bounce-back if attack from T is blocked
-	BOTH_B3_TL___,	//# Bounce-back if attack from TL is blocked
-	BOTH_B3__L___,	//# Bounce-back if attack from L is blocked
-	BOTH_B3_BL___,	//# Bounce-back if attack from BL is blocked
-	//Saber Attack Deflections (last 4 frames of an attack)
-	BOTH_D3_BR___,	//# Deflection toward BR
-	BOTH_D3__R___,	//# Deflection toward R
-	BOTH_D3_TR___,	//# Deflection toward TR
-	BOTH_D3_TL___,	//# Deflection toward TL
-	BOTH_D3__L___,	//# Deflection toward L
-	BOTH_D3_BL___,	//# Deflection toward BL
-	BOTH_D3_B____,	//# Deflection toward B
-	//Saber attack anims - power level 4  - Desann's
-	BOTH_A4_T__B_,	//# Fast weak vertical attack top to bottom
-	BOTH_A4__L__R,	//# Fast weak horizontal attack left to right
-	BOTH_A4__R__L,	//# Fast weak horizontal attack right to left
-	BOTH_A4_TL_BR,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A4_BR_TL,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A4_BL_TR,	//# Fast weak diagonal attack bottom left to top right
-	BOTH_A4_TR_BL,	//# Fast weak diagonal attack bottom left to right
-	//Saber Arc and Spin Transitions
-	BOTH_T4_BR__R,	//# Fast arc bottom right to right
-	BOTH_T4_BR_TL,	//# Fast weak spin bottom right to top left
-	BOTH_T4_BR__L,	//# Fast weak spin bottom right to left
-	BOTH_T4_BR_BL,	//# Fast weak spin bottom right to bottom left
-	BOTH_T4__R_TR,	//# Fast arc right to top right
-	BOTH_T4__R_TL,	//# Fast arc right to top left
-	BOTH_T4__R__L,	//# Fast weak spin right to left
-	BOTH_T4__R_BL,	//# Fast weak spin right to bottom left
-	BOTH_T4_TR_BR,	//# Fast arc top right to bottom right
-	BOTH_T4_TR_TL,	//# Fast arc top right to top left
-	BOTH_T4_TR__L,	//# Fast arc top right to left
-	BOTH_T4_TR_BL,	//# Fast weak spin top right to bottom left
-	BOTH_T4_T__BR,	//# Fast arc top to bottom right
-	BOTH_T4_T___R,	//# Fast arc top to right
-	BOTH_T4_T__TR,	//# Fast arc top to top right
-	BOTH_T4_T__TL,	//# Fast arc top to top left
-	BOTH_T4_T___L,	//# Fast arc top to left
-	BOTH_T4_T__BL,	//# Fast arc top to bottom left
-	BOTH_T4_TL_BR,	//# Fast weak spin top left to bottom right
-	BOTH_T4_TL_BL,	//# Fast arc top left to bottom left
-	BOTH_T4__L_BR,	//# Fast weak spin left to bottom right
-	BOTH_T4__L__R,	//# Fast weak spin left to right
-	BOTH_T4__L_TL,	//# Fast arc left to top left
-	BOTH_T4_BL_BR,	//# Fast weak spin bottom left to bottom right
-	BOTH_T4_BL__R,	//# Fast weak spin bottom left to right
-	BOTH_T4_BL_TR,	//# Fast weak spin bottom left to top right
-	BOTH_T4_BL__L,	//# Fast arc bottom left to left
-	//Saber Arc Transitions that use existing animations played backwards
-	BOTH_T4_BR_TR,	//# Fast arc bottom right to top right		(use: BOTH_T4_TR_BR)
-	BOTH_T4_BR_T_,	//# Fast arc bottom right to top			(use: BOTH_T4_T__BR)
-	BOTH_T4__R_BR,	//# Fast arc right to bottom right			(use: BOTH_T4_BR__R)
-	BOTH_T4__R_T_,	//# Fast ar right to top				(use: BOTH_T4_T___R)
-	BOTH_T4_TR__R,	//# Fast arc top right to right			(use: BOTH_T4__R_TR)
-	BOTH_T4_TR_T_,	//# Fast arc top right to top				(use: BOTH_T4_T__TR)
-	BOTH_T4_TL__R,	//# Fast arc top left to right			(use: BOTH_T4__R_TL)
-	BOTH_T4_TL_TR,	//# Fast arc top left to top right			(use: BOTH_T4_TR_TL)
-	BOTH_T4_TL_T_,	//# Fast arc top left to top				(use: BOTH_T4_T__TL)
-	BOTH_T4_TL__L,	//# Fast arc top left to left				(use: BOTH_T4__L_TL)
-	BOTH_T4__L_TR,	//# Fast arc left to top right			(use: BOTH_T4_TR__L)
-	BOTH_T4__L_T_,	//# Fast arc left to top				(use: BOTH_T4_T___L)
-	BOTH_T4__L_BL,	//# Fast arc left to bottom left			(use: BOTH_T4_BL__L)
-	BOTH_T4_BL_T_,	//# Fast arc bottom left to top			(use: BOTH_T4_T__BL)
-	BOTH_T4_BL_TL,	//# Fast arc bottom left to top left		(use: BOTH_T4_TL_BL)
-	//Saber Attack Start Transitions
-	BOTH_S4_S1_T_,	//# Fast plain transition from stance1 to top-to-bottom Fast weak attack
-	BOTH_S4_S1__L,	//# Fast plain transition from stance1 to left-to-right Fast weak attack
-	BOTH_S4_S1__R,	//# Fast plain transition from stance1 to right-to-left Fast weak attack
-	BOTH_S4_S1_TL,	//# Fast plain transition from stance1 to top-left-to-bottom-right Fast weak attack
-	BOTH_S4_S1_BR,	//# Fast plain transition from stance1 to bottom-right-to-top-left Fast weak attack
-	BOTH_S4_S1_BL,	//# Fast plain transition from stance1 to bottom-left-to-top-right Fast weak attack
-	BOTH_S4_S1_TR,	//# Fast plain transition from stance1 to top-right-to-bottom-left Fast weak attack
-	//Saber Attack Return Transitions
-	BOTH_R4_B__S1,	//# Fast plain transition from top-to-bottom Fast weak attack to stance1
-	BOTH_R4__L_S1,	//# Fast plain transition from left-to-right Fast weak attack to stance1
-	BOTH_R4__R_S1,	//# Fast plain transition from right-to-left Fast weak attack to stance1
-	BOTH_R4_TL_S1,	//# Fast plain transition from top-left-to-bottom-right Fast weak attack to stance1
-	BOTH_R4_BR_S1,	//# Fast plain transition from bottom-right-to-top-left Fast weak attack to stance1
-	BOTH_R4_BL_S1,	//# Fast plain transition from bottom-left-to-top-right Fast weak attack to stance1
-	BOTH_R4_TR_S1,	//# Fast plain transition from top-right-to-bottom-left Fast weak attack
-	//Saber Attack Bounces (first 4 frames of an attack, played backwards)
-	BOTH_B4_BR___,	//# Bounce-back if attack from BR is blocked
-	BOTH_B4__R___,	//# Bounce-back if attack from R is blocked
-	BOTH_B4_TR___,	//# Bounce-back if attack from TR is blocked
-	BOTH_B4_T____,	//# Bounce-back if attack from T is blocked
-	BOTH_B4_TL___,	//# Bounce-back if attack from TL is blocked
-	BOTH_B4__L___,	//# Bounce-back if attack from L is blocked
-	BOTH_B4_BL___,	//# Bounce-back if attack from BL is blocked
-	//Saber Attack Deflections (last 4 frames of an attack)
-	BOTH_D4_BR___,	//# Deflection toward BR
-	BOTH_D4__R___,	//# Deflection toward R
-	BOTH_D4_TR___,	//# Deflection toward TR
-	BOTH_D4_TL___,	//# Deflection toward TL
-	BOTH_D4__L___,	//# Deflection toward L
-	BOTH_D4_BL___,	//# Deflection toward BL
-	BOTH_D4_B____,	//# Deflection toward B
-	//Saber attack anims - power level 5  - Tavion's
-	BOTH_A5_T__B_,	//# Fast weak vertical attack top to bottom
-	BOTH_A5__L__R,	//# Fast weak horizontal attack left to right
-	BOTH_A5__R__L,	//# Fast weak horizontal attack right to left
-	BOTH_A5_TL_BR,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A5_BR_TL,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A5_BL_TR,	//# Fast weak diagonal attack bottom left to top right
-	BOTH_A5_TR_BL,	//# Fast weak diagonal attack bottom left to right
-	//Saber Arc and Spin Transitions
-	BOTH_T5_BR__R,	//# Fast arc bottom right to right
-	BOTH_T5_BR_TL,	//# Fast weak spin bottom right to top left
-	BOTH_T5_BR__L,	//# Fast weak spin bottom right to left
-	BOTH_T5_BR_BL,	//# Fast weak spin bottom right to bottom left
-	BOTH_T5__R_TR,	//# Fast arc right to top right
-	BOTH_T5__R_TL,	//# Fast arc right to top left
-	BOTH_T5__R__L,	//# Fast weak spin right to left
-	BOTH_T5__R_BL,	//# Fast weak spin right to bottom left
-	BOTH_T5_TR_BR,	//# Fast arc top right to bottom right
-	BOTH_T5_TR_TL,	//# Fast arc top right to top left
-	BOTH_T5_TR__L,	//# Fast arc top right to left
-	BOTH_T5_TR_BL,	//# Fast weak spin top right to bottom left
-	BOTH_T5_T__BR,	//# Fast arc top to bottom right
-	BOTH_T5_T___R,	//# Fast arc top to right
-	BOTH_T5_T__TR,	//# Fast arc top to top right
-	BOTH_T5_T__TL,	//# Fast arc top to top left
-	BOTH_T5_T___L,	//# Fast arc top to left
-	BOTH_T5_T__BL,	//# Fast arc top to bottom left
-	BOTH_T5_TL_BR,	//# Fast weak spin top left to bottom right
-	BOTH_T5_TL_BL,	//# Fast arc top left to bottom left
-	BOTH_T5__L_BR,	//# Fast weak spin left to bottom right
-	BOTH_T5__L__R,	//# Fast weak spin left to right
-	BOTH_T5__L_TL,	//# Fast arc left to top left
-	BOTH_T5_BL_BR,	//# Fast weak spin bottom left to bottom right
-	BOTH_T5_BL__R,	//# Fast weak spin bottom left to right
-	BOTH_T5_BL_TR,	//# Fast weak spin bottom left to top right
-	BOTH_T5_BL__L,	//# Fast arc bottom left to left
-	//Saber Arc Transitions that use existing animations played backwards
-	BOTH_T5_BR_TR,	//# Fast arc bottom right to top right		(use: BOTH_T5_TR_BR)
-	BOTH_T5_BR_T_,	//# Fast arc bottom right to top			(use: BOTH_T5_T__BR)
-	BOTH_T5__R_BR,	//# Fast arc right to bottom right			(use: BOTH_T5_BR__R)
-	BOTH_T5__R_T_,	//# Fast ar right to top				(use: BOTH_T5_T___R)
-	BOTH_T5_TR__R,	//# Fast arc top right to right			(use: BOTH_T5__R_TR)
-	BOTH_T5_TR_T_,	//# Fast arc top right to top				(use: BOTH_T5_T__TR)
-	BOTH_T5_TL__R,	//# Fast arc top left to right			(use: BOTH_T5__R_TL)
-	BOTH_T5_TL_TR,	//# Fast arc top left to top right			(use: BOTH_T5_TR_TL)
-	BOTH_T5_TL_T_,	//# Fast arc top left to top				(use: BOTH_T5_T__TL)
-	BOTH_T5_TL__L,	//# Fast arc top left to left				(use: BOTH_T5__L_TL)
-	BOTH_T5__L_TR,	//# Fast arc left to top right			(use: BOTH_T5_TR__L)
-	BOTH_T5__L_T_,	//# Fast arc left to top				(use: BOTH_T5_T___L)
-	BOTH_T5__L_BL,	//# Fast arc left to bottom left			(use: BOTH_T5_BL__L)
-	BOTH_T5_BL_T_,	//# Fast arc bottom left to top			(use: BOTH_T5_T__BL)
-	BOTH_T5_BL_TL,	//# Fast arc bottom left to top left		(use: BOTH_T5_TL_BL)
-	//Saber Attack Start Transitions
-	BOTH_S5_S1_T_,	//# Fast plain transition from stance1 to top-to-bottom Fast weak attack
-	BOTH_S5_S1__L,	//# Fast plain transition from stance1 to left-to-right Fast weak attack
-	BOTH_S5_S1__R,	//# Fast plain transition from stance1 to right-to-left Fast weak attack
-	BOTH_S5_S1_TL,	//# Fast plain transition from stance1 to top-left-to-bottom-right Fast weak attack
-	BOTH_S5_S1_BR,	//# Fast plain transition from stance1 to bottom-right-to-top-left Fast weak attack
-	BOTH_S5_S1_BL,	//# Fast plain transition from stance1 to bottom-left-to-top-right Fast weak attack
-	BOTH_S5_S1_TR,	//# Fast plain transition from stance1 to top-right-to-bottom-left Fast weak attack
-	//Saber Attack Return Transitions
-	BOTH_R5_B__S1,	//# Fast plain transition from top-to-bottom Fast weak attack to stance1
-	BOTH_R5__L_S1,	//# Fast plain transition from left-to-right Fast weak attack to stance1
-	BOTH_R5__R_S1,	//# Fast plain transition from right-to-left Fast weak attack to stance1
-	BOTH_R5_TL_S1,	//# Fast plain transition from top-left-to-bottom-right Fast weak attack to stance1
-	BOTH_R5_BR_S1,	//# Fast plain transition from bottom-right-to-top-left Fast weak attack to stance1
-	BOTH_R5_BL_S1,	//# Fast plain transition from bottom-left-to-top-right Fast weak attack to stance1
-	BOTH_R5_TR_S1,	//# Fast plain transition from top-right-to-bottom-left Fast weak attack
-	//Saber Attack Bounces (first 4 frames of an attack, played backwards)
-	BOTH_B5_BR___,	//# Bounce-back if attack from BR is blocked
-	BOTH_B5__R___,	//# Bounce-back if attack from R is blocked
-	BOTH_B5_TR___,	//# Bounce-back if attack from TR is blocked
-	BOTH_B5_T____,	//# Bounce-back if attack from T is blocked
-	BOTH_B5_TL___,	//# Bounce-back if attack from TL is blocked
-	BOTH_B5__L___,	//# Bounce-back if attack from L is blocked
-	BOTH_B5_BL___,	//# Bounce-back if attack from BL is blocked
-	//Saber Attack Deflections (last 4 frames of an attack)
-	BOTH_D5_BR___,	//# Deflection toward BR
-	BOTH_D5__R___,	//# Deflection toward R
-	BOTH_D5_TR___,	//# Deflection toward TR
-	BOTH_D5_TL___,	//# Deflection toward TL
-	BOTH_D5__L___,	//# Deflection toward L
-	BOTH_D5_BL___,	//# Deflection toward BL
-	BOTH_D5_B____,	//# Deflection toward B
-	//Saber attack anims - power level 6
-	BOTH_A6_T__B_,	//# Fast weak vertical attack top to bottom
-	BOTH_A6__L__R,	//# Fast weak horizontal attack left to right
-	BOTH_A6__R__L,	//# Fast weak horizontal attack right to left
-	BOTH_A6_TL_BR,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A6_BR_TL,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A6_BL_TR,	//# Fast weak diagonal attack bottom left to top right
-	BOTH_A6_TR_BL,	//# Fast weak diagonal attack bottom left to right
-	//Saber Arc and Spin Transitions
-	BOTH_T6_BR__R,	//# Fast arc bottom right to right
-	BOTH_T6_BR_TL,	//# Fast weak spin bottom right to top left
-	BOTH_T6_BR__L,	//# Fast weak spin bottom right to left
-	BOTH_T6_BR_BL,	//# Fast weak spin bottom right to bottom left
-	BOTH_T6__R_TR,	//# Fast arc right to top right
-	BOTH_T6__R_TL,	//# Fast arc right to top left
-	BOTH_T6__R__L,	//# Fast weak spin right to left
-	BOTH_T6__R_BL,	//# Fast weak spin right to bottom left
-	BOTH_T6_TR_BR,	//# Fast arc top right to bottom right
-	BOTH_T6_TR_TL,	//# Fast arc top right to top left
-	BOTH_T6_TR__L,	//# Fast arc top right to left
-	BOTH_T6_TR_BL,	//# Fast weak spin top right to bottom left
-	BOTH_T6_T__BR,	//# Fast arc top to bottom right
-	BOTH_T6_T___R,	//# Fast arc top to right
-	BOTH_T6_T__TR,	//# Fast arc top to top right
-	BOTH_T6_T__TL,	//# Fast arc top to top left
-	BOTH_T6_T___L,	//# Fast arc top to left
-	BOTH_T6_T__BL,	//# Fast arc top to bottom left
-	BOTH_T6_TL_BR,	//# Fast weak spin top left to bottom right
-	BOTH_T6_TL_BL,	//# Fast arc top left to bottom left
-	BOTH_T6__L_BR,	//# Fast weak spin left to bottom right
-	BOTH_T6__L__R,	//# Fast weak spin left to right
-	BOTH_T6__L_TL,	//# Fast arc left to top left
-	BOTH_T6_BL_BR,	//# Fast weak spin bottom left to bottom right
-	BOTH_T6_BL__R,	//# Fast weak spin bottom left to right
-	BOTH_T6_BL_TR,	//# Fast weak spin bottom left to top right
-	BOTH_T6_BL__L,	//# Fast arc bottom left to left
-	//Saber Arc Transitions that use existing animations played backwards
-	BOTH_T6_BR_TR,	//# Fast arc bottom right to top right		(use: BOTH_T6_TR_BR)
-	BOTH_T6_BR_T_,	//# Fast arc bottom right to top			(use: BOTH_T6_T__BR)
-	BOTH_T6__R_BR,	//# Fast arc right to bottom right			(use: BOTH_T6_BR__R)
-	BOTH_T6__R_T_,	//# Fast ar right to top				(use: BOTH_T6_T___R)
-	BOTH_T6_TR__R,	//# Fast arc top right to right			(use: BOTH_T6__R_TR)
-	BOTH_T6_TR_T_,	//# Fast arc top right to top				(use: BOTH_T6_T__TR)
-	BOTH_T6_TL__R,	//# Fast arc top left to right			(use: BOTH_T6__R_TL)
-	BOTH_T6_TL_TR,	//# Fast arc top left to top right			(use: BOTH_T6_TR_TL)
-	BOTH_T6_TL_T_,	//# Fast arc top left to top				(use: BOTH_T6_T__TL)
-	BOTH_T6_TL__L,	//# Fast arc top left to left				(use: BOTH_T6__L_TL)
-	BOTH_T6__L_TR,	//# Fast arc left to top right			(use: BOTH_T6_TR__L)
-	BOTH_T6__L_T_,	//# Fast arc left to top				(use: BOTH_T6_T___L)
-	BOTH_T6__L_BL,	//# Fast arc left to bottom left			(use: BOTH_T6_BL__L)
-	BOTH_T6_BL_T_,	//# Fast arc bottom left to top			(use: BOTH_T6_T__BL)
-	BOTH_T6_BL_TL,	//# Fast arc bottom left to top left		(use: BOTH_T6_TL_BL)
-	//Saber Attack Start Transitions
-	BOTH_S6_S6_T_,	//# Fast plain transition from stance1 to top-to-bottom Fast weak attack
-	BOTH_S6_S6__L,	//# Fast plain transition from stance1 to left-to-right Fast weak attack
-	BOTH_S6_S6__R,	//# Fast plain transition from stance1 to right-to-left Fast weak attack
-	BOTH_S6_S6_TL,	//# Fast plain transition from stance1 to top-left-to-bottom-right Fast weak attack
-	BOTH_S6_S6_BR,	//# Fast plain transition from stance1 to bottom-right-to-top-left Fast weak attack
-	BOTH_S6_S6_BL,	//# Fast plain transition from stance1 to bottom-left-to-top-right Fast weak attack
-	BOTH_S6_S6_TR,	//# Fast plain transition from stance1 to top-right-to-bottom-left Fast weak attack
-	//Saber Attack Return Transitions
-	BOTH_R6_B__S6,	//# Fast plain transition from top-to-bottom Fast weak attack to stance1
-	BOTH_R6__L_S6,	//# Fast plain transition from left-to-right Fast weak attack to stance1
-	BOTH_R6__R_S6,	//# Fast plain transition from right-to-left Fast weak attack to stance1
-	BOTH_R6_TL_S6,	//# Fast plain transition from top-left-to-bottom-right Fast weak attack to stance1
-	BOTH_R6_BR_S6,	//# Fast plain transition from bottom-right-to-top-left Fast weak attack to stance1
-	BOTH_R6_BL_S6,	//# Fast plain transition from bottom-left-to-top-right Fast weak attack to stance1
-	BOTH_R6_TR_S6,	//# Fast plain transition from top-right-to-bottom-left Fast weak attack
-	//Saber Attack Bounces (first 4 frames of an attack, played backwards)
-	BOTH_B6_BR___,	//# Bounce-back if attack from BR is blocked
-	BOTH_B6__R___,	//# Bounce-back if attack from R is blocked
-	BOTH_B6_TR___,	//# Bounce-back if attack from TR is blocked
-	BOTH_B6_T____,	//# Bounce-back if attack from T is blocked
-	BOTH_B6_TL___,	//# Bounce-back if attack from TL is blocked
-	BOTH_B6__L___,	//# Bounce-back if attack from L is blocked
-	BOTH_B6_BL___,	//# Bounce-back if attack from BL is blocked
-	//Saber Attack Deflections (last 4 frames of an attack)
-	BOTH_D6_BR___,	//# Deflection toward BR
-	BOTH_D6__R___,	//# Deflection toward R
-	BOTH_D6_TR___,	//# Deflection toward TR
-	BOTH_D6_TL___,	//# Deflection toward TL
-	BOTH_D6__L___,	//# Deflection toward L
-	BOTH_D6_BL___,	//# Deflection toward BL
-	BOTH_D6_B____,	//# Deflection toward B
-	//Saber attack anims - power level 7
-	BOTH_A7_T__B_,	//# Fast weak vertical attack top to bottom
-	BOTH_A7__L__R,	//# Fast weak horizontal attack left to right
-	BOTH_A7__R__L,	//# Fast weak horizontal attack right to left
-	BOTH_A7_TL_BR,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A7_BR_TL,	//# Fast weak diagonal attack top left to botom right
-	BOTH_A7_BL_TR,	//# Fast weak diagonal attack bottom left to top right
-	BOTH_A7_TR_BL,	//# Fast weak diagonal attack bottom left to right
-	//Saber Arc and Spin Transitions
-	BOTH_T7_BR__R,	//# Fast arc bottom right to right
-	BOTH_T7_BR_TL,	//# Fast weak spin bottom right to top left
-	BOTH_T7_BR__L,	//# Fast weak spin bottom right to left
-	BOTH_T7_BR_BL,	//# Fast weak spin bottom right to bottom left
-	BOTH_T7__R_TR,	//# Fast arc right to top right
-	BOTH_T7__R_TL,	//# Fast arc right to top left
-	BOTH_T7__R__L,	//# Fast weak spin right to left
-	BOTH_T7__R_BL,	//# Fast weak spin right to bottom left
-	BOTH_T7_TR_BR,	//# Fast arc top right to bottom right
-	BOTH_T7_TR_TL,	//# Fast arc top right to top left
-	BOTH_T7_TR__L,	//# Fast arc top right to left
-	BOTH_T7_TR_BL,	//# Fast weak spin top right to bottom left
-	BOTH_T7_T__BR,	//# Fast arc top to bottom right
-	BOTH_T7_T___R,	//# Fast arc top to right
-	BOTH_T7_T__TR,	//# Fast arc top to top right
-	BOTH_T7_T__TL,	//# Fast arc top to top left
-	BOTH_T7_T___L,	//# Fast arc top to left
-	BOTH_T7_T__BL,	//# Fast arc top to bottom left
-	BOTH_T7_TL_BR,	//# Fast weak spin top left to bottom right
-	BOTH_T7_TL_BL,	//# Fast arc top left to bottom left
-	BOTH_T7__L_BR,	//# Fast weak spin left to bottom right
-	BOTH_T7__L__R,	//# Fast weak spin left to right
-	BOTH_T7__L_TL,	//# Fast arc left to top left
-	BOTH_T7_BL_BR,	//# Fast weak spin bottom left to bottom right
-	BOTH_T7_BL__R,	//# Fast weak spin bottom left to right
-	BOTH_T7_BL_TR,	//# Fast weak spin bottom left to top right
-	BOTH_T7_BL__L,	//# Fast arc bottom left to left
-	//Saber Arc Transitions that use existing animations played backwards
-	BOTH_T7_BR_TR,	//# Fast arc bottom right to top right		(use: BOTH_T7_TR_BR)
-	BOTH_T7_BR_T_,	//# Fast arc bottom right to top			(use: BOTH_T7_T__BR)
-	BOTH_T7__R_BR,	//# Fast arc right to bottom right			(use: BOTH_T7_BR__R)
-	BOTH_T7__R_T_,	//# Fast ar right to top				(use: BOTH_T7_T___R)
-	BOTH_T7_TR__R,	//# Fast arc top right to right			(use: BOTH_T7__R_TR)
-	BOTH_T7_TR_T_,	//# Fast arc top right to top				(use: BOTH_T7_T__TR)
-	BOTH_T7_TL__R,	//# Fast arc top left to right			(use: BOTH_T7__R_TL)
-	BOTH_T7_TL_TR,	//# Fast arc top left to top right			(use: BOTH_T7_TR_TL)
-	BOTH_T7_TL_T_,	//# Fast arc top left to top				(use: BOTH_T7_T__TL)
-	BOTH_T7_TL__L,	//# Fast arc top left to left				(use: BOTH_T7__L_TL)
-	BOTH_T7__L_TR,	//# Fast arc left to top right			(use: BOTH_T7_TR__L)
-	BOTH_T7__L_T_,	//# Fast arc left to top				(use: BOTH_T7_T___L)
-	BOTH_T7__L_BL,	//# Fast arc left to bottom left			(use: BOTH_T7_BL__L)
-	BOTH_T7_BL_T_,	//# Fast arc bottom left to top			(use: BOTH_T7_T__BL)
-	BOTH_T7_BL_TL,	//# Fast arc bottom left to top left		(use: BOTH_T7_TL_BL)
-	//Saber Attack Start Transitions
-	BOTH_S7_S7_T_,	//# Fast plain transition from stance1 to top-to-bottom Fast weak attack
-	BOTH_S7_S7__L,	//# Fast plain transition from stance1 to left-to-right Fast weak attack
-	BOTH_S7_S7__R,	//# Fast plain transition from stance1 to right-to-left Fast weak attack
-	BOTH_S7_S7_TL,	//# Fast plain transition from stance1 to top-left-to-bottom-right Fast weak attack
-	BOTH_S7_S7_BR,	//# Fast plain transition from stance1 to bottom-right-to-top-left Fast weak attack
-	BOTH_S7_S7_BL,	//# Fast plain transition from stance1 to bottom-left-to-top-right Fast weak attack
-	BOTH_S7_S7_TR,	//# Fast plain transition from stance1 to top-right-to-bottom-left Fast weak attack
-	//Saber Attack Return Transitions
-	BOTH_R7_B__S7,	//# Fast plain transition from top-to-bottom Fast weak attack to stance1
-	BOTH_R7__L_S7,	//# Fast plain transition from left-to-right Fast weak attack to stance1
-	BOTH_R7__R_S7,	//# Fast plain transition from right-to-left Fast weak attack to stance1
-	BOTH_R7_TL_S7,	//# Fast plain transition from top-left-to-bottom-right Fast weak attack to stance1
-	BOTH_R7_BR_S7,	//# Fast plain transition from bottom-right-to-top-left Fast weak attack to stance1
-	BOTH_R7_BL_S7,	//# Fast plain transition from bottom-left-to-top-right Fast weak attack to stance1
-	BOTH_R7_TR_S7,	//# Fast plain transition from top-right-to-bottom-left Fast weak attack
-	//Saber Attack Bounces (first 4 frames of an attack, played backwards)
-	BOTH_B7_BR___,	//# Bounce-back if attack from BR is blocked
-	BOTH_B7__R___,	//# Bounce-back if attack from R is blocked
-	BOTH_B7_TR___,	//# Bounce-back if attack from TR is blocked
-	BOTH_B7_T____,	//# Bounce-back if attack from T is blocked
-	BOTH_B7_TL___,	//# Bounce-back if attack from TL is blocked
-	BOTH_B7__L___,	//# Bounce-back if attack from L is blocked
-	BOTH_B7_BL___,	//# Bounce-back if attack from BL is blocked
-	//Saber Attack Deflections (last 4 frames of an attack)
-	BOTH_D7_BR___,	//# Deflection toward BR
-	BOTH_D7__R___,	//# Deflection toward R
-	BOTH_D7_TR___,	//# Deflection toward TR
-	BOTH_D7_TL___,	//# Deflection toward TL
-	BOTH_D7__L___,	//# Deflection toward L
-	BOTH_D7_BL___,	//# Deflection toward BL
-	BOTH_D7_B____,	//# Deflection toward B
-	//Saber parry anims
-	BOTH_P1_S1_T_,	//# Block shot/saber top
-	BOTH_P1_S1_TR,	//# Block shot/saber top right
-	BOTH_P1_S1_TL,	//# Block shot/saber top left
-	BOTH_P1_S1_BL,	//# Block shot/saber bottom left
-	BOTH_P1_S1_BR,	//# Block shot/saber bottom right
-	//Saber knockaway
-	BOTH_K1_S1_T_,	//# knockaway saber top
-	BOTH_K1_S1_TR,	//# knockaway saber top right
-	BOTH_K1_S1_TL,	//# knockaway saber top left
-	BOTH_K1_S1_BL,	//# knockaway saber bottom left
-	BOTH_K1_S1_B_,	//# knockaway saber bottom
-	BOTH_K1_S1_BR,	//# knockaway saber bottom right
-	//Saber attack knocked away
-	BOTH_V1_BR_S1,	//# BR attack knocked away
-	BOTH_V1__R_S1,	//# R attack knocked away
-	BOTH_V1_TR_S1,	//# TR attack knocked away
-	BOTH_V1_T__S1,	//# T attack knocked away
-	BOTH_V1_TL_S1,	//# TL attack knocked away
-	BOTH_V1__L_S1,	//# L attack knocked away
-	BOTH_V1_BL_S1,	//# BL attack knocked away
-	BOTH_V1_B__S1,	//# B attack knocked away
-	//Saber parry broken
-	BOTH_H1_S1_T_,	//# saber knocked down from top parry
-	BOTH_H1_S1_TR,	//# saber knocked down-left from TR parry
-	BOTH_H1_S1_TL,	//# saber knocked down-right from TL parry
-	BOTH_H1_S1_BL,	//# saber knocked up-right from BL parry
-	BOTH_H1_S1_B_,	//# saber knocked up over head from ready?
-	BOTH_H1_S1_BR,	//# saber knocked up-left from BR parry
-	//Dual Saber parry anims
-	BOTH_P6_S6_T_,	//# Block shot/saber top
-	BOTH_P6_S6_TR,	//# Block shot/saber top right
-	BOTH_P6_S6_TL,	//# Block shot/saber top left
-	BOTH_P6_S6_BL,	//# Block shot/saber bottom left
-	BOTH_P6_S6_BR,	//# Block shot/saber bottom right
-	//Dual Saber knockaway
-	BOTH_K6_S6_T_,	//# knockaway saber top
-	BOTH_K6_S6_TR,	//# knockaway saber top right
-	BOTH_K6_S6_TL,	//# knockaway saber top left
-	BOTH_K6_S6_BL,	//# knockaway saber bottom left
-	BOTH_K6_S6_B_,	//# knockaway saber bottom
-	BOTH_K6_S6_BR,	//# knockaway saber bottom right
-	//Dual Saber attack knocked away
-	BOTH_V6_BR_S6,	//# BR attack knocked away
-	BOTH_V6__R_S6,	//# R attack knocked away
-	BOTH_V6_TR_S6,	//# TR attack knocked away
-	BOTH_V6_T__S6,	//# T attack knocked away
-	BOTH_V6_TL_S6,	//# TL attack knocked away
-	BOTH_V6__L_S6,	//# L attack knocked away
-	BOTH_V6_BL_S6,	//# BL attack knocked away
-	BOTH_V6_B__S6,	//# B attack knocked away
-	//Dual Saber parry broken
-	BOTH_H6_S6_T_,	//# saber knocked down from top parry
-	BOTH_H6_S6_TR,	//# saber knocked down-left from TR parry
-	BOTH_H6_S6_TL,	//# saber knocked down-right from TL parry
-	BOTH_H6_S6_BL,	//# saber knocked up-right from BL parry
-	BOTH_H6_S6_B_,	//# saber knocked up over head from ready?
-	BOTH_H6_S6_BR,	//# saber knocked up-left from BR parry
-	//SaberStaff parry anims
-	BOTH_P7_S7_T_,	//# Block shot/saber top
-	BOTH_P7_S7_TR,	//# Block shot/saber top right
-	BOTH_P7_S7_TL,	//# Block shot/saber top left
-	BOTH_P7_S7_BL,	//# Block shot/saber bottom left
-	BOTH_P7_S7_BR,	//# Block shot/saber bottom right
-	//SaberStaff knockaway
-	BOTH_K7_S7_T_,	//# knockaway saber top
-	BOTH_K7_S7_TR,	//# knockaway saber top right
-	BOTH_K7_S7_TL,	//# knockaway saber top left
-	BOTH_K7_S7_BL,	//# knockaway saber bottom left
-	BOTH_K7_S7_B_,	//# knockaway saber bottom
-	BOTH_K7_S7_BR,	//# knockaway saber bottom right
-	//SaberStaff attack knocked away
-	BOTH_V7_BR_S7,	//# BR attack knocked away
-	BOTH_V7__R_S7,	//# R attack knocked away
-	BOTH_V7_TR_S7,	//# TR attack knocked away
-	BOTH_V7_T__S7,	//# T attack knocked away
-	BOTH_V7_TL_S7,	//# TL attack knocked away
-	BOTH_V7__L_S7,	//# L attack knocked away
-	BOTH_V7_BL_S7,	//# BL attack knocked away
-	BOTH_V7_B__S7,	//# B attack knocked away
-	//SaberStaff parry broken
-	BOTH_H7_S7_T_,	//# saber knocked down from top parry
-	BOTH_H7_S7_TR,	//# saber knocked down-left from TR parry
-	BOTH_H7_S7_TL,	//# saber knocked down-right from TL parry
-	BOTH_H7_S7_BL,	//# saber knocked up-right from BL parry
-	BOTH_H7_S7_B_,	//# saber knocked up over head from ready?
-	BOTH_H7_S7_BR,	//# saber knocked up-left from BR parry
-	//Sabers locked anims
-	//* #sep BOTH_ SABER LOCKED ANIMS
-	//BOTH_(DL, S, ST)_(DL, S, ST)_(T, S)_(L, B, SB)_1(_W, _L)
-//===Single locks==================================================================
-//SINGLE vs. DUAL
-	//side locks - I'm using a single and they're using dual
-	BOTH_LK_S_DL_S_B_1_L,	//normal break I lost
-	BOTH_LK_S_DL_S_B_1_W,	//normal break I won
-	BOTH_LK_S_DL_S_L_1,		//lock if I'm using single vs. a dual
-	BOTH_LK_S_DL_S_SB_1_L,	//super break I lost
-	BOTH_LK_S_DL_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_S_DL_T_B_1_L,	//normal break I lost
-	BOTH_LK_S_DL_T_B_1_W,	//normal break I won
-	BOTH_LK_S_DL_T_L_1,		//lock if I'm using single vs. a dual
-	BOTH_LK_S_DL_T_SB_1_L,	//super break I lost
-	BOTH_LK_S_DL_T_SB_1_W,	//super break I won
-//SINGLE vs. STAFF
-	//side locks
-	BOTH_LK_S_ST_S_B_1_L,	//normal break I lost
-	BOTH_LK_S_ST_S_B_1_W,	//normal break I won
-	BOTH_LK_S_ST_S_L_1,		//lock if I'm using single vs. a staff
-	BOTH_LK_S_ST_S_SB_1_L,	//super break I lost
-	BOTH_LK_S_ST_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_S_ST_T_B_1_L,	//normal break I lost
-	BOTH_LK_S_ST_T_B_1_W,	//normal break I won
-	BOTH_LK_S_ST_T_L_1,		//lock if I'm using single vs. a staff
-	BOTH_LK_S_ST_T_SB_1_L,	//super break I lost
-	BOTH_LK_S_ST_T_SB_1_W,	//super break I won
-//SINGLE vs. SINGLE
-	//side locks
-	BOTH_LK_S_S_S_B_1_L,	//normal break I lost
-	BOTH_LK_S_S_S_B_1_W,	//normal break I won
-	BOTH_LK_S_S_S_L_1,		//lock if I'm using single vs. a single and I initiated
-	BOTH_LK_S_S_S_SB_1_L,	//super break I lost
-	BOTH_LK_S_S_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_S_S_T_B_1_L,	//normal break I lost
-	BOTH_LK_S_S_T_B_1_W,	//normal break I won
-	BOTH_LK_S_S_T_L_1,		//lock if I'm using single vs. a single and I initiated
-	BOTH_LK_S_S_T_SB_1_L,	//super break I lost
-	BOTH_LK_S_S_T_SB_1_W,	//super break I won
-//===Dual Saber locks==================================================================
-//DUAL vs. DUAL	
-	//side locks
-	BOTH_LK_DL_DL_S_B_1_L,	//normal break I lost
-	BOTH_LK_DL_DL_S_B_1_W,	//normal break I won
-	BOTH_LK_DL_DL_S_L_1,	//lock if I'm using dual vs. dual and I initiated
-	BOTH_LK_DL_DL_S_SB_1_L,	//super break I lost
-	BOTH_LK_DL_DL_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_DL_DL_T_B_1_L,	//normal break I lost
-	BOTH_LK_DL_DL_T_B_1_W,	//normal break I won
-	BOTH_LK_DL_DL_T_L_1,	//lock if I'm using dual vs. dual and I initiated
-	BOTH_LK_DL_DL_T_SB_1_L,	//super break I lost
-	BOTH_LK_DL_DL_T_SB_1_W,	//super break I won
-//DUAL vs. STAFF
-	//side locks
-	BOTH_LK_DL_ST_S_B_1_L,	//normal break I lost
-	BOTH_LK_DL_ST_S_B_1_W,	//normal break I won
-	BOTH_LK_DL_ST_S_L_1,	//lock if I'm using dual vs. a staff
-	BOTH_LK_DL_ST_S_SB_1_L,	//super break I lost
-	BOTH_LK_DL_ST_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_DL_ST_T_B_1_L,	//normal break I lost
-	BOTH_LK_DL_ST_T_B_1_W,	//normal break I won
-	BOTH_LK_DL_ST_T_L_1,	//lock if I'm using dual vs. a staff
-	BOTH_LK_DL_ST_T_SB_1_L,	//super break I lost
-	BOTH_LK_DL_ST_T_SB_1_W,	//super break I won
-//DUAL vs. SINGLE
-	//side locks
-	BOTH_LK_DL_S_S_B_1_L,	//normal break I lost
-	BOTH_LK_DL_S_S_B_1_W,	//normal break I won
-	BOTH_LK_DL_S_S_L_1,		//lock if I'm using dual vs. a single
-	BOTH_LK_DL_S_S_SB_1_L,	//super break I lost
-	BOTH_LK_DL_S_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_DL_S_T_B_1_L,	//normal break I lost
-	BOTH_LK_DL_S_T_B_1_W,	//normal break I won
-	BOTH_LK_DL_S_T_L_1,		//lock if I'm using dual vs. a single
-	BOTH_LK_DL_S_T_SB_1_L,	//super break I lost
-	BOTH_LK_DL_S_T_SB_1_W,	//super break I won
-//===Saber Staff locks==================================================================
-//STAFF vs. DUAL
-	//side locks
-	BOTH_LK_ST_DL_S_B_1_L,	//normal break I lost
-	BOTH_LK_ST_DL_S_B_1_W,	//normal break I won
-	BOTH_LK_ST_DL_S_L_1,	//lock if I'm using staff vs. dual
-	BOTH_LK_ST_DL_S_SB_1_L,	//super break I lost
-	BOTH_LK_ST_DL_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_ST_DL_T_B_1_L,	//normal break I lost
-	BOTH_LK_ST_DL_T_B_1_W,	//normal break I won
-	BOTH_LK_ST_DL_T_L_1,	//lock if I'm using staff vs. dual
-	BOTH_LK_ST_DL_T_SB_1_L,	//super break I lost
-	BOTH_LK_ST_DL_T_SB_1_W,	//super break I won
-//STAFF vs. STAFF
-	//side locks
-	BOTH_LK_ST_ST_S_B_1_L,	//normal break I lost
-	BOTH_LK_ST_ST_S_B_1_W,	//normal break I won
-	BOTH_LK_ST_ST_S_L_1,	//lock if I'm using staff vs. a staff and I initiated
-	BOTH_LK_ST_ST_S_SB_1_L,	//super break I lost
-	BOTH_LK_ST_ST_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_ST_ST_T_B_1_L,	//normal break I lost
-	BOTH_LK_ST_ST_T_B_1_W,	//normal break I won
-	BOTH_LK_ST_ST_T_L_1,	//lock if I'm using staff vs. a staff and I initiated
-	BOTH_LK_ST_ST_T_SB_1_L,	//super break I lost
-	BOTH_LK_ST_ST_T_SB_1_W,	//super break I won
-//STAFF vs. SINGLE
-	//side locks
-	BOTH_LK_ST_S_S_B_1_L,	//normal break I lost
-	BOTH_LK_ST_S_S_B_1_W,	//normal break I won
-	BOTH_LK_ST_S_S_L_1,		//lock if I'm using staff vs. a single
-	BOTH_LK_ST_S_S_SB_1_L,	//super break I lost
-	BOTH_LK_ST_S_S_SB_1_W,	//super break I won
-	//top locks
-	BOTH_LK_ST_S_T_B_1_L,	//normal break I lost
-	BOTH_LK_ST_S_T_B_1_W,	//normal break I won
-	BOTH_LK_ST_S_T_L_1,		//lock if I'm using staff vs. a single
-	BOTH_LK_ST_S_T_SB_1_L,	//super break I lost
-	BOTH_LK_ST_S_T_SB_1_W,	//super break I won
-//Special cases for same saber style vs. each other (won't fit in nice 5-anim size lists above)
-	BOTH_LK_S_S_S_L_2,		//lock if I'm using single vs. a single and other intitiated
-	BOTH_LK_S_S_T_L_2,		//lock if I'm using single vs. a single and other initiated
-	BOTH_LK_DL_DL_S_L_2,	//lock if I'm using dual vs. dual and other initiated
-	BOTH_LK_DL_DL_T_L_2,	//lock if I'm using dual vs. dual and other initiated
-	BOTH_LK_ST_ST_S_L_2,	//lock if I'm using staff vs. a staff and other initiated
-	BOTH_LK_ST_ST_T_L_2,	//lock if I'm using staff vs. a staff and other initiated
-//===End Saber locks==================================================================
-	//old locks
-	BOTH_BF2RETURN,	//#
-	BOTH_BF2BREAK,	//#
-	BOTH_BF2LOCK,	//#
-	BOTH_BF1RETURN,	//#
-	BOTH_BF1BREAK,	//#
-	BOTH_BF1LOCK,	//#
-	BOTH_CWCIRCLE_R2__R_S1,	//#
-	BOTH_CCWCIRCLE_R2__L_S1,	//#
-	BOTH_CWCIRCLE_A2__L__R,	//#
-	BOTH_CCWCIRCLE_A2__R__L,	//#
-	BOTH_CWCIRCLEBREAK,	//#
-	BOTH_CCWCIRCLEBREAK,	//#
-	BOTH_CWCIRCLELOCK,	//#
-	BOTH_CCWCIRCLELOCK,	//#
-	//other saber anims
-	//* #sep BOTH_ SABER MISC ANIMS
-	BOTH_SABERFAST_STANCE,
-	BOTH_SABERSLOW_STANCE,
-	BOTH_SABERDUAL_STANCE,
-	BOTH_SABERSTAFF_STANCE,
-	BOTH_A2_STABBACK1,		//# Stab saber backward
-	BOTH_ATTACK_BACK,		//# Swing around backwards and attack
-	BOTH_JUMPFLIPSLASHDOWN1,//#
-	BOTH_JUMPFLIPSTABDOWN,//#
-	BOTH_FORCELEAP2_T__B_,//#
-	BOTH_LUNGE2_B__T_,//#
-	BOTH_CROUCHATTACKBACK1,//#
-	//New specials for JKA:
-	BOTH_JUMPATTACK6,//#
-	BOTH_JUMPATTACK7,//#
-	BOTH_SPINATTACK6,//#
-	BOTH_SPINATTACK7,//#
-	BOTH_S1_S6,//#	From stand1 to saberdual stance - turning on your dual sabers
-	BOTH_S6_S1,//#	From dualstaff stance to stand1 - turning off your dual sabers
-	BOTH_S1_S7,//#	From stand1 to saberstaff stance - turning on your saberstaff
-	BOTH_S7_S1,//#	From saberstaff stance to stand1 - turning off your saberstaff
-	BOTH_FORCELONGLEAP_START,
-	BOTH_FORCELONGLEAP_ATTACK,
-	BOTH_FORCELONGLEAP_LAND,
-	BOTH_FORCEWALLRUNFLIP_START,
-	BOTH_FORCEWALLRUNFLIP_END,
-	BOTH_FORCEWALLRUNFLIP_ALT,
-	BOTH_FORCEWALLREBOUND_FORWARD,
-	BOTH_FORCEWALLREBOUND_LEFT,
-	BOTH_FORCEWALLREBOUND_BACK,
-	BOTH_FORCEWALLREBOUND_RIGHT,
-	BOTH_FORCEWALLHOLD_FORWARD,
-	BOTH_FORCEWALLHOLD_LEFT,
-	BOTH_FORCEWALLHOLD_BACK,
-	BOTH_FORCEWALLHOLD_RIGHT,
-	BOTH_FORCEWALLRELEASE_FORWARD,
-	BOTH_FORCEWALLRELEASE_LEFT,
-	BOTH_FORCEWALLRELEASE_BACK,
-	BOTH_FORCEWALLRELEASE_RIGHT,
-	BOTH_A7_KICK_F,
-	BOTH_A7_KICK_B,
-	BOTH_A7_KICK_R,
-	BOTH_A7_KICK_L,
-	BOTH_A7_KICK_S,
-	BOTH_A7_KICK_BF,
-	BOTH_A7_KICK_BF_STOP,
-	BOTH_A7_KICK_RL,
-	BOTH_A7_KICK_F_AIR,
-	BOTH_A7_KICK_B_AIR,
-	BOTH_A7_KICK_R_AIR,
-	BOTH_A7_KICK_L_AIR,
-	BOTH_FLIP_ATTACK7,
-	BOTH_FLIP_HOLD7,
-	BOTH_FLIP_LAND,
-	BOTH_PULL_IMPALE_STAB,
-	BOTH_PULL_IMPALE_SWING,
-	BOTH_PULLED_INAIR_B,
-	BOTH_PULLED_INAIR_F,
-	BOTH_STABDOWN,
-	BOTH_STABDOWN_STAFF,
-	BOTH_STABDOWN_DUAL,
-	BOTH_A6_SABERPROTECT,
-	BOTH_A7_SOULCAL,
-	BOTH_A1_SPECIAL,
-	BOTH_A2_SPECIAL,
-	BOTH_A3_SPECIAL,
-	BOTH_ROLL_STAB,
-
-	//# #sep BOTH_ STANDING
-	BOTH_STAND1,			//# Standing idle, no weapon, hands down
-	BOTH_STAND1IDLE1,		//# Random standing idle
-	BOTH_STAND2,			//# Standing idle with a saber
-	BOTH_STAND2IDLE1,		//# Random standing idle
-	BOTH_STAND2IDLE2,		//# Random standing idle
-	BOTH_STAND3,			//# Standing idle with 2-handed weapon
-	BOTH_STAND3IDLE1,		//# Random standing idle
-	BOTH_STAND4,			//# hands clasp behind back
-	BOTH_STAND5,			//# standing idle, no weapon, hand down, back straight
-	BOTH_STAND5IDLE1,		//# Random standing idle
-	BOTH_STAND6,			//# one handed, gun at side, relaxed stand
-	BOTH_STAND8,			//# both hands on hips (male)
-	BOTH_STAND1TO2,			//# Transition from stand1 to stand2
-	BOTH_STAND2TO1,			//# Transition from stand2 to stand1
-	BOTH_STAND2TO4,			//# Transition from stand2 to stand4
-	BOTH_STAND4TO2,			//# Transition from stand4 to stand2
-	BOTH_STAND4TOATTACK2,	//# relaxed stand to 1-handed pistol ready
-	BOTH_STANDUP2,			//# Luke standing up from his meditation platform (cin # 37)
-	BOTH_STAND5TOSIT3,		//# transition from stand 5 to sit 3
-	BOTH_STAND1TOSTAND5,	//# Transition from stand1 to stand5
-	BOTH_STAND5TOSTAND1,	//# Transition from stand5 to stand1
-	BOTH_STAND5TOAIM,		//# Transition of Kye aiming his gun at Desann (cin #9) 
-	BOTH_STAND5STARTLEDLOOKLEFT,	//# Kyle turning to watch the bridge drop (cin #9) 
-	BOTH_STARTLEDLOOKLEFTTOSTAND5,	//# Kyle returning to stand 5 from watching the bridge drop (cin #9) 
-	BOTH_STAND5TOSTAND8,	//# Transition from stand5 to stand8
-	BOTH_STAND7TOSTAND8,	//# Tavion putting hands on back of chair (cin #11)
-	BOTH_STAND8TOSTAND5,	//# Transition from stand8 to stand5
-	BOTH_STAND9,			//# Kyle's standing idle, no weapon, hands down
-	BOTH_STAND9IDLE1,		//# Kyle's random standing idle
-	BOTH_STAND5SHIFTWEIGHT,	//# Weightshift from stand5 to side and back to stand5
-	BOTH_STAND5SHIFTWEIGHTSTART,	//# From stand5 to side
-	BOTH_STAND5SHIFTWEIGHTSTOP,		//# From side to stand5
-	BOTH_STAND5TURNLEFTSTART,		//# Start turning left from stand5
-	BOTH_STAND5TURNLEFTSTOP,		//# Stop turning left from stand5
-	BOTH_STAND5TURNRIGHTSTART,		//# Start turning right from stand5
-	BOTH_STAND5TURNRIGHTSTOP,		//# Stop turning right from stand5
-	BOTH_STAND5LOOK180LEFTSTART,	//# Start looking over left shoulder (cin #17)
-	BOTH_STAND5LOOK180LEFTSTOP,	//# Stop looking over left shoulder (cin #17)
-
-	BOTH_CONSOLE1START,		//# typing at a console
-	BOTH_CONSOLE1,			//# typing at a console
-	BOTH_CONSOLE1STOP,		//# typing at a console
-	BOTH_CONSOLE2START,		//# typing at a console with comm link in hand (cin #5) 
-	BOTH_CONSOLE2,			//# typing at a console with comm link in hand (cin #5) 
-	BOTH_CONSOLE2STOP,		//# typing at a console with comm link in hand (cin #5) 
-	BOTH_CONSOLE2HOLDCOMSTART,	//# lean in to type at console while holding comm link in hand (cin #5) 
-	BOTH_CONSOLE2HOLDCOMSTOP,	//# lean away after typing at console while holding comm link in hand (cin #5) 
-
-	BOTH_GUARD_LOOKAROUND1,	//# Cradling weapon and looking around
-	BOTH_GUARD_IDLE1,		//# Cradling weapon and standing
-	BOTH_GESTURE1,			//# Generic gesture, non-specific
-	BOTH_GESTURE2,			//# Generic gesture, non-specific
-	BOTH_WALK1TALKCOMM1,	//# Talking into coom link while walking
-	BOTH_TALK1,				//# Generic talk anim
-	BOTH_TALK2,				//# Generic talk anim
-	BOTH_TALKCOMM1START,	//# Start talking into a comm link
-	BOTH_TALKCOMM1,			//# Talking into a comm link
-	BOTH_TALKCOMM1STOP,		//# Stop talking into a comm link
-	BOTH_TALKGESTURE1,		//# Generic talk anim
-	
-	BOTH_HEADTILTLSTART,		//# Head tilt to left
-	BOTH_HEADTILTLSTOP,			//# Head tilt to left
-	BOTH_HEADTILTRSTART,		//# Head tilt to right
-	BOTH_HEADTILTRSTOP,			//# Head tilt to right
-	BOTH_HEADNOD,				//# Head shake YES
-	BOTH_HEADSHAKE,				//# Head shake NO
-	BOTH_SIT2HEADTILTLSTART,	//# Head tilt to left from seated position 2
-	BOTH_SIT2HEADTILTLSTOP,		//# Head tilt to left from seated position 2
- 
-	BOTH_REACH1START,		//# Monmothma reaching for crystal
-	BOTH_REACH1STOP,		//# Monmothma reaching for crystal
-
-	BOTH_COME_ON1,				//# Jan gesturing to Kyle (cin #32a)
-	BOTH_STEADYSELF1,			//# Jan trying to keep footing (cin #32a)
-	BOTH_STEADYSELF1END,		//# Return hands to side from STEADSELF1 Kyle (cin#5)
-	BOTH_SILENCEGESTURE1,		//# Luke silencing Kyle with a raised hand (cin #37)
-	BOTH_REACHFORSABER1,		//# Luke holding hand out for Kyle's saber (cin #37)
-	BOTH_SABERKILLER1,			//# Tavion about to strike Jan with saber (cin #9)
-	BOTH_SABERKILLEE1,			//# Jan about to be struck by Tavion with saber (cin #9)
-	BOTH_HUGGER1,			//# Kyle hugging Jan (cin #29)
-	BOTH_HUGGERSTOP1,		//# Kyle stop hugging Jan but don't let her go (cin #29)
-	BOTH_HUGGEE1,			//# Jan being hugged (cin #29)
-	BOTH_HUGGEESTOP1,		//# Jan stop being hugged but don't let go (cin #29)
-
-	BOTH_SABERTHROW1START,		//# Desann throwing his light saber (cin #26)
-	BOTH_SABERTHROW1STOP,		//# Desann throwing his light saber (cin #26)
-	BOTH_SABERTHROW2START,		//# Kyle throwing his light saber (cin #32)
-	BOTH_SABERTHROW2STOP,		//# Kyle throwing his light saber (cin #32)
-
-	//# #sep BOTH_ SITTING/CROUCHING
-	BOTH_SIT1,				//# Normal chair sit.
-	BOTH_SIT2,				//# Lotus position.
-	BOTH_SIT3,				//# Sitting in tired position, elbows on knees
-
-	BOTH_SIT2TOSTAND5,		//# Transition from sit 2 to stand 5
-	BOTH_STAND5TOSIT2,		//# Transition from stand 5 to sit 2
-	BOTH_SIT2TOSIT4,		//# Trans from sit2 to sit4 (cin #12) Luke leaning back from lotus position.
-	BOTH_SIT3TOSTAND5,		//# transition from sit 3 to stand 5
-
-	BOTH_CROUCH1,			//# Transition from standing to crouch
-	BOTH_CROUCH1IDLE,		//# Crouching idle
-	BOTH_CROUCH1WALK,		//# Walking while crouched
-	BOTH_CROUCH1WALKBACK,	//# Walking while crouched
-	BOTH_UNCROUCH1,			//# Transition from crouch to standing
-	BOTH_CROUCH2TOSTAND1,	//# going from crouch2 to stand1
-	BOTH_CROUCH3,			//# Desann crouching down to Kyle (cin 9)
-	BOTH_UNCROUCH3,			//# Desann uncrouching down to Kyle (cin 9)
-	BOTH_CROUCH4,			//# Slower version of crouch1 for cinematics
-	BOTH_UNCROUCH4,			//# Slower version of uncrouch1 for cinematics
-
-	BOTH_GUNSIT1,			//# sitting on an emplaced gun.
-
-	// Swoop Vehicle animations.
-	//* #sep BOTH_ SWOOP ANIMS
-	BOTH_VS_MOUNT_L,			//# Mount from left		
-	BOTH_VS_DISMOUNT_L,			//# Dismount to left		
-	BOTH_VS_MOUNT_R,			//# Mount from  right (symmetry)		
-	BOTH_VS_DISMOUNT_R,			//# DISMOUNT TO  RIGHT (SYMMETRY)		
-
-	BOTH_VS_MOUNTJUMP_L,		//#
-	BOTH_VS_MOUNTTHROW,			//# Land on an occupied vehicle & throw off current pilot
-	BOTH_VS_MOUNTTHROW_L,		//# Land on an occupied vehicle & throw off current pilot
-	BOTH_VS_MOUNTTHROW_R,		//# Land on an occupied vehicle & throw off current pilot
-	BOTH_VS_MOUNTTHROWEE,		//# Current pilot getting thrown off by another guy
-
-	BOTH_VS_LOOKLEFT,			//# Turn & Look behind and to the left (no weapon)		
-	BOTH_VS_LOOKRIGHT,			//# Turn & Look behind and to the right (no weapon)		
-
-	BOTH_VS_TURBO,				//# Hit The Turbo Button
-
-	BOTH_VS_REV,				//# Player looks back as swoop reverses		
-
-	BOTH_VS_AIR,				//# Player stands up when swoop is airborn		
-	BOTH_VS_AIR_G,				//# "" with Gun
-	BOTH_VS_AIR_SL,				//# "" with Saber Left
-	BOTH_VS_AIR_SR,				//# "" with Saber Right
-
-	BOTH_VS_LAND,				//# Player bounces down when swoop lands		
-	BOTH_VS_LAND_G,				//#  "" with Gun
-	BOTH_VS_LAND_SL,			//#  "" with Saber Left
-	BOTH_VS_LAND_SR,			//#  "" with Saber Right
-
-	BOTH_VS_IDLE,				//# Sit
-	BOTH_VS_IDLE_G,				//# Sit (gun)
-	BOTH_VS_IDLE_SL,			//# Sit (saber left)		
-	BOTH_VS_IDLE_SR,			//# Sit (saber right)		
-
-	BOTH_VS_LEANL,				//# Lean left
-	BOTH_VS_LEANL_G,			//# Lean left (gun)		
-	BOTH_VS_LEANL_SL,			//# Lean left (saber left)		
-	BOTH_VS_LEANL_SR,			//# Lean left (saber right)		
-
-	BOTH_VS_LEANR,				//# Lean right		
-	BOTH_VS_LEANR_G,			//# Lean right (gun)		
-	BOTH_VS_LEANR_SL,			//# Lean right (saber left)		
-	BOTH_VS_LEANR_SR,			//# Lean right (saber right)		
-				
-	BOTH_VS_ATL_S,				//# Attack left with saber		
-	BOTH_VS_ATR_S,				//# Attack right with saber		
-	BOTH_VS_ATR_TO_L_S,			//# Attack toss saber from right to left hand
-	BOTH_VS_ATL_TO_R_S,			//# Attack toss saber from left to right hand
-	BOTH_VS_ATR_G,				//# Attack right with gun (90)		
-	BOTH_VS_ATL_G,				//# Attack left with gun (90)		
-	BOTH_VS_ATF_G,				//# Attack forward with gun		
-
-	BOTH_VS_PAIN1,				//# Pain
-
-	// Added 12/04/02 by Aurelio.
-	//* #sep BOTH_ TAUNTAUN ANIMS
-	BOTH_VT_MOUNT_L,		//# Mount from left	
-	BOTH_VT_MOUNT_R,		//# Mount from right
-	BOTH_VT_MOUNT_B,		//# Mount from air, behind
-	BOTH_VT_DISMOUNT,		//# Dismount for tauntaun
-	BOTH_VT_DISMOUNT_L,		//# Dismount to tauntauns left	
-	BOTH_VT_DISMOUNT_R,		//# Dismount to tauntauns right (symmetry)	
-
-	BOTH_VT_WALK_FWD,		//# Walk forward	
-	BOTH_VT_WALK_REV,		//# Walk backward	
-	BOTH_VT_WALK_FWD_L,		//# walk lean left
-	BOTH_VT_WALK_FWD_R,		//# Walk lean right
-	BOTH_VT_RUN_FWD,		//# Run forward	
-	BOTH_VT_RUN_REV,		//# Look backwards while running (not weapon specific)	
-	BOTH_VT_RUN_FWD_L,		//# Run lean left
-	BOTH_VT_RUN_FWD_R,		//# Run lean right
-
-	BOTH_VT_SLIDEF,			//# Tauntaun slides forward with abrupt stop	
-	BOTH_VT_AIR,			//# Tauntaun jump	
-	BOTH_VT_ATB,			//# Tauntaun tail swipe	
-	BOTH_VT_PAIN1,			//# Pain	
-	BOTH_VT_DEATH1,			//# Die	
-	BOTH_VT_STAND,			//# Stand still and breath	
-	BOTH_VT_BUCK,			//# Tauntaun bucking loop animation	
-
-	BOTH_VT_LAND,			//# Player bounces down when tauntaun lands	
-	BOTH_VT_TURBO,			//# Hit The Turbo Button
-	BOTH_VT_IDLE_SL,		//# Sit (saber left)		
-	BOTH_VT_IDLE_SR,		//# Sit (saber right)		
-
-	BOTH_VT_IDLE,			//# Sit with no weapon selected	
-	BOTH_VT_IDLE1,			//# Sit with no weapon selected	
-	BOTH_VT_IDLE_S,			//# Sit with saber selected	
-	BOTH_VT_IDLE_G,			//# Sit with gun selected	
-	BOTH_VT_IDLE_T,			//# Sit with thermal grenade selected
-
-	BOTH_VT_ATL_S,			//# Attack left with saber	
-	BOTH_VT_ATR_S,			//# Attack right with saber	
-	BOTH_VT_ATR_TO_L_S,		//# Attack toss saber from right to left hand
-	BOTH_VT_ATL_TO_R_S,		//# Attack toss saber from left to right hand
-	BOTH_VT_ATR_G,			//# Attack right with gun (90)	
-	BOTH_VT_ATL_G,			//# Attack left with gun (90)	
-	BOTH_VT_ATF_G,			//# Attack forward with gun	
-
-
-	// Added 2/26/02 by Aurelio.
-	//* #sep BOTH_ FIGHTER ANIMS
-	BOTH_GEARS_OPEN,
-	BOTH_GEARS_CLOSE,
-	BOTH_WINGS_OPEN,
-	BOTH_WINGS_CLOSE,
-
-	BOTH_DEATH14_UNGRIP,	//# Desann's end death (cin #35)
-	BOTH_DEATH14_SITUP,		//# Tavion sitting up after having been thrown (cin #23)
-	BOTH_KNEES1,			//# Tavion on her knees
-	BOTH_KNEES2,			//# Tavion on her knees looking down
-	BOTH_KNEES2TO1,			//# Transition of KNEES2 to KNEES1
-
-	//# #sep BOTH_ MOVING
-	BOTH_WALK1,				//# Normal walk
-	BOTH_WALK2,				//# Normal walk
-	BOTH_WALK_STAFF,		//# Walk with saberstaff turned on
-	BOTH_WALKBACK_STAFF,	//# Walk backwards with saberstaff turned on
-	BOTH_WALK_DUAL,			//# Walk with dual turned on
-	BOTH_WALKBACK_DUAL,		//# Walk backwards with dual turned on
-	BOTH_WALK5,				//# Tavion taunting Kyle (cin 22)
-	BOTH_WALK6,				//# Slow walk for Luke (cin 12)
-	BOTH_WALK7,				//# Fast walk
-	BOTH_RUN1,				//# Full run
-	BOTH_RUN1START,			//# Start into full run1
-	BOTH_RUN1STOP,			//# Stop from full run1
-	BOTH_RUN2,				//# Full run
-	BOTH_RUN1TORUN2,		//# Wampa run anim transition
-	BOTH_RUN2TORUN1,		//# Wampa run anim transition
-	BOTH_RUN4,				//# Jawa Run
-	BOTH_RUN_STAFF,			//# Run with saberstaff turned on
-	BOTH_RUNBACK_STAFF,		//# Run backwards with saberstaff turned on
-	BOTH_RUN_DUAL,			//# Run with dual turned on
-	BOTH_RUNBACK_DUAL,		//# Run backwards with dual turned on
-	BOTH_STRAFE_LEFT1,		//# Sidestep left, should loop
-	BOTH_STRAFE_RIGHT1,		//# Sidestep right, should loop
-	BOTH_RUNSTRAFE_LEFT1,	//# Sidestep left, should loop
-	BOTH_RUNSTRAFE_RIGHT1,	//# Sidestep right, should loop
-	BOTH_TURN_LEFT1,		//# Turn left, should loop
-	BOTH_TURN_RIGHT1,		//# Turn right, should loop
-	BOTH_TURNSTAND1,		//# Turn from STAND1 position
-	BOTH_TURNSTAND2,		//# Turn from STAND2 position
-	BOTH_TURNSTAND3,		//# Turn from STAND3 position
-	BOTH_TURNSTAND4,		//# Turn from STAND4 position
-	BOTH_TURNSTAND5,		//# Turn from STAND5 position
-	BOTH_TURNCROUCH1,		//# Turn from CROUCH1 position
-
-	BOTH_WALKBACK1,			//# Walk1 backwards
-	BOTH_WALKBACK2,			//# Walk2 backwards
-	BOTH_RUNBACK1,			//# Run1 backwards
-	BOTH_RUNBACK2,			//# Run1 backwards
-	
-	//# #sep BOTH_ JUMPING
-	BOTH_JUMP1,				//# Jump - wind-up and leave ground
-	BOTH_INAIR1,			//# In air loop (from jump)
-	BOTH_LAND1,				//# Landing (from in air loop)
-	BOTH_LAND2,				//# Landing Hard (from a great height)
-
-	BOTH_JUMPBACK1,			//# Jump backwards - wind-up and leave ground
-	BOTH_INAIRBACK1,		//# In air loop (from jump back)
-	BOTH_LANDBACK1,			//# Landing backwards(from in air loop)
-
-	BOTH_JUMPLEFT1,			//# Jump left - wind-up and leave ground
-	BOTH_INAIRLEFT1,		//# In air loop (from jump left)
-	BOTH_LANDLEFT1,			//# Landing left(from in air loop)
-
-	BOTH_JUMPRIGHT1,		//# Jump right - wind-up and leave ground
-	BOTH_INAIRRIGHT1,		//# In air loop (from jump right)
-	BOTH_LANDRIGHT1,		//# Landing right(from in air loop)
-
-	BOTH_FORCEJUMP1,		//# Jump - wind-up and leave ground
-	BOTH_FORCEINAIR1,		//# In air loop (from jump)
-	BOTH_FORCELAND1,		//# Landing (from in air loop)
-
-	BOTH_FORCEJUMPBACK1,	//# Jump backwards - wind-up and leave ground
-	BOTH_FORCEINAIRBACK1,	//# In air loop (from jump back)
-	BOTH_FORCELANDBACK1,	//# Landing backwards(from in air loop)
-
-	BOTH_FORCEJUMPLEFT1,	//# Jump left - wind-up and leave ground
-	BOTH_FORCEINAIRLEFT1,	//# In air loop (from jump left)
-	BOTH_FORCELANDLEFT1,	//# Landing left(from in air loop)
-
-	BOTH_FORCEJUMPRIGHT1,	//# Jump right - wind-up and leave ground
-	BOTH_FORCEINAIRRIGHT1,	//# In air loop (from jump right)
-	BOTH_FORCELANDRIGHT1,	//# Landing right(from in air loop)
-	//# #sep BOTH_ ACROBATICS
-	BOTH_FLIP_F,			//# Flip forward
-	BOTH_FLIP_B,			//# Flip backwards
-	BOTH_FLIP_L,			//# Flip left
-	BOTH_FLIP_R,			//# Flip right
-
-	BOTH_ROLL_F,			//# Roll forward
-	BOTH_ROLL_B,			//# Roll backward
-	BOTH_ROLL_L,			//# Roll left
-	BOTH_ROLL_R,			//# Roll right
-
-	BOTH_HOP_F,				//# quickstep forward
-	BOTH_HOP_B,				//# quickstep backwards
-	BOTH_HOP_L,				//# quickstep left
-	BOTH_HOP_R,				//# quickstep right
-
-	BOTH_DODGE_FL,			//# lean-dodge forward left
-	BOTH_DODGE_FR,			//# lean-dodge forward right
-	BOTH_DODGE_BL,			//# lean-dodge backwards left
-	BOTH_DODGE_BR,			//# lean-dodge backwards right
-	BOTH_DODGE_L,			//# lean-dodge left
-	BOTH_DODGE_R,			//# lean-dodge right
-	BOTH_DODGE_HOLD_FL,			//# lean-dodge pose forward left
-	BOTH_DODGE_HOLD_FR,			//# lean-dodge pose forward right
-	BOTH_DODGE_HOLD_BL,			//# lean-dodge pose backwards left
-	BOTH_DODGE_HOLD_BR,			//# lean-dodge pose backwards right
-	BOTH_DODGE_HOLD_L,			//# lean-dodge pose left
-	BOTH_DODGE_HOLD_R,			//# lean-dodge pose right
-
-	//MP taunt anims
-	BOTH_ENGAGETAUNT,
-	BOTH_BOW,
-	BOTH_MEDITATE,
-	BOTH_MEDITATE_END,
-	BOTH_SHOWOFF_FAST,
-	BOTH_SHOWOFF_MEDIUM,
-	BOTH_SHOWOFF_STRONG,
-	BOTH_SHOWOFF_DUAL,
-	BOTH_SHOWOFF_STAFF,
-	BOTH_VICTORY_FAST,
-	BOTH_VICTORY_MEDIUM,
-	BOTH_VICTORY_STRONG,
-	BOTH_VICTORY_DUAL,
-	BOTH_VICTORY_STAFF,
-	//other saber/acro anims
-	BOTH_ARIAL_LEFT,		//# 
-	BOTH_ARIAL_RIGHT,		//# 
-	BOTH_CARTWHEEL_LEFT,	//# 
-	BOTH_CARTWHEEL_RIGHT,	//# 
-	BOTH_FLIP_LEFT,			//# 
-	BOTH_FLIP_BACK1,		//# 
-	BOTH_FLIP_BACK2,		//# 
-	BOTH_FLIP_BACK3,		//# 
-	BOTH_BUTTERFLY_LEFT,	//# 
-	BOTH_BUTTERFLY_RIGHT,	//# 
-	BOTH_WALL_RUN_RIGHT,	//# 
-	BOTH_WALL_RUN_RIGHT_FLIP,//#
-	BOTH_WALL_RUN_RIGHT_STOP,//# 
-	BOTH_WALL_RUN_LEFT,		//# 
-	BOTH_WALL_RUN_LEFT_FLIP,//#
-	BOTH_WALL_RUN_LEFT_STOP,//# 
-	BOTH_WALL_FLIP_RIGHT,	//# 
-	BOTH_WALL_FLIP_LEFT,	//# 
-	BOTH_KNOCKDOWN1,		//# knocked backwards
-	BOTH_KNOCKDOWN2,		//# knocked backwards hard
-	BOTH_KNOCKDOWN3,		//#	knocked forwards
-	BOTH_KNOCKDOWN4,		//# knocked backwards from crouch
-	BOTH_KNOCKDOWN5,		//# dupe of 3 - will be removed
-	BOTH_GETUP1,			//#
-	BOTH_GETUP2,			//#
-	BOTH_GETUP3,			//#
-	BOTH_GETUP4,			//#
-	BOTH_GETUP5,			//#
-	BOTH_GETUP_CROUCH_F1,	//#
-	BOTH_GETUP_CROUCH_B1,	//#
-	BOTH_FORCE_GETUP_F1,	//#
-	BOTH_FORCE_GETUP_F2,	//#
-	BOTH_FORCE_GETUP_B1,	//#
-	BOTH_FORCE_GETUP_B2,	//#
-	BOTH_FORCE_GETUP_B3,	//#
-	BOTH_FORCE_GETUP_B4,	//#
-	BOTH_FORCE_GETUP_B5,	//#
-	BOTH_FORCE_GETUP_B6,	//#
-	BOTH_GETUP_BROLL_B,	//#
-	BOTH_GETUP_BROLL_F,	//#
-	BOTH_GETUP_BROLL_L,	//#
-	BOTH_GETUP_BROLL_R,	//#
-	BOTH_GETUP_FROLL_B,	//#
-	BOTH_GETUP_FROLL_F,	//#
-	BOTH_GETUP_FROLL_L,	//#
-	BOTH_GETUP_FROLL_R,	//#
-	BOTH_WALL_FLIP_BACK1,	//#
-	BOTH_WALL_FLIP_BACK2,	//#
-	BOTH_SPIN1,				//#
-	BOTH_CEILING_CLING,		//# clinging to ceiling
-	BOTH_CEILING_DROP,		//# dropping from ceiling cling
-
-	//TESTING
-	BOTH_FJSS_TR_BL,		//# jump spin slash tr to bl
-	BOTH_FJSS_TL_BR,		//# jump spin slash bl to tr
-	BOTH_RIGHTHANDCHOPPEDOFF,//#
-	BOTH_DEFLECTSLASH__R__L_FIN,//#
-	BOTH_BASHED1,//#
-	BOTH_ARIAL_F1,//#
-	BOTH_BUTTERFLY_FR1,//#
-	BOTH_BUTTERFLY_FL1,//#
-
-	//NEW SABER/JEDI/FORCE ANIMS
-	BOTH_BACK_FLIP_UP,	//# back flip up Bonus Animation!!!!	
-	BOTH_LOSE_SABER,	//# player losing saber (pulled from hand by force pull 4 - Kyle?)
-	BOTH_STAFF_TAUNT,	//# taunt saberstaff			
-	BOTH_DUAL_TAUNT,		//# taunt dual
-	BOTH_A6_FB,				//# dual attack front/back		
-	BOTH_A6_LR,				//# dual attack left/right
-	BOTH_A7_HILT,			//# saber knock (alt + stand still)
-	//Alora			
-	BOTH_ALORA_SPIN,		//#jump spin attack	death ballet	
-	BOTH_ALORA_FLIP_1,		//# gymnast move 1		
-	BOTH_ALORA_FLIP_2,		//# gymnast move 2		
-	BOTH_ALORA_FLIP_3,		//# gymnast move3		
-	BOTH_ALORA_FLIP_B,		//# gymnast move back		
-	BOTH_ALORA_SPIN_THROW,	//# dual saber throw		
-	BOTH_ALORA_SPIN_SLASH,	//# spin slash	special bonus animation!! :)	
-	BOTH_ALORA_TAUNT,		//# special taunt
-	//Rosh (Kothos battle)			
-	BOTH_ROSH_PAIN,	//# hurt animation (exhausted)		
-	BOTH_ROSH_HEAL,	//# healed/rejuvenated		
-	//Tavion			
-	BOTH_TAVION_SCEPTERGROUND, //# stabbing ground with sith sword shoots electricity everywhere
-	BOTH_TAVION_SWORDPOWER,//# Tavion doing the He-Man(tm) thing
-	BOTH_SCEPTER_START,	//#Point scepter and attack start
-	BOTH_SCEPTER_HOLD,	//#Point scepter and attack hold
-	BOTH_SCEPTER_STOP,	//#Point scepter and attack stop
-	//Kyle Boss			
-	BOTH_KYLE_GRAB,		//# grab
-	BOTH_KYLE_MISS,		//# miss
-	BOTH_KYLE_PA_1,		//# hold 1
-	BOTH_PLAYER_PA_1,	//# player getting held 1
-	BOTH_KYLE_PA_2,		//# hold 2
-	BOTH_PLAYER_PA_2,	//# player getting held 2
-	BOTH_PLAYER_PA_FLY,	//# player getting knocked back from punch at end of hold 1
-	BOTH_KYLE_PA_3,		//# hold 3
-	BOTH_PLAYER_PA_3,	//# player getting held 3
-	BOTH_PLAYER_PA_3_FLY,//# player getting thrown at end of hold 3
-	//Rancor
-	BOTH_BUCK_RIDER,	//# Rancor bucks when someone is on him
-	//WAMPA Grabbing enemy
-	BOTH_HOLD_START,	//#
-	BOTH_HOLD_MISS,	//#
-	BOTH_HOLD_IDLE,	//#
-	BOTH_HOLD_END,	//#
-	BOTH_HOLD_ATTACK,	//#
-	BOTH_HOLD_SNIFF,	//# Sniff the guy you're holding
-	BOTH_HOLD_DROP,		//# just drop 'em
-	//BEING GRABBED BY WAMPA
-	BOTH_GRABBED,	//#
-	BOTH_RELEASED,	//#
-	BOTH_HANG_IDLE,	//#
-	BOTH_HANG_ATTACK,	//#
-	BOTH_HANG_PAIN,	//#
-
-	//# #sep BOTH_ MISC MOVEMENT
-	BOTH_HIT1,				//# Kyle hit by crate in cin #9
-	BOTH_LADDER_UP1,		//# Climbing up a ladder with rungs at 16 unit intervals
-	BOTH_LADDER_DWN1,		//# Climbing down a ladder with rungs at 16 unit intervals
-	BOTH_LADDER_IDLE,		//#	Just sitting on the ladder
-
-	//# #sep BOTH_ FLYING IDLE
-	BOTH_FLY_SHIELDED,		//# For sentry droid, shields in
-
-	//# #sep BOTH_ SWIMMING
-	BOTH_SWIM_IDLE1,		//# Swimming Idle 1
-	BOTH_SWIMFORWARD,		//# Swim forward loop
-	BOTH_SWIMBACKWARD,		//# Swim backward loop
-
-	//# #sep BOTH_ LYING
-	BOTH_SLEEP1,			//# laying on back-rknee up-rhand on torso
-	BOTH_SLEEP6START,		//# Kyle leaning back to sleep (cin 20)
-	BOTH_SLEEP6STOP,		//# Kyle waking up and shaking his head (cin 21)
-	BOTH_SLEEP1GETUP,		//# alarmed and getting up out of sleep1 pose to stand
-	BOTH_SLEEP1GETUP2,		//# 
-
-	BOTH_CHOKE1START,		//# tavion in force grip choke
-	BOTH_CHOKE1STARTHOLD,	//# loop of tavion in force grip choke
-	BOTH_CHOKE1,			//# tavion in force grip choke
-
-	BOTH_CHOKE2,			//# tavion recovering from force grip choke
-	BOTH_CHOKE3,			//# left-handed choke (for people still holding a weapon)
-
-	//# #sep BOTH_ HUNTER-SEEKER BOT-SPECIFIC
-	BOTH_POWERUP1,			//# Wakes up
-
-	BOTH_TURNON,			//# Protocol Droid wakes up
-	BOTH_TURNOFF,			//# Protocol Droid shuts off
-
-	BOTH_BUTTON1,			//# Single button push with right hand
-	BOTH_BUTTON2,			//# Single button push with left finger
-	BOTH_BUTTON_HOLD,		//# Single button hold with left hand
-	BOTH_BUTTON_RELEASE,	//# Single button release with left hand
-
-	//# JEDI-SPECIFIC
-	//# #sep BOTH_ FORCE ANIMS
-	BOTH_RESISTPUSH,		//# plant yourself to resist force push/pulls.
-	BOTH_FORCEPUSH,			//# Use off-hand to do force power.
-	BOTH_FORCEPULL,			//# Use off-hand to do force power.
-	BOTH_MINDTRICK1,			//# Use off-hand to do mind trick
-	BOTH_MINDTRICK2,			//# Use off-hand to do distraction
-	BOTH_FORCELIGHTNING,		//# Use off-hand to do lightning
-	BOTH_FORCELIGHTNING_START,	//# Use off-hand to do lightning - start
-	BOTH_FORCELIGHTNING_HOLD,	//# Use off-hand to do lightning - hold
-	BOTH_FORCELIGHTNING_RELEASE,//# Use off-hand to do lightning - release
-	BOTH_FORCEHEAL_START,		//# Healing meditation pose start
-	BOTH_FORCEHEAL_STOP,		//# Healing meditation pose end
-	BOTH_FORCEHEAL_QUICK,		//# Healing meditation gesture
-	BOTH_SABERPULL,			//# Use off-hand to do force power.
-	BOTH_FORCEGRIP1,		//# force-gripping (no anim?)
-	BOTH_FORCEGRIP3,		//# force-gripping (right hand)
-	BOTH_FORCEGRIP3THROW,	//# throwing while force-gripping (right hand)
-	BOTH_FORCEGRIP_HOLD,	//# Use off-hand to do grip - hold
-	BOTH_FORCEGRIP_RELEASE,//# Use off-hand to do grip - release
-	BOTH_TOSS1,				//# throwing to left after force gripping
-	BOTH_TOSS2,				//# throwing to right after force gripping
-	//NEW force anims for JKA:
-	BOTH_FORCE_RAGE,
-	BOTH_FORCE_2HANDEDLIGHTNING,
-	BOTH_FORCE_2HANDEDLIGHTNING_START,
-	BOTH_FORCE_2HANDEDLIGHTNING_HOLD,
-	BOTH_FORCE_2HANDEDLIGHTNING_RELEASE,
-	BOTH_FORCE_DRAIN,
-	BOTH_FORCE_DRAIN_START,
-	BOTH_FORCE_DRAIN_HOLD,
-	BOTH_FORCE_DRAIN_RELEASE,
-	BOTH_FORCE_DRAIN_GRAB_START,
-	BOTH_FORCE_DRAIN_GRAB_HOLD,
-	BOTH_FORCE_DRAIN_GRAB_END,
-	BOTH_FORCE_DRAIN_GRABBED,
-	BOTH_FORCE_ABSORB,
-	BOTH_FORCE_ABSORB_START,
-	BOTH_FORCE_ABSORB_END,
-	BOTH_FORCE_PROTECT,
-	BOTH_FORCE_PROTECT_FAST,
-
-	BOTH_WIND,
-
-	BOTH_STAND_TO_KNEEL,
-	BOTH_KNEEL_TO_STAND,
-
-	BOTH_TUSKENATTACK1,
-	BOTH_TUSKENATTACK2,
-	BOTH_TUSKENATTACK3,
-	BOTH_TUSKENLUNGE1,
-	BOTH_TUSKENTAUNT1,
-
-	BOTH_COWER1_START,		//# cower start
-	BOTH_COWER1,			//# cower loop
-	BOTH_COWER1_STOP,		//# cower stop
-	BOTH_SONICPAIN_START,
-	BOTH_SONICPAIN_HOLD,
-	BOTH_SONICPAIN_END,
-
-	//new anim slots per Jarrod's request
-	BOTH_STAND10,
-	BOTH_STAND10_TALK1,
-	BOTH_STAND10_TALK2,
-	BOTH_STAND10TOSTAND1,
-
-	BOTH_STAND1_TALK1,
-	BOTH_STAND1_TALK2,
-	BOTH_STAND1_TALK3,
-
-	BOTH_SIT4,
-	BOTH_SIT5,
-	BOTH_SIT5_TALK1,
-	BOTH_SIT5_TALK2,
-	BOTH_SIT5_TALK3,
-
-	BOTH_SIT6,
-	BOTH_SIT7,
-
-	//=================================================
-	//ANIMS IN WHICH ONLY THE UPPER OBJECTS ARE IN MD3
-	//=================================================
-	//# #sep TORSO_ WEAPON-RELATED
-	TORSO_DROPWEAP1,		//# Put weapon away
-	TORSO_DROPWEAP4,		//# Put weapon away
-	TORSO_RAISEWEAP1,		//# Draw Weapon
-	TORSO_RAISEWEAP4,		//# Draw Weapon
-	TORSO_WEAPONREADY1,		//# Ready to fire stun baton
-	TORSO_WEAPONREADY2,		//# Ready to fire one-handed blaster pistol
-	TORSO_WEAPONREADY3,		//# Ready to fire blaster rifle
-	TORSO_WEAPONREADY4,		//# Ready to fire sniper rifle
-	TORSO_WEAPONREADY10,	//# Ready to fire thermal det
-	TORSO_WEAPONIDLE2,		//# Holding one-handed blaster
-	TORSO_WEAPONIDLE3,		//# Holding blaster rifle
-	TORSO_WEAPONIDLE4,		//# Holding sniper rifle
-	TORSO_WEAPONIDLE10,		//# Holding thermal det
-
-	//# #sep TORSO_ MISC
-	TORSO_SURRENDER_START,	//# arms up
-	TORSO_SURRENDER_STOP,	//# arms back down
-
-	TORSO_CHOKING1,			//# TEMP
-
-	TORSO_HANDSIGNAL1,
-	TORSO_HANDSIGNAL2,
-	TORSO_HANDSIGNAL3,
-	TORSO_HANDSIGNAL4,
-	TORSO_HANDSIGNAL5,
-
-
-	//=================================================
-	//ANIMS IN WHICH ONLY THE LOWER OBJECTS ARE IN MD3
-	//=================================================
-	//# #sep Legs-only anims
-	LEGS_TURN1,				//# What legs do when you turn your lower body to match your upper body facing
-	LEGS_TURN2,				//# Leg turning from stand2
-	LEGS_LEAN_LEFT1,		//# Lean left
-	LEGS_LEAN_RIGHT1,		//# Lean Right
-	LEGS_CHOKING1,			//# TEMP
-	LEGS_LEFTUP1,			//# On a slope with left foot 4 higher than right
-	LEGS_LEFTUP2,			//# On a slope with left foot 8 higher than right
-	LEGS_LEFTUP3,			//# On a slope with left foot 12 higher than right
-	LEGS_LEFTUP4,			//# On a slope with left foot 16 higher than right
-	LEGS_LEFTUP5,			//# On a slope with left foot 20 higher than right
-	LEGS_RIGHTUP1,			//# On a slope with RIGHT foot 4 higher than left
-	LEGS_RIGHTUP2,			//# On a slope with RIGHT foot 8 higher than left
-	LEGS_RIGHTUP3,			//# On a slope with RIGHT foot 12 higher than left
-	LEGS_RIGHTUP4,			//# On a slope with RIGHT foot 16 higher than left
-	LEGS_RIGHTUP5,			//# On a slope with RIGHT foot 20 higher than left
-	LEGS_S1_LUP1,
-	LEGS_S1_LUP2,
-	LEGS_S1_LUP3,
-	LEGS_S1_LUP4,
-	LEGS_S1_LUP5,
-	LEGS_S1_RUP1,
-	LEGS_S1_RUP2,
-	LEGS_S1_RUP3,
-	LEGS_S1_RUP4,
-	LEGS_S1_RUP5,
-	LEGS_S3_LUP1,
-	LEGS_S3_LUP2,
-	LEGS_S3_LUP3,
-	LEGS_S3_LUP4,
-	LEGS_S3_LUP5,
-	LEGS_S3_RUP1,
-	LEGS_S3_RUP2,
-	LEGS_S3_RUP3,
-	LEGS_S3_RUP4,
-	LEGS_S3_RUP5,
-	LEGS_S4_LUP1,
-	LEGS_S4_LUP2,
-	LEGS_S4_LUP3,
-	LEGS_S4_LUP4,
-	LEGS_S4_LUP5,
-	LEGS_S4_RUP1,
-	LEGS_S4_RUP2,
-	LEGS_S4_RUP3,
-	LEGS_S4_RUP4,
-	LEGS_S4_RUP5,
-	LEGS_S5_LUP1,
-	LEGS_S5_LUP2,
-	LEGS_S5_LUP3,
-	LEGS_S5_LUP4,
-	LEGS_S5_LUP5,
-	LEGS_S5_RUP1,
-	LEGS_S5_RUP2,
-	LEGS_S5_RUP3,
-	LEGS_S5_RUP4,
-	LEGS_S5_RUP5,
-	LEGS_S6_LUP1,
-	LEGS_S6_LUP2,
-	LEGS_S6_LUP3,
-	LEGS_S6_LUP4,
-	LEGS_S6_LUP5,
-	LEGS_S6_RUP1,
-	LEGS_S6_RUP2,
-	LEGS_S6_RUP3,
-	LEGS_S6_RUP4,
-	LEGS_S6_RUP5,
-	LEGS_S7_LUP1,
-	LEGS_S7_LUP2,
-	LEGS_S7_LUP3,
-	LEGS_S7_LUP4,
-	LEGS_S7_LUP5,
-	LEGS_S7_RUP1,
-	LEGS_S7_RUP2,
-	LEGS_S7_RUP3,
-	LEGS_S7_RUP4,
-	LEGS_S7_RUP5,
-
-	//New anim as per Jarrod's request
-	LEGS_TURN180,
-
-	//======================================================
-	//cinematic anims
-	//======================================================
-	//# #sep BOTH_ CINEMATIC-ONLY
-	BOTH_CIN_1,		//# Level specific cinematic 1
-	BOTH_CIN_2,		//# Level specific cinematic 2
-	BOTH_CIN_3,		//# Level specific cinematic 3
-	BOTH_CIN_4,		//# Level specific cinematic 4
-	BOTH_CIN_5,		//# Level specific cinematic 5
-	BOTH_CIN_6,		//# Level specific cinematic 6
-	BOTH_CIN_7,		//# Level specific cinematic 7
-	BOTH_CIN_8,		//# Level specific cinematic 8
-	BOTH_CIN_9,		//# Level specific cinematic 9
-	BOTH_CIN_10,		//# Level specific cinematic 10
-	BOTH_CIN_11,		//# Level specific cinematic 11
-	BOTH_CIN_12,		//# Level specific cinematic 12
-	BOTH_CIN_13,		//# Level specific cinematic 13
-	BOTH_CIN_14,		//# Level specific cinematic 14
-	BOTH_CIN_15,		//# Level specific cinematic 15
-	BOTH_CIN_16,		//# Level specific cinematic 16
-	BOTH_CIN_17,		//# Level specific cinematic 17
-	BOTH_CIN_18,		//# Level specific cinematic 18
-	BOTH_CIN_19,		//# Level specific cinematic 19
-	BOTH_CIN_20,		//# Level specific cinematic 20
-	BOTH_CIN_21,		//# Level specific cinematic 21
-	BOTH_CIN_22,		//# Level specific cinematic 22
-	BOTH_CIN_23,		//# Level specific cinematic 23
-	BOTH_CIN_24,		//# Level specific cinematic 24
-	BOTH_CIN_25,		//# Level specific cinematic 25
-	BOTH_CIN_26,		//# Level specific cinematic 
-	BOTH_CIN_27,		//# Level specific cinematic 
-	BOTH_CIN_28,		//# Level specific cinematic 
-	BOTH_CIN_29,		//# Level specific cinematic 
-	BOTH_CIN_30,		//# Level specific cinematic 
-	BOTH_CIN_31,		//# Level specific cinematic 
-	BOTH_CIN_32,		//# Level specific cinematic 
-	BOTH_CIN_33,		//# Level specific cinematic 
-	BOTH_CIN_34,		//# Level specific cinematic 
-	BOTH_CIN_35,		//# Level specific cinematic 
-	BOTH_CIN_36,		//# Level specific cinematic 
-	BOTH_CIN_37,		//# Level specific cinematic 
-	BOTH_CIN_38,		//# Level specific cinematic 
-	BOTH_CIN_39,		//# Level specific cinematic 
-	BOTH_CIN_40,		//# Level specific cinematic 
-	BOTH_CIN_41,		//# Level specific cinematic 
-	BOTH_CIN_42,		//# Level specific cinematic 
-	BOTH_CIN_43,		//# Level specific cinematic 
-	BOTH_CIN_44,		//# Level specific cinematic 
-	BOTH_CIN_45,		//# Level specific cinematic 
-	BOTH_CIN_46,		//# Level specific cinematic 
-	BOTH_CIN_47,		//# Level specific cinematic 
-	BOTH_CIN_48,		//# Level specific cinematic 
-	BOTH_CIN_49,		//# Level specific cinematic 
-	BOTH_CIN_50,		//# Level specific cinematic
-
-	//# #eol
-	MAX_ANIMATIONS,
-	MAX_TOTALANIMATIONS,
+	BOTH_DEATH_NORMAL,
+
+	ANIM_START_DEATHS,
+
+	BOTH_DEATH_NECK,
+	BOTH_DEATH_CHEST_1,
+	BOTH_DEATH_CHEST_2,
+	BOTH_DEATH_GROIN_1,
+	BOTH_DEATH_GROIN_2,
+	BOTH_DEATH_GUT_1,
+	BOTH_DEATH_GUT_2,
+	BOTH_DEATH_HEAD_1,
+	BOTH_DEATH_HEAD_2,
+	BOTH_DEATH_SHOULDER_LEFT_1,
+	BOTH_DEATH_SHOULDER_LEFT_2,
+	BOTH_DEATH_ARMS_LEFT_1,
+	BOTH_DEATH_ARMS_LEFT_2,
+	BOTH_DEATH_LEGS_LEFT_1,
+	BOTH_DEATH_LEGS_LEFT_2,
+	BOTH_DEATH_LEGS_LEFT_3,
+	BOTH_DEATH_THIGH_LEFT_1,
+	BOTH_DEATH_THIGH_LEFT_2,
+	BOTH_DEATH_ARMS_RIGHT_1,
+	BOTH_DEATH_ARMS_RIGHT_2,
+	BOTH_DEATH_LEGS_RIGHT_1,
+	BOTH_DEATH_LEGS_RIGHT_2,
+	BOTH_DEATH_LEGS_RIGHT_3,
+	BOTH_DEATH_SHOULDER_RIGHT_1,
+	BOTH_DEATH_SHOULDER_RIGHT_2,
+	BOTH_DEATH_THIGH_RIGHT_1,
+	BOTH_DEATH_THIGH_RIGHT_2,
+
+	ANIM_END_DEATHS,
+
+	TORSO_DROP,
+	TORSO_DROP_ONEHANDED,
+	TORSO_DROP_KNIFE,
+	TORSO_RAISE,
+	TORSO_RAISE_ONEHANDED,
+	TORSO_RAISE_KNIFE,
+
+	LEGS_IDLE,
+	LEGS_IDLE_CROUCH,
+	LEGS_WALK,
+	LEGS_WALK_BACK,
+	LEGS_WALK_CROUCH,
+	LEGS_WALK_CROUCH_BACK,
+
+	LEGS_RUN,
+	LEGS_RUN_BACK,
+
+	LEGS_SWIM,
+
+	LEGS_JUMP,
+	LEGS_JUMP_BACK,
+
+	LEGS_TURN,
+
+	LEGS_LEAN_LEFT,
+	LEGS_LEAN_RIGHT,
+	LEGS_LEAN_CROUCH_LEFT,
+	LEGS_LEAN_CROUCH_RIGHT,
+
+	LEGS_LEANLEFT_WALKLEFT,
+	LEGS_LEANLEFT_WALKRIGHT,
+	LEGS_LEANRIGHT_WALKLEFT,
+	LEGS_LEANRIGHT_WALKRIGHT,
+
+	LEGS_LEANLEFT_CROUCH_WALKLEFT,
+	LEGS_LEANLEFT_CROUCH_WALKRIGHT,
+	LEGS_LEANRIGHT_CROUCH_WALKLEFT,
+	LEGS_LEANRIGHT_CROUCH_WALKRIGHT,
+
+	TORSO_IDLE_KNIFE,
+	TORSO_IDLE_PISTOL,
+	TORSO_IDLE_RIFLE,
+	TORSO_IDLE_MSG90A1,
+	TORSO_IDLE_MSG90A1_ZOOMED,
+	TORSO_IDLE_M4,
+	TORSO_IDLE_M590,
+	TORSO_IDLE_USAS12,
+	TORSO_IDLE_RPG,
+	TORSO_IDLE_M60,
+	TORSO_IDLE_MM1,
+	TORSO_IDLE_GRENADE,
+
+	TORSO_ATTACK_KNIFE,
+	TORSO_ATTACK_KNIFE_THROW,
+	TORSO_ATTACK_PISTOL,
+	TORSO_ATTACK_RIFLE,
+	TORSO_ATTACK_MSG90A1_ZOOMED,
+	TORSO_ATTACK_M4,
+	TORSO_ATTACK_M590,
+	TORSO_ATTACK_USAS12,
+	TORSO_ATTACK_RIFLEBUTT,
+	TORSO_ATTACK_RPG,
+	TORSO_ATTACK_M60,
+	TORSO_ATTACK_MM1,
+	TORSO_ATTACK_GRENADE_START,
+	TORSO_ATTACK_GRENADE_END,
+	TORSO_ATTACK_BAYONET,
+	TORSO_ATTACK_PISTOLWHIP,
+
+	TORSO_RELOAD_M60,
+	TORSO_RELOAD_PISTOL,
+	TORSO_RELOAD_RIFLE,
+	TORSO_RELOAD_MSG90A1,
+	TORSO_RELOAD_RPG,
+	TORSO_RELOAD_USAS12,
+
+	TORSO_RELOAD_M590_START,
+	TORSO_RELOAD_M590_SHELL,
+	TORSO_RELOAD_M590_END,
+
+	TORSO_RELOAD_MM1_START,
+	TORSO_RELOAD_MM1_SHELL,
+	TORSO_RELOAD_MM1_END,
+
+	TORSO_USE,
+
+	MAX_ANIMATIONS
 } animNumber_t;
 
-#define SABER_ANIM_GROUP_SIZE (BOTH_A2_T__B_ - BOTH_A1_T__B_)
-
-
 #endif// #ifndef __ANIMS_H__
 
diff --git a/codemp/game/bg_public.h b/codemp/game/bg_public.h
index 70f559e..a45f05b 100644
--- a/codemp/game/bg_public.h
+++ b/codemp/game/bg_public.h
@@ -10,31 +10,24 @@
 
 #include "bg_weapons.h"
 #include "anims.h"
-#include "bg_vehicles.h"
 
 //these two defs are shared now because we do clientside ent parsing
 #define	MAX_SPAWN_VARS			64
 #define	MAX_SPAWN_VARS_CHARS	4096
 
 
-#define	GAME_VERSION		"basejka-1"
-
-#define DEFAULT_SABER		"Kyle"
-#define DEFAULT_SABER_MODEL	"models/weapons2/saber/saber_w.glm"
-
-#define	STEPSIZE		18
-
-#define DEFAULT_FORCEPOWERS	"5-1-000000000000000000"
-//"rank-side-heal.lev.speed.push.pull.tele.grip.lightning.rage.protect.absorb.teamheal.teamforce.drain.see"
+#define	GAME_VERSION		"sof2mp-1.03"
 
 #define	DEFAULT_GRAVITY		800
-#define	GIB_HEALTH			-40
-#define ARMOR_PROTECTION		0.50 // Shields only stop 50% of armor-piercing dmg
-#define ARMOR_REDUCTION_FACTOR	0.50 // Certain damage doesn't take off armor as efficiently
-
-#define	JUMP_VELOCITY		225//270
+#define	ARMOR_PROTECTION	0.55
 
 #define	MAX_ITEMS			256
+#define MAX_HEALTH			100
+#define MAX_ARMOR			100
+
+#define	BULLET_SPACING		95
+
+#define DISMEMBER_HEALTH	-20
 
 #define	RANK_TIED_FLAG		0x4000
 
@@ -42,19 +35,26 @@
 
 #define	SCORE_NOT_PRESENT	-9999	// for the CS_SCORES[12] when only one player is present
 
-#define	VOTE_TIME			30000	// 30 seconds before vote times out
+#define DEFAULT_PLAYER_Z_MAX	43
+#define CROUCH_PLAYER_Z_MAX		18
+#define PRONE_PLAYER_Z_MAX		-12
+#define DEAD_PLAYER_Z_MAX		-30
+
+#define DUCK_ACCURACY_MODIFIER	0.75f
+#define JUMP_ACCURACY_MODIFIER	2.0f
+
+#define	MINS_Z				-46
 
-#define DEFAULT_MINS_2		-24
-#define DEFAULT_MAXS_2		40
-#define CROUCH_MAXS_2		16
-#define	STANDARD_VIEWHEIGHT_OFFSET -4
+#define	DEFAULT_VIEWHEIGHT	37
+#define CROUCH_VIEWHEIGHT	8
+#define PRONE_VIEWHEIGHT	-22
+#define	DEAD_VIEWHEIGHT		-38
 
-#define	MINS_Z				-24
-#define	DEFAULT_VIEWHEIGHT	(DEFAULT_MAXS_2+STANDARD_VIEWHEIGHT_OFFSET)//26
-#define CROUCH_VIEWHEIGHT	(CROUCH_MAXS_2+STANDARD_VIEWHEIGHT_OFFSET)//12
-#define	DEAD_VIEWHEIGHT		-16
+#define BODY_SINK_DELAY		10000
+#define BODY_SINK_TIME		1500
 
-#define MAX_CLIENT_SCORE_SEND 20
+#define LEAN_TIME			250
+#define LEAN_OFFSET			30
 
 //
 // config strings are a general means of communicating variable length strings
@@ -62,68 +62,101 @@
 //
 
 // CS_SERVERINFO and CS_SYSTEMINFO are defined in q_shared.h
-#define	CS_MUSIC				2
-#define	CS_MESSAGE				3		// from the map worldspawn's message field
+
+#define	CS_PLAYERS				2
+
+enum
+{
+//	CS_SERVERINFO,
+//	CS_SYSTEMINFO,
+//  CS_PLAYERS,
+
+	CS_MUSIC = CS_CUSTOM,
+
+	CS_MESSAGE,
+	CS_MOTD,
+	CS_WARMUP,
+
+	CS_VOTE_TIME,
+	CS_VOTE_STRING,
+	CS_VOTE_YES,
+	CS_VOTE_NO,
+	CS_VOTE_NEEDED,
+
+	CS_GAME_VERSION,
+	CS_GAME_ID,
+	CS_LEVEL_START_TIME,
+	CS_INTERMISSION,
+	CS_SHADERSTATE,
+	CS_BOTINFO,
+	
+	CS_GAMETYPE_TIMER,
+	CS_GAMETYPE_MESSAGE,
+	CS_GAMETYPE_REDTEAM,
+	CS_GAMETYPE_BLUETEAM,
+
+	CS_ITEMS,
+
+	CS_PICKUPSDISABLED,
+
+	// Config string ranges
+	CS_MODELS,
+	CS_SOUNDS				= CS_MODELS + MAX_MODELS,
+	CS_LOCATIONS			= CS_SOUNDS + MAX_SOUNDS,
+	CS_LADDERS				= CS_LOCATIONS + MAX_LOCATIONS,
+	CS_BSP_MODELS			= CS_LADDERS + MAX_LADDERS,
+	CS_TERRAINS				= CS_BSP_MODELS + MAX_SUB_BSP,
+	CS_EFFECTS				= CS_TERRAINS + MAX_TERRAINS,
+	CS_LIGHT_STYLES			= CS_EFFECTS + MAX_FX,
+	CS_ICONS				= CS_LIGHT_STYLES + (MAX_LIGHT_STYLES*3),
+	CS_TEAM_INFO			= CS_ICONS + MAX_ICONS,
+	CS_AMBIENT_SOUNDSETS	= CS_TEAM_INFO + TEAM_NUM_TEAMS,
+
+	CS_HUDICONS				= CS_AMBIENT_SOUNDSETS + MAX_AMBIENT_SOUNDSETS,
+
+	CS_MAX					= CS_HUDICONS + MAX_HUDICONS,
+};
+	
+/*
+#define	CS_MUSIC				68
+#define	CS_MESSAGE				69		// from the map worldspawn's message field
 #define	CS_MOTD					4		// g_motd string for server message of the day
 #define	CS_WARMUP				5		// server time when the match will be restarted
-#define	CS_SCORES1				6
-#define	CS_SCORES2				7
 #define CS_VOTE_TIME			8
 #define CS_VOTE_STRING			9
 #define	CS_VOTE_YES				10
 #define	CS_VOTE_NO				11
-
-#define CS_TEAMVOTE_TIME		12
-#define CS_TEAMVOTE_STRING		14
-#define	CS_TEAMVOTE_YES			16
-#define	CS_TEAMVOTE_NO			18
-
-#define	CS_GAME_VERSION			20
-#define	CS_LEVEL_START_TIME		21		// so the timer only shows the current level
-#define	CS_INTERMISSION			22		// when 1, fraglimit/timelimit has been hit and intermission will start in a second or two
-#define CS_FLAGSTATUS			23		// string indicating flag status in CTF
-#define CS_SHADERSTATE			24
-#define CS_BOTINFO				25
-
-#define	CS_ITEMS				27		// string of 0's and 1's that tell which items are present
-
-#define CS_CLIENT_JEDIMASTER	28		// current jedi master
-#define CS_CLIENT_DUELWINNER	29		// current duel round winner - needed for printing at top of scoreboard
-#define CS_CLIENT_DUELISTS		30		// client numbers for both current duelists. Needed for a number of client-side things.
-#define CS_CLIENT_DUELHEALTHS	31		// nmckenzie: DUEL_HEALTH.  Hopefully adding this cs is safe and good?
-#define CS_GLOBAL_AMBIENT_SET	32
-
-#define CS_AMBIENT_SET			37
-
-#define CS_SIEGE_STATE			(CS_AMBIENT_SET+MAX_AMBIENT_SETS)
-#define CS_SIEGE_OBJECTIVES		(CS_SIEGE_STATE+1)
-#define CS_SIEGE_TIMEOVERRIDE	(CS_SIEGE_OBJECTIVES+1)
-#define CS_SIEGE_WINTEAM		(CS_SIEGE_TIMEOVERRIDE+1)
-#define CS_SIEGE_ICONS			(CS_SIEGE_WINTEAM+1)
-
-#define	CS_MODELS				(CS_SIEGE_ICONS+1)
-#define	CS_SKYBOXORG			(CS_MODELS+MAX_MODELS)		//rww - skybox info
-#define	CS_SOUNDS				(CS_SKYBOXORG+1)
-#define CS_ICONS				(CS_SOUNDS+MAX_SOUNDS)
-#define	CS_PLAYERS				(CS_ICONS+MAX_ICONS)
-/*
-Ghoul2 Insert Start
-*/
-#define CS_G2BONES				(CS_PLAYERS+MAX_CLIENTS)
-//rww - used to be CS_CHARSKINS, but I have eliminated the need for that.
-/*
-Ghoul2 Insert End
-*/
-#define CS_LOCATIONS			(CS_G2BONES+MAX_G2BONES)
-#define CS_PARTICLES			(CS_LOCATIONS+MAX_LOCATIONS) 
+#define	CS_VOTE_NEEDED			12
+
+#define	CS_GAME_VERSION			16
+#define	CS_LEVEL_START_TIME		17		// so the timer only shows the current level
+#define	CS_INTERMISSION			18		// when 1, scorelimit/timelimit has been hit and intermission will start in a second or two
+#define CS_SHADERSTATE			19
+#define CS_BOTINFO				20
+
+#define	CS_GAMETYPE_TIMER		21		// currently visible timer
+#define CS_GAMETYPE_MESSAGE		22		// Last gametype message
+#define CS_GAMETYPE_REDTEAM		23		// red team group name
+#define CS_GAMETYPE_BLUETEAM	24		// blue team group name
+
+#define	CS_ITEMS				28		// string of 0's and 1's that tell which items are present
+
+// these are also in be_aas_def.h - argh (rjr)
+#define	CS_MODELS				32
+#define	CS_SOUNDS				(CS_MODELS+MAX_MODELS)
+#define CS_CHARSKINS 			(CS_PLAYERS+MAX_CLIENTS)
+#define CS_LOCATIONS			(CS_CHARSKINS+MAX_CHARSKINS)
+#define CS_LADDERS				(CS_LOCATIONS + MAX_LOCATIONS)
+#define CS_BSP_MODELS			(CS_LADDERS + MAX_LADDERS)
+#define CS_TERRAINS				(CS_BSP_MODELS + MAX_SUB_BSP)
 #define CS_EFFECTS				(CS_PARTICLES+MAX_LOCATIONS)
 #define	CS_LIGHT_STYLES			(CS_EFFECTS + MAX_FX)
+#define CS_ICONS				(CS_LIGHT_STYLES + (MAX_LIGHT_STYLES*3))
+#define CS_TEAM_INFO			(CS_ICONS+MAX_ICONS)
+#define CS_AMBIENT_SOUNDSETS	(CS_TEAM_INFO+TEAM_NUM_TEAMS)
 
-//rwwRMG - added:
-#define CS_TERRAINS				(CS_LIGHT_STYLES + (MAX_LIGHT_STYLES*3))
-#define CS_BSP_MODELS			(CS_TERRAINS + MAX_TERRAINS)
-
-#define CS_MAX					(CS_BSP_MODELS + MAX_SUB_BSP)
+#define CS_MAX					(CS_AMBIENT_SOUNDSETS+MAX_AMBIENT_SOUNDSETS)
+*/
 
 #if (CS_MAX) > MAX_CONFIGSTRINGS
 #error overflow: (CS_MAX) > MAX_CONFIGSTRINGS
@@ -150,29 +183,6 @@ extern const char *bg_customSiegeSoundNames[MAX_CUSTOM_SIEGE_SOUNDS];
 extern const char *bgToggleableSurfaces[BG_NUM_TOGGLEABLE_SURFACES];
 extern const int bgToggleableSurfaceDebris[BG_NUM_TOGGLEABLE_SURFACES];
 
-typedef enum {
-	HANDEXTEND_NONE = 0,
-	HANDEXTEND_FORCEPUSH,
-	HANDEXTEND_FORCEPULL,
-	HANDEXTEND_FORCE_HOLD,
-	HANDEXTEND_SABERPULL,
-	HANDEXTEND_CHOKE, //use handextend priorities to choke someone being gripped
-	HANDEXTEND_WEAPONREADY,
-	HANDEXTEND_DODGE,
-	HANDEXTEND_KNOCKDOWN,
-	HANDEXTEND_DUELCHALLENGE,
-	HANDEXTEND_TAUNT,
-
-	HANDEXTEND_PRETHROW,
-	HANDEXTEND_POSTTHROW,
-	HANDEXTEND_PRETHROWN,
-	HANDEXTEND_POSTTHROWN,
-
-	HANDEXTEND_DRAGGING,
-
-	HANDEXTEND_JEDITAUNT,
-} forceHandAnims_t;
-
 typedef enum
 {
 	BROKENLIMB_NONE = 0,
@@ -184,40 +194,10 @@ typedef enum
 //for supplier class items
 #define TOSS_DEBOUNCE_TIME				5000
 
-typedef enum {
-	GT_FFA,				// free for all
-	GT_HOLOCRON,		// holocron ffa
-	GT_JEDIMASTER,		// jedi master
-	GT_DUEL,		// one on one tournament
-	GT_POWERDUEL,
-	GT_SINGLE_PLAYER,	// single player ffa
-
-	//-- team games go after this --
-
-	GT_TEAM,			// team deathmatch
-	GT_SIEGE,			// siege
-	GT_CTF,				// capture the flag
-	GT_CTY,
-	GT_MAX_GAME_TYPE
-} gametype_t;
-
 typedef enum { GENDER_MALE, GENDER_FEMALE, GENDER_NEUTER } gender_t;
 
 extern vec3_t WP_MuzzlePoint[WP_NUM_WEAPONS];
 
-extern int forcePowerSorted[NUM_FORCE_POWERS];
-
-typedef enum saberLockType_e
-{
-	SABERLOCK_TOP,
-	SABERLOCK_SIDE,
-	SABERLOCK_LOCK,
-	SABERLOCK_BREAK,
-	SABERLOCK_SUPERBREAK,
-	SABERLOCK_WIN,
-	SABERLOCK_LOSE
-} saberLockType_t;
-
 typedef enum direction_e
 {
 	DIR_RIGHT,
@@ -240,178 +220,96 @@ movement on the server game.
 
 #pragma pack(push, 1)
 typedef struct animation_s {
-	unsigned short		firstFrame;
-	unsigned short		numFrames;
-	short				frameLerp;			// msec between frames
-	//initialLerp is abs(frameLerp)
-	signed char			loopFrames;			// 0 to numFrames
+	int		firstFrame;
+	int		numFrames;
+	int		loopFrames;			// 0 to numFrames
+	int		frameLerp;			// msec between frames
+	int		initialLerp;		// msec to get to first frame
+	int		reversed;			// true if animation is reversed
+	int		flipflop;			// true if animation should flipflop back to base
 } animation_t;
 #pragma pack(pop)
 
-extern qboolean			BGPAFtextLoaded;
-extern animation_t		bgHumanoidAnimations[MAX_TOTALANIMATIONS];
-
-#define MAX_ANIM_FILES	16
-#define MAX_ANIM_EVENTS 300
-
-typedef enum
-{
-	FOOTSTEP_R,
-	FOOTSTEP_L,
-	FOOTSTEP_HEAVY_R,
-	FOOTSTEP_HEAVY_L,
-	NUM_FOOTSTEP_TYPES
-} footstepType_t;
-
-extern stringID_table_t animEventTypeTable[MAX_ANIM_EVENTS+1];
-extern stringID_table_t footstepTypeTable[NUM_FOOTSTEP_TYPES+1];
-
-//size of Anim eventData array...
-#define MAX_RANDOM_ANIM_SOUNDS		4
-#define	AED_ARRAY_SIZE				(MAX_RANDOM_ANIM_SOUNDS+3)
-//indices for AEV_SOUND data
-#define	AED_SOUNDINDEX_START		0
-#define	AED_SOUNDINDEX_END			(MAX_RANDOM_ANIM_SOUNDS-1)
-#define	AED_SOUND_NUMRANDOMSNDS		(MAX_RANDOM_ANIM_SOUNDS)
-#define	AED_SOUND_PROBABILITY		(MAX_RANDOM_ANIM_SOUNDS+1)
-//indices for AEV_SOUNDCHAN data
-#define	AED_SOUNDCHANNEL			(MAX_RANDOM_ANIM_SOUNDS+2)
-//indices for AEV_FOOTSTEP data
-#define	AED_FOOTSTEP_TYPE			0
-#define	AED_FOOTSTEP_PROBABILITY	1
-//indices for AEV_EFFECT data
-#define	AED_EFFECTINDEX				0
-#define	AED_BOLTINDEX				1
-#define	AED_EFFECT_PROBABILITY		2
-#define	AED_MODELINDEX				3
-//indices for AEV_FIRE data
-#define	AED_FIRE_ALT				0
-#define	AED_FIRE_PROBABILITY		1
-//indices for AEV_MOVE data
-#define	AED_MOVE_FWD				0
-#define	AED_MOVE_RT					1
-#define	AED_MOVE_UP					2
-//indices for AEV_SABER_SWING data
-#define	AED_SABER_SWING_SABERNUM	0
-#define	AED_SABER_SWING_TYPE		1
-#define	AED_SABER_SWING_PROBABILITY	2
-//indices for AEV_SABER_SPIN data
-#define	AED_SABER_SPIN_SABERNUM		0
-#define	AED_SABER_SPIN_TYPE			1	//0 = saberspinoff, 1 = saberspin, 2-4 = saberspin1-saberspin3
-#define	AED_SABER_SPIN_PROBABILITY	2	
-
-typedef enum
-{//NOTENOTE:  Be sure to update animEventTypeTable and ParseAnimationEvtBlock(...) if you change this enum list!
-	AEV_NONE,
-	AEV_SOUND,		//# animID AEV_SOUND framenum soundpath randomlow randomhi chancetoplay
-	AEV_FOOTSTEP,	//# animID AEV_FOOTSTEP framenum footstepType chancetoplay
-	AEV_EFFECT,		//# animID AEV_EFFECT framenum effectpath boltName chancetoplay
-	AEV_FIRE,		//# animID AEV_FIRE framenum altfire chancetofire
-	AEV_MOVE,		//# animID AEV_MOVE framenum forwardpush rightpush uppush
-	AEV_SOUNDCHAN,  //# animID AEV_SOUNDCHAN framenum CHANNEL soundpath randomlow randomhi chancetoplay 
-	AEV_SABER_SWING,  //# animID AEV_SABER_SWING framenum CHANNEL randomlow randomhi chancetoplay 
-	AEV_SABER_SPIN,  //# animID AEV_SABER_SPIN framenum CHANNEL chancetoplay 
-	AEV_NUM_AEV
-} animEventType_t;
-
-typedef struct animevent_s 
-{
-	animEventType_t	eventType;
-	unsigned short	keyFrame;			//Frame to play event on
-	signed short	eventData[AED_ARRAY_SIZE];	//Unique IDs, can be soundIndex of sound file to play OR effect index or footstep type, etc.
-	char			*stringData;		//we allow storage of one string, temporarily (in case we have to look up an index later, then make sure to set stringData to NULL so we only do the look-up once)
-} animevent_t;
-
-typedef struct
-{
-	char			filename[MAX_QPATH];
-	animation_t		*anims;
-//	animsounds_t	torsoAnimSnds[MAX_ANIM_SOUNDS];
-//	animsounds_t	legsAnimSnds[MAX_ANIM_SOUNDS];
-//	qboolean		soundsCached;
-} bgLoadedAnim_t;
-
-typedef struct
+typedef struct ladder_s 
 {
-	char			filename[MAX_QPATH];
-	animevent_t		torsoAnimEvents[MAX_ANIM_EVENTS];
-	animevent_t		legsAnimEvents[MAX_ANIM_EVENTS];
-	qboolean		eventsParsed;
-} bgLoadedEvents_t;
-
+	vec3_t	origin;
+	vec3_t	fwd;
 
-extern bgLoadedAnim_t bgAllAnims[MAX_ANIM_FILES];
-
-//In SP this is shared in with the anim stuff, and humanoid anim sets can be loaded
-//multiple times just for the sake of sounds being different. We probably wouldn't
-//care normally but since we're working in VMs we have to do everything possible to
-//cut memory cost.
-//On the bright side this also means we're cutting a rather large size out of
-//required game-side memory.
-#ifndef QAGAME
-extern bgLoadedEvents_t bgAllEvents[MAX_ANIM_FILES];
-extern int bgNumAnimEvents;
-#endif
+} ladder_t;
 
+// flip the togglebit every time an animation
+// changes so a restart of the same anim can be detected
+#define	ANIM_TOGGLEBIT				2048		// Note that there are 12 bits (max 4095) for animations.
+#define ITEM_AUTOSWITCHBIT			(1<<31)	
+#define ITEM_QUIETPICKUP			(1<<30)
 
 typedef enum {
 	PM_NORMAL,		// can accelerate and turn
-	PM_JETPACK,		// special jetpack movement
-	PM_FLOAT,		// float with no gravity in general direction of velocity (intended for gripping)
 	PM_NOCLIP,		// noclip movement
 	PM_SPECTATOR,	// still run into walls
 	PM_DEAD,		// no acceleration or turning, but free falling
 	PM_FREEZE,		// stuck in place with no control
 	PM_INTERMISSION,	// no movement or status bar
-	PM_SPINTERMISSION	// no movement or status bar
 } pmtype_t;
 
 typedef enum {
 	WEAPON_READY, 
+	WEAPON_SPAWNING,
 	WEAPON_RAISING,
 	WEAPON_DROPPING,
+	WEAPON_RELOADING,
+	WEAPON_RELOADING_ALT,
 	WEAPON_FIRING,
+	WEAPON_FIRING_ALT,
 	WEAPON_CHARGING,
 	WEAPON_CHARGING_ALT,
-	WEAPON_IDLE, //lowered		// NOTENOTE Added with saber
+	WEAPON_ZOOMIN,
+	WEAPON_ZOOMOUT,
 } weaponstate_t;
 
-
-typedef enum forceMasteries_e {
-	FORCE_MASTERY_UNINITIATED,
-	FORCE_MASTERY_INITIATE,
-	FORCE_MASTERY_PADAWAN,
-	FORCE_MASTERY_JEDI,
-	FORCE_MASTERY_JEDI_GUARDIAN,
-	FORCE_MASTERY_JEDI_ADEPT,
-	FORCE_MASTERY_JEDI_KNIGHT,
-	FORCE_MASTERY_JEDI_MASTER,
-	NUM_FORCE_MASTERY_LEVELS
-} forceMasteries_t;
-
-extern char *forceMasteryLevels[NUM_FORCE_MASTERY_LEVELS];
-extern int forceMasteryPoints[NUM_FORCE_MASTERY_LEVELS];
-
-extern int bgForcePowerCost[NUM_FORCE_POWERS][NUM_FORCE_POWER_LEVELS];
-
 // pmove->pm_flags
-#define	PMF_DUCKED			1
-#define	PMF_JUMP_HELD		2
-#define PMF_ROLLING			4
-#define	PMF_BACKWARDS_JUMP	8		// go into backwards land
-#define	PMF_BACKWARDS_RUN	16		// coast down to backwards run
-#define	PMF_TIME_LAND		32		// pm_time is time before rejump
-#define	PMF_TIME_KNOCKBACK	64		// pm_time is an air-accelerate only time
-#define	PMF_FIX_MINS		128		// mins have been brought up, keep tracing down to fix them
-#define	PMF_TIME_WATERJUMP	256		// pm_time is waterjump
-#define	PMF_RESPAWNED		512		// clear after attack and jump buttons come up
-#define	PMF_USE_ITEM_HELD	1024
-#define PMF_UPDATE_ANIM		2048	// The server updated the animation, the pmove should set the ghoul2 anim to match.
-#define PMF_FOLLOW			4096	// spectate following another player
-#define PMF_SCOREBOARD		8192	// spectate as a scoreboard
-#define PMF_STUCK_TO_WALL	16384	// grabbing a wall
+#define	PMF_DUCKED				0x00000001
+#define	PMF_BACKWARDS_JUMP		0x00000002		// go into backwards land
+#define PMF_JUMPING				0x00000004		// executing a jump
+#define	PMF_BACKWARDS_RUN		0x00000008		// coast down to backwards run
+#define	PMF_TIME_LAND			0x00000010		// pm_time is time before rejump
+#define	PMF_TIME_KNOCKBACK		0x00000020		// pm_time is an air-accelerate only time
+#define	PMF_TIME_WATERJUMP		0x00000040		// pm_time is waterjump
+#define	PMF_RESPAWNED			0x00000080		// clear after attack and jump buttons come up
+#define PMF_CAN_USE				0x00000100		// The server updated the animation, the pmove should set the ghoul2 anim to match.
+#define PMF_FOLLOW				0x00000200		// spectate following another player
+#define PMF_SCOREBOARD			0x00000400		// spectate as a scoreboard
+#define	PMF_GHOST				0x00000800		// Your a ghost. scarry!!
+#define PMF_LADDER				0x00001000		// On a ladder
+#define PMF_LADDER_JUMP			0x00002000		// Jumped off a ladder
+								
+#define PMF_ZOOMED				0x00004000
+#define PMF_ZOOM_LOCKED			0x00008000		// Zoom mode cant be changed 
+#define PMF_ZOOM_REZOOM			0x00010000		// Rezoom after reload done
+#define PMF_ZOOM_DEFER_RELOAD	0x00020000		// Reload after zoomout
+
+#define	PMF_LIMITED_INVENTORY	0x00040000		// inventory is limited for this player
+
+#define PMF_CROUCH_JUMP			0x00080000		// crouch jumping
+#define PMF_GOGGLES_ON			0x00100000		// goggles are on
+#define PMF_LEANING				0x00200000		// currently leaning
+
+#define	PMF_AUTORELOAD			0x00400000		// autoreloading enabled
+
+#define	PMF_SIAMESETWINS		0x00800000	
+#define PMF_FOLLOWFIRST			0x01000000		// First person following
 
 #define	PMF_ALL_TIMES	(PMF_TIME_WATERJUMP|PMF_TIME_LAND|PMF_TIME_KNOCKBACK)
+#define PMF_ZOOM_FLAGS	(PMF_ZOOMED|PMF_ZOOM_LOCKED|PMF_ZOOM_REZOOM|PMF_ZOOM_DEFER_RELOAD)
+
+// pmove->pm_debounce
+
+#define PMD_JUMP				0x0001
+#define PMD_ATTACK				0x0002
+#define PMD_FIREMODE			0x0004
+#define PMD_USE					0x0008
+#define PMD_ALTATTACK			0x0010
+#define PMD_GOGGLES				0x0020
 
 #define	MAXTOUCH	32
 
@@ -419,7 +317,6 @@ typedef struct bgEntity_s
 {
 	entityState_t	s;
 	playerState_t	*playerState;
-	Vehicle_t		*m_pVehicle; //vehicle data
 	void			*ghoul2; //g2 instance
 	int				localAnimIndex; //index locally (game/cgame) to anim data for this skel
 	vec3_t			modelScale; //needed for g2 collision
@@ -435,15 +332,6 @@ typedef struct {
 	// state (in / out)
 	playerState_t	*ps;
 
-	//rww - shared ghoul2 stuff (not actually the same data, but hey)
-	void		*ghoul2;
-	int			g2Bolts_LFoot;
-	int			g2Bolts_RFoot;
-	vec3_t		modelScale;
-
-	//hacky bool so we know if we're dealing with a nonhumanoid (which is probably a rockettrooper)
-	qboolean	nonHumanoid;
-
 	// command (in)
 	usercmd_t	cmd;
 	int			tracemask;			// collide against these types of surfaces
@@ -464,12 +352,6 @@ typedef struct {
 	int			watertype;
 	int			waterlevel;
 
-	int			gametype;
-
-	int			debugMelee;
-	int			stepSlideFix;
-	int			noSpecMove;
-
 	animation_t	*animations;
 
 	float		xyspeed;
@@ -483,11 +365,9 @@ typedef struct {
 	void		(*trace)( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentMask );
 	int			(*pointcontents)( const vec3_t point, int passEntityNum );
 
-	int			checkDuelLoss;
-
-	//rww - bg entitystate access method
-	bgEntity_t	*baseEnt; //base address of the entity array (g_entities or cg_entities)
-	int			entSize; //size of the struct (gentity_t or centity_t) so things can be dynamic
+	int			weaponAnimIdx;
+	char		weaponAnim[MAX_QPATH];
+	char		weaponEndAnim[MAX_QPATH];
 } pmove_t;
 
 
@@ -516,16 +396,19 @@ void Pmove (pmove_t *pmove);
 // NOTE: may not have more than 16
 typedef enum {
 	STAT_HEALTH,
-	STAT_HOLDABLE_ITEM,
-	STAT_HOLDABLE_ITEMS,
-	STAT_PERSISTANT_POWERUP,
-	//MAKE SURE STAT_WEAPONS REMAINS 4!!!!
-	//There is a hardcoded reference in msg.cpp to send it in 32 bits -rww
-	STAT_WEAPONS = 4,					// 16 bit fields
+	STAT_WEAPONS,					// 16 bit fields
 	STAT_ARMOR,				
 	STAT_DEAD_YAW,					// look this direction when dead (FIXME: get rid of?)
 	STAT_CLIENTS_READY,				// bit mask of clients wishing to exit the intermission (FIXME: configstring?)
-	STAT_MAX_HEALTH					// health / armor limit, changable by handicap
+	STAT_FROZEN,
+	STAT_GOGGLES,					// Which visual enhancing device they have
+	STAT_GAMETYPE_ITEMS,			// Which gametype items they have	
+	STAT_SEED,						// seed used to keep weapon firing in sync
+	STAT_OUTFIT_GRENADE,			// indicates which greande is chosen in the outfitting
+	STAT_USEICON,					// icon to display when able to use a trigger or item
+	STAT_USETIME,					// elased time for using 
+	STAT_USETIME_MAX,				// total time required to use
+	STAT_USEWEAPONDROP,				// value to drop weapon out of view when using
 } statIndex_t;
 
 
@@ -535,177 +418,69 @@ typedef enum {
 // NOTE: may not have more than 16
 typedef enum {
 	PERS_SCORE,						// !!! MUST NOT CHANGE, SERVER AND GAME BOTH REFERENCE !!!
-	PERS_HITS,						// total points damage inflicted so damage beeps can sound on change
 	PERS_RANK,						// player rank or team rank
 	PERS_TEAM,						// player team
 	PERS_SPAWN_COUNT,				// incremented every respawn
 	PERS_PLAYEREVENTS,				// 16 bits that can be flipped for events
 	PERS_ATTACKER,					// clientnum of last damage inflicter
-	PERS_ATTACKEE_ARMOR,			// health/armor of last person we attacked
-	PERS_KILLED,					// count of the number of times you died
-	// player awards tracking
-	PERS_IMPRESSIVE_COUNT,			// two railgun hits in a row
-	PERS_EXCELLENT_COUNT,			// two successive kills in a short amount of time
-	PERS_DEFEND_COUNT,				// defend awards
-	PERS_ASSIST_COUNT,				// assist awards
-	PERS_GAUNTLET_FRAG_COUNT,		// kills with the guantlet
-	PERS_CAPTURES					// captures
-} persEnum_t;
-
-
-// entityState_t->eFlags
-#define	EF_G2ANIMATING			(1<<0)		//perform g2 bone anims based on torsoAnim and legsAnim, works for ET_GENERAL -rww
-#define	EF_DEAD					(1<<1)		// don't draw a foe marker over players with EF_DEAD
-//#define	EF_BOUNCE_SHRAPNEL		(1<<2)		// special shrapnel flag
-//do not use eflags for server-only things, it wastes bandwidth -rww
-#define EF_RADAROBJECT			(1<<2)		// display on team radar
-
-#define	EF_TELEPORT_BIT			(1<<3)		// toggled every time the origin abruptly changes
-
-#define	EF_SHADER_ANIM			(1<<4)		// Animating shader (by s.frame)
-
-#define EF_PLAYER_EVENT			(1<<5)
-//#define	EF_BOUNCE				(1<<5)		// for missiles
-//#define	EF_BOUNCE_HALF			(1<<6)		// for missiles
-//these aren't even referenced in bg or client code and do not need to be eFlags, so I
-//am using these flags for rag stuff -rww
-
-#define EF_RAG					(1<<6)		//ragdoll him even if he's alive
-
-
-#define EF_PERMANENT			(1<<7)		// rww - I am claiming this. (for permanent entities)
-
-#define	EF_NODRAW				(1<<8)		// may have an event, but no model (unspawned items)
-#define	EF_FIRING				(1<<9)		// for lightning gun
-#define EF_ALT_FIRING			(1<<10)		// for alt-fires, mostly for lightning guns though
-#define	EF_JETPACK_ACTIVE		(1<<11)		//jetpack is activated
-
-#define EF_NOT_USED_1			(1<<12)		// not used
-
-#define	EF_TALK					(1<<13)		// draw a talk balloon
-#define	EF_CONNECTION			(1<<14)		// draw a connection trouble sprite
-#define	EF_NOT_USED_6			(1<<15)		// not used
-
-#define	EF_NOT_USED_2			(1<<16)		// not used
-#define	EF_NOT_USED_3			(1<<17)		// not used
-#define	EF_NOT_USED_4			(1<<18)		// not used
-
-#define	EF_BODYPUSH				(1<<19)		//rww - claiming this for fullbody push effect
-
-#define	EF_DOUBLE_AMMO			(1<<20)		// Hacky way to get around ammo max
-#define EF_SEEKERDRONE			(1<<21)		// show seeker drone floating around head
-#define EF_MISSILE_STICK		(1<<22)		// missiles that stick to the wall.
-#define EF_ITEMPLACEHOLDER		(1<<23)		// item effect
-#define EF_SOUNDTRACKER			(1<<24)		// sound position needs to be updated in relation to another entity
-#define EF_DROPPEDWEAPON		(1<<25)		// it's a dropped weapon
-#define EF_DISINTEGRATION		(1<<26)		// being disintegrated by the disruptor
-#define EF_INVULNERABLE			(1<<27)		// just spawned in or whatever, so is protected
-
-#define EF_CLIENTSMOOTH			(1<<28)		// standard lerporigin smooth override on client
-
-#define EF_JETPACK				(1<<29)		//rww - wearing a jetpack
-#define EF_JETPACK_FLAMING		(1<<30)		//rww - jetpack fire effect
-
-#define	EF_NOT_USED_5			(1<<31)		// not used
-
-//These new EF2_??? flags were added for NPCs, they really should not be used often.
-//NOTE: we only allow 10 of these!
-#define	EF2_HELD_BY_MONSTER		(1<<0)		// Being held by something, like a Rancor or a Wampa
-#define	EF2_USE_ALT_ANIM		(1<<1)		// For certain special runs/stands for creatures like the Rancor and Wampa whose runs/stands are conditional
-#define	EF2_ALERTED				(1<<2)		// For certain special anims, for Rancor: means you've had an enemy, so use the more alert stand
-#define	EF2_GENERIC_NPC_FLAG	(1<<3)		// So far, used for Rancor...
-#define	EF2_FLYING				(1<<4)		// Flying FIXME: only used on NPCs doesn't *really* have to be passed over, does it?
-#define	EF2_HYPERSPACE			(1<<5)		// Used to both start the hyperspace effect on the predicted client and to let the vehicle know it can now jump into hyperspace (after turning to face the proper angle)
-#define	EF2_BRACKET_ENTITY		(1<<6)		// Draw as bracketed
-#define	EF2_SHIP_DEATH			(1<<7)		// "died in ship" mode
-#define	EF2_NOT_USED_1			(1<<8)		// not used
-
-
-typedef enum {
-	EFFECT_NONE = 0,
-	EFFECT_SMOKE,
-	EFFECT_EXPLOSION,
-	EFFECT_EXPLOSION_PAS,
-	EFFECT_SPARK_EXPLOSION,
-	EFFECT_EXPLOSION_TRIPMINE,
-	EFFECT_EXPLOSION_DETPACK,
-	EFFECT_EXPLOSION_FLECHETTE,
-	EFFECT_STUNHIT,
-	EFFECT_EXPLOSION_DEMP2ALT,
-	EFFECT_EXPLOSION_TURRET,
-	EFFECT_SPARKS,
-	EFFECT_WATER_SPLASH,
-	EFFECT_ACID_SPLASH,
-	EFFECT_LAVA_SPLASH,
-	EFFECT_LANDING_MUD,
-	EFFECT_LANDING_SAND,
-	EFFECT_LANDING_DIRT,
-	EFFECT_LANDING_SNOW,
-	EFFECT_LANDING_GRAVEL,
-	EFFECT_MAX
-} effectTypes_t;
-
-// NOTE: may not have more than 16
-typedef enum {
-	PW_NONE,
-
-	#ifdef BASE_COMPAT
-		PW_QUAD,
-		PW_BATTLESUIT,
-	#endif // BASE_COMPAT
 
-	PW_PULL,
+	PERS_RED_SCORE,					// Blue team score
+	PERS_BLUE_SCORE,				// red team score
 
-	PW_REDFLAG,
-	PW_BLUEFLAG,
-	PW_NEUTRALFLAG,
-
-	PW_SHIELDHIT,
-
-	PW_SPEEDBURST,
-	PW_DISINT_4,
-	PW_SPEED,
-	PW_CLOAKED,
-	PW_FORCE_ENLIGHTENED_LIGHT,
-	PW_FORCE_ENLIGHTENED_DARK,
-	PW_FORCE_BOON,
-	PW_YSALAMIRI,
-
-	PW_NUM_POWERUPS
-
-} powerup_t;
-
-typedef enum {
-	HI_NONE,
-
-	HI_SEEKER,
-	HI_SHIELD,
-	HI_MEDPAC,
-	HI_MEDPAC_BIG,
-	HI_BINOCULARS,
-	HI_SENTRY_GUN,
-	HI_JETPACK,
-
-	HI_HEALTHDISP,
-	HI_AMMODISP,
-	HI_EWEB,
-	HI_CLOAK,
+	PERS_RED_ALIVE_COUNT,			// number of alive people on the red team
+	PERS_BLUE_ALIVE_COUNT,			// number of alive people on the blue team
+} persEnum_t;
 
-	HI_NUM_HOLDABLE
-} holdable_t;
+typedef enum
+{
+	GOGGLES_NONE,
+	GOGGLES_NIGHTVISION,
+	GOGGLES_INFRARED,
+	GOGGLES_MAX
 
+} goggleType_t;
 
-typedef enum {
-	CTFMESSAGE_FRAGGED_FLAG_CARRIER,
-	CTFMESSAGE_FLAG_RETURNED,
-	CTFMESSAGE_PLAYER_RETURNED_FLAG,
-	CTFMESSAGE_PLAYER_CAPTURED_FLAG,
-	CTFMESSAGE_PLAYER_GOT_FLAG
-} ctfMsg_t;
+// entityState_t->eFlags
+#define	EF_G2ANIMATING			(1<<0)		//perform g2 bone anims based on torsoAnim and legsAnim, works for ET_GENERAL -rww
+#define	EF_DEAD					0x00000001		// don't draw a foe marker over players with EF_DEAD
+#define EF_EXPLODE				0x00000002		// ready to explode
+#define	EF_TELEPORT_BIT			0x00000004		// toggled every time the origin abruptly changes
+								
+#define EF_PLAYER_EVENT			0x00000008
+#define	EF_BOUNCE				0x00000008		// for missiles
+								
+#define	EF_BOUNCE_HALF			0x00000010		// bounce and retain half velocity each time
+#define	EF_BOUNCE_SCALE			0x00000020		// bounces using the bounce scale
+#define	EF_NODRAW				0x00000040		// may have an event, but no model (unspawned items)
+#define	EF_FIRING				0x00000080		// for lightning gun
+#define EF_ALT_FIRING			0x00000100		// for alt-fires, mostly for lightning guns though
+#define	EF_MOVER_STOP			0x00000200		// will push otherwise
+#define	EF_TALK					0x00000400		// draw a talk balloon
+#define	EF_CONNECTION			0x00000800		// draw a connection trouble sprite
+#define	EF_VOTED				0x00001000		// already cast a vote
+#define	EF_ANGLE_OVERRIDE		0x00002000		// angle coming from the server is absolute
+#define EF_PERMANENT			0x00004000		// this entity is permanent and is never updated (sent only in the game state)
+												// this should only be used in RMG!
+#define EF_NOPICKUP				0x00008000		// entity cannot be picked up
+#define EF_NOSHADOW				0x00008000		// used for bodies when they are sinking
+
+#define EF_REDTEAM				0x00010000		// Red team only
+#define EF_BLUETEAM				0x00020000		// Blue team only
+#define	EF_INSKY				0x00040000		// In a sky brush
+
+#define EF_GOGGLES				0x00080000		// goggles on or not
+
+#define	EF_DUCKED				0x00100000		// ducked?
+#define	EF_INVULNERABLE			0x00200000		// cant be shot
+
+#define EFFECT_SMOKE 0
+#define EFFECT_EXPLOSION 1
+#define EFFECT_SPARK_EXPLOSION 2
 
 // reward sounds (stored in ps->persistant[PERS_PLAYEREVENTS])
 #define	PLAYEREVENT_DENIEDREWARD		0x0001
 #define	PLAYEREVENT_GAUNTLETREWARD		0x0002
+#define PLAYEREVENT_HOLYSHIT			0x0004
 
 // entityState_t->event values
 // entity events are for effects that take place reletive
@@ -736,11 +511,7 @@ typedef enum
 typedef enum {
 	EV_NONE,
 
-	EV_CLIENTJOIN,
-
 	EV_FOOTSTEP,
-	EV_FOOTSTEP_METAL,
-	EV_FOOTSPLASH,
 	EV_FOOTWADE,
 	EV_SWIM,
 
@@ -749,238 +520,93 @@ typedef enum {
 	EV_STEP_12,
 	EV_STEP_16,
 
-	EV_FALL,
-
-	EV_JUMP_PAD,			// boing sound at origin, jump sound on player
-
-	EV_GHOUL2_MARK,			//create a projectile impact mark on something with a client-side g2 instance.
-
-	EV_GLOBAL_DUEL,
-	EV_PRIVATE_DUEL,
+	EV_FALL_SHORT,
+	EV_FALL_MEDIUM,
+	EV_FALL_FAR,
 
 	EV_JUMP,
-	EV_ROLL,
+	EV_WATER_FOOTSTEP,
 	EV_WATER_TOUCH,	// foot touches
-	EV_WATER_LEAVE,	// foot leaves
-	EV_WATER_UNDER,	// head touches
-	EV_WATER_CLEAR,	// head leaves
+	EV_WATER_LAND,  // landed in water
+	EV_WATER_CLEAR,
 
 	EV_ITEM_PICKUP,			// normal item pickups are predictable
-	EV_GLOBAL_ITEM_PICKUP,	// powerup / team sounds are broadcast to everyone
-
-	EV_VEH_FIRE,
+	EV_ITEM_PICKUP_QUIET,	// quiet pickup
 
 	EV_NOAMMO,
 	EV_CHANGE_WEAPON,
+	EV_CHANGE_WEAPON_CANCELLED,
+	EV_READY_WEAPON,
 	EV_FIRE_WEAPON,
 	EV_ALT_FIRE,
-	EV_SABER_ATTACK,
-	EV_SABER_HIT,
-	EV_SABER_BLOCK,
-	EV_SABER_CLASHFLARE,
-	EV_SABER_UNHOLSTER,
-	EV_BECOME_JEDIMASTER,
-	EV_DISRUPTOR_MAIN_SHOT,
-	EV_DISRUPTOR_SNIPER_SHOT,
-	EV_DISRUPTOR_SNIPER_MISS,
-	EV_DISRUPTOR_HIT,
-	EV_DISRUPTOR_ZOOMSOUND,
-
-	EV_PREDEFSOUND,
-
-	EV_TEAM_POWER,
-
-	EV_SCREENSHAKE,
-
-	EV_LOCALTIMER,
 
 	EV_USE,			// +Use key
 
-	EV_USE_ITEM0,
-	EV_USE_ITEM1,
-	EV_USE_ITEM2,
-	EV_USE_ITEM3,
-	EV_USE_ITEM4,
-	EV_USE_ITEM5,
-	EV_USE_ITEM6,
-	EV_USE_ITEM7,
-	EV_USE_ITEM8,
-	EV_USE_ITEM9,
-	EV_USE_ITEM10,
-	EV_USE_ITEM11,
-	EV_USE_ITEM12,
-	EV_USE_ITEM13,
-	EV_USE_ITEM14,
-	EV_USE_ITEM15,
-
-	EV_ITEMUSEFAIL,
-
 	EV_ITEM_RESPAWN,
 	EV_ITEM_POP,
 	EV_PLAYER_TELEPORT_IN,
 	EV_PLAYER_TELEPORT_OUT,
 
 	EV_GRENADE_BOUNCE,		// eventParm will be the soundindex
-	EV_MISSILE_STICK,		// eventParm will be the soundindex
 
 	EV_PLAY_EFFECT,
-	EV_PLAY_EFFECT_ID,
-	EV_PLAY_PORTAL_EFFECT_ID,
-
-	EV_PLAYDOORSOUND,
-	EV_PLAYDOORLOOPSOUND,
-	EV_BMODEL_SOUND,
 
-	EV_MUTE_SOUND,
-	EV_VOICECMD_SOUND,
 	EV_GENERAL_SOUND,
 	EV_GLOBAL_SOUND,		// no attenuation
-	EV_GLOBAL_TEAM_SOUND,
 	EV_ENTITY_SOUND,
 
-	EV_PLAY_ROFF,
-
 	EV_GLASS_SHATTER,
-	EV_DEBRIS,
-	EV_MISC_MODEL_EXP,
-
-	EV_CONC_ALT_IMPACT,
 
 	EV_MISSILE_HIT,
 	EV_MISSILE_MISS,
-	EV_MISSILE_MISS_METAL,
+
+	EV_BULLET_HIT_WALL,
+	EV_BULLET_HIT_FLESH,
 	EV_BULLET,				// otherEntity is the shooter
 
+	EV_EXPLOSION_HIT_FLESH,
+
 	EV_PAIN,
-	EV_DEATH1,
-	EV_DEATH2,
-	EV_DEATH3,
+	EV_PAIN_WATER,
 	EV_OBITUARY,
 
-	#ifdef BASE_COMPAT
-		EV_POWERUP_QUAD,
-		EV_POWERUP_BATTLESUIT,
-	#endif // BASE_COMPAT
-
-	EV_FORCE_DRAINED,
-
-	EV_GIB_PLAYER,			// gib a previously living player
-	EV_SCOREPLUM,			// score plum
-
-	EV_CTFMESSAGE,
-
-	EV_BODYFADE,
-
-	EV_SIEGE_ROUNDOVER,
-	EV_SIEGE_OBJECTIVECOMPLETE,
-
 	EV_DESTROY_GHOUL2_INSTANCE,
 
-	EV_DESTROY_WEAPON_MODEL,
-
-	EV_GIVE_NEW_RANK,
-	EV_SET_FREE_SABER,
-	EV_SET_FORCE_DISABLE,
-
 	EV_WEAPON_CHARGE,
 	EV_WEAPON_CHARGE_ALT,
 
-	EV_SHIELD_HIT,
-
 	EV_DEBUG_LINE,
 	EV_TESTLINE,
 	EV_STOPLOOPINGSOUND,
-	EV_STARTLOOPINGSOUND,
-	EV_TAUNT,
-
-	//rww - Begin NPC sound events
-	EV_ANGER1,	//Say when acquire an enemy when didn't have one before
-	EV_ANGER2,
-	EV_ANGER3,
-
-	EV_VICTORY1,	//Say when killed an enemy
-	EV_VICTORY2,
-	EV_VICTORY3,
-
-	EV_CONFUSE1,	//Say when confused
-	EV_CONFUSE2,
-	EV_CONFUSE3,
-
-	EV_PUSHED1,		//Say when pushed
-	EV_PUSHED2,
-	EV_PUSHED3,
-
-	EV_CHOKE1,		//Say when choking
-	EV_CHOKE2,
-	EV_CHOKE3,
-
-	EV_FFWARN,		//ffire founds
-	EV_FFTURN,
-	//extra sounds for ST
-	EV_CHASE1,
-	EV_CHASE2,
-	EV_CHASE3,
-	EV_COVER1,
-	EV_COVER2,
-	EV_COVER3,
-	EV_COVER4,
-	EV_COVER5,
-	EV_DETECTED1,
-	EV_DETECTED2,
-	EV_DETECTED3,
-	EV_DETECTED4,
-	EV_DETECTED5,
-	EV_LOST1,
-	EV_OUTFLANK1,
-	EV_OUTFLANK2,
-	EV_ESCAPING1,
-	EV_ESCAPING2,
-	EV_ESCAPING3,
-	EV_GIVEUP1,
-	EV_GIVEUP2,
-	EV_GIVEUP3,
-	EV_GIVEUP4,
-	EV_LOOK1,
-	EV_LOOK2,
-	EV_SIGHT1,
-	EV_SIGHT2,
-	EV_SIGHT3,
-	EV_SOUND1,
-	EV_SOUND2,
-	EV_SOUND3,
-	EV_SUSPICIOUS1,
-	EV_SUSPICIOUS2,
-	EV_SUSPICIOUS3,
-	EV_SUSPICIOUS4,
-	EV_SUSPICIOUS5,
-	//extra sounds for Jedi
-	EV_COMBAT1,
-	EV_COMBAT2,
-	EV_COMBAT3,
-	EV_JDETECTED1,
-	EV_JDETECTED2,
-	EV_JDETECTED3,
-	EV_TAUNT1,
-	EV_TAUNT2,
-	EV_TAUNT3,
-	EV_JCHASE1,
-	EV_JCHASE2,
-	EV_JCHASE3,
-	EV_JLOST1,
-	EV_JLOST2,
-	EV_JLOST3,
-	EV_DEFLECT1,
-	EV_DEFLECT2,
-	EV_DEFLECT3,
-	EV_GLOAT1,
-	EV_GLOAT2,
-	EV_GLOAT3,
-	EV_PUSHFAIL,
-
-	EV_SIEGESPEC,
+
+	EV_BODY_QUEUE_COPY,
+	EV_BOTWAYPOINT,
+
+	// Procedural gore event.
+	EV_PROC_GORE,
+	
+	EV_GAMETYPE_RESTART,			// gametype restarting
+	EV_GAME_OVER,					// game is over
+
+	EV_GOGGLES,						// goggles turning on/off
+
+	EV_WEAPON_CALLBACK,
 	
 } entity_event_t;			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
 
+typedef enum
+{
+	VEV_TALKSTART,
+	VEV_TALKSTOP,
+
+} voice_event_t;
+
+typedef enum 
+{
+	GAME_OVER_TIMELIMIT,
+	GAME_OVER_SCORELIMIT,
+
+} game_over_t;
 
 typedef enum {
 	GTS_RED_CAPTURE,
@@ -997,112 +623,25 @@ typedef enum {
 } global_team_sound_t;
 
 
-
-typedef enum {
-	TEAM_FREE,
-	TEAM_RED,
-	TEAM_BLUE,
-	TEAM_SPECTATOR,
-
-	TEAM_NUM_TEAMS
-} team_t;
-
-typedef enum {
-	DUELTEAM_FREE,
-	DUELTEAM_LONE,
-	DUELTEAM_DOUBLE,
-
-	DUELTEAM_SINGLE,		// for regular duel matches (not power duel)
-} duelTeam_t;
-
 // Time between location updates
 #define TEAM_LOCATION_UPDATE_TIME		1000
 
 // How many players on the overlay
 #define TEAM_MAXOVERLAY		32
 
-//team task
-typedef enum {
-	TEAMTASK_NONE,
-	TEAMTASK_OFFENSE, 
-	TEAMTASK_DEFENSE,
-	TEAMTASK_PATROL,
-	TEAMTASK_FOLLOW,
-	TEAMTASK_RETRIEVE,
-	TEAMTASK_ESCORT,
-	TEAMTASK_CAMP
-} teamtask_t;
-
-// means of death
-typedef enum {
-	MOD_UNKNOWN,
-	MOD_STUN_BATON,
-	MOD_MELEE,
-	MOD_SABER,
-	MOD_BRYAR_PISTOL,
-	MOD_BRYAR_PISTOL_ALT,
-	MOD_BLASTER,
-	MOD_TURBLAST,
-	MOD_DISRUPTOR,
-	MOD_DISRUPTOR_SPLASH,
-	MOD_DISRUPTOR_SNIPER,
-	MOD_BOWCASTER,
-	MOD_REPEATER,
-	MOD_REPEATER_ALT,
-	MOD_REPEATER_ALT_SPLASH,
-	MOD_DEMP2,
-	MOD_DEMP2_ALT,
-	MOD_FLECHETTE,
-	MOD_FLECHETTE_ALT_SPLASH,
-	MOD_ROCKET,
-	MOD_ROCKET_SPLASH,
-	MOD_ROCKET_HOMING,
-	MOD_ROCKET_HOMING_SPLASH,
-	MOD_THERMAL,
-	MOD_THERMAL_SPLASH,
-	MOD_TRIP_MINE_SPLASH,
-	MOD_TIMED_MINE_SPLASH,
-	MOD_DET_PACK_SPLASH,
-	MOD_VEHICLE,
-	MOD_CONC,
-	MOD_CONC_ALT,
-	MOD_FORCE_DARK,
-	MOD_SENTRY,
-	MOD_WATER,
-	MOD_SLIME,
-	MOD_LAVA,
-	MOD_CRUSH,
-	MOD_TELEFRAG,
-	MOD_FALLING,
-	MOD_SUICIDE,
-	MOD_TARGET_LASER,
-	MOD_TRIGGER_HURT,
-	MOD_TEAM_CHANGE,
-	//AURELIO: when/if you put this back in, remember to make a case for it in all the other places where
-	//mod's are checked. Also, it probably isn't the most elegant solution for what you want - just add
-	//a frag back to the player after you call the player_die (and keep a local of his pre-death score to
-	//make sure he actually lost points, there may be cases where you don't lose points on changing teams
-	//or suiciding, and so you would actually be giving him a point) -Rich
-	// I put it back in for now, if it becomes a problem we'll work around it later (it shouldn't though)...
-	MOD_MAX
-} meansOfDeath_t;
-
 
 //---------------------------------------------------------
 
 // gitem_t->type
 typedef enum {
 	IT_BAD,
-	IT_WEAPON,				// EFX: rotate + upscale + minlight
-	IT_AMMO,				// EFX: rotate
-	IT_ARMOR,				// EFX: rotate + minlight
-	IT_HEALTH,				// EFX: static external sphere + rotating internal
-	IT_POWERUP,				// instant on, timer based
-							// EFX: rotate + external ring that rotates
-	IT_HOLDABLE,			// single use, holdable item
-							// EFX: rotate + bob
-	IT_PERSISTANT_POWERUP,
-	IT_TEAM
+	IT_WEAPON,		// Weapon item
+	IT_AMMO,		// Ammo item
+	IT_ARMOR,		// Armor item
+	IT_HEALTH,		// Healh item
+	IT_GAMETYPE,	// Custom gametype related item
+	IT_BACKPACK,	// replenish backpack item
+	IT_PASSIVE,		// Passive items
 } itemType_t;
 
 #define MAX_ITEM_MODELS 4
@@ -1111,18 +650,21 @@ typedef struct gitem_s {
 	char		*classname;	// spawning name
 	char		*pickup_sound;
 	char		*world_model[MAX_ITEM_MODELS];
-	char		*view_model;
+
 	char		*icon;
-//	char		*pickup_name;	// for printing on pickup
+	char		*render;
+	char		*pickup_prefix;					// an, some, a, the, etc..
+	char		*pickup_name;					// for printing on pickup
 
-	int			quantity;		// for ammo how much, or duration of powerup
-	itemType_t  giType;			// IT_* flags
+	int			quantity;						// for ammo how much
+	itemType_t  giType;							// IT_* flags
 
 	int			giTag;
 
-	char		*precaches;		// string of all models and images this item will use
-	char		*sounds;		// string of all sounds this item will use
-	char		*description;
+	char		*precaches;						// string of all models and images this item will use
+	char		*sounds;						// string of all sounds this item will use
+
+	int			outfittingGroup;
 } gitem_t;
 
 // included in both the game dll and the client
@@ -1134,18 +676,12 @@ float vectoyaw( const vec3_t vec );
 
 gitem_t	*BG_FindItem( const char *classname );
 gitem_t	*BG_FindItemForWeapon( weapon_t weapon );
-gitem_t	*BG_FindItemForPowerup( powerup_t pw );
-gitem_t	*BG_FindItemForHoldable( holdable_t pw );
 #define	ITEM_INDEX(x) ((x)-bg_itemlist)
 
 qboolean	BG_CanItemBeGrabbed( int gametype, const entityState_t *ent, const playerState_t *ps );
 
 
 
-#define SABER_BLOCK_DUR 150		// number of milliseconds a block animation should take.
-
-
-
 // g_dmflags->integer flags
 #define	DF_NO_FALLING			8
 #define DF_FIXED_FOV			16
@@ -1155,12 +691,11 @@ qboolean	BG_CanItemBeGrabbed( int gametype, const entityState_t *ent, const play
 // content masks
 #define	MASK_ALL				(-1)
 #define	MASK_SOLID				(CONTENTS_SOLID|CONTENTS_TERRAIN)
-#define	MASK_PLAYERSOLID		(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_BODY|CONTENTS_TERRAIN)
-#define	MASK_NPCSOLID			(CONTENTS_SOLID|CONTENTS_MONSTERCLIP|CONTENTS_BODY|CONTENTS_TERRAIN)
-#define	MASK_DEADSOLID			(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_TERRAIN)
-#define	MASK_WATER				(CONTENTS_WATER|CONTENTS_LAVA|CONTENTS_SLIME)
-#define	MASK_OPAQUE				(CONTENTS_SOLID|CONTENTS_SLIME|CONTENTS_LAVA|CONTENTS_TERRAIN)
-#define	MASK_SHOT				(CONTENTS_SOLID|CONTENTS_BODY|CONTENTS_CORPSE|CONTENTS_TERRAIN)
+#define	MASK_PLAYERSOLID		(CONTENTS_SOLID|CONTENTS_TERRAIN|CONTENTS_PLAYERCLIP|CONTENTS_BODY|CONTENTS_SHOTCLIP)
+#define	MASK_DEADSOLID			(CONTENTS_SOLID|CONTENTS_TERRAIN|CONTENTS_PLAYERCLIP)
+#define	MASK_WATER				(CONTENTS_WATER)
+#define	MASK_OPAQUE				(CONTENTS_SOLID|CONTENTS_TERRAIN|CONTENTS_SLIME|CONTENTS_LAVA)
+#define	MASK_SHOT				(CONTENTS_SOLID|CONTENTS_TERRAIN|CONTENTS_BODY|CONTENTS_SHOTCLIP)
 
 
 // ET_FX States (stored in modelindex2)
@@ -1178,8 +713,6 @@ typedef enum {
 	ET_PLAYER,
 	ET_ITEM,
 	ET_MISSILE,
-	ET_SPECIAL,				// rww - force fields
-	ET_HOLOCRON,			// rww - holocron icon displays
 	ET_MOVER,
 	ET_BEAM,
 	ET_PORTAL,
@@ -1187,11 +720,16 @@ typedef enum {
 	ET_PUSH_TRIGGER,
 	ET_TELEPORT_TRIGGER,
 	ET_INVISIBLE,
-	ET_NPC,					// ghoul2 player-like entity
-	ET_TEAM,
+	ET_GRAPPLE,				// grapple hooked on wall
 	ET_BODY,
+	ET_DAMAGEAREA,
 	ET_TERRAIN,
-	ET_FX,
+
+	ET_DEBUG_CYLINDER,
+
+	ET_GAMETYPE_TRIGGER,
+
+	ET_WALL,
 
 	ET_EVENTS				// any of the EV_* events can be added freestanding
 							// by setting eType to ET_EVENTS + eventNum
@@ -1208,233 +746,8 @@ typedef enum {
 #ifdef LS_NONE
 #undef LS_NONE
 #endif
-
-typedef enum {
-	//totally invalid
-	LS_INVALID	= -1,
-	// Invalid, or saber not armed
-	LS_NONE		= 0,
-
-	// General movements with saber
-	LS_READY,
-	LS_DRAW,
-	LS_PUTAWAY,
-
-	// Attacks
-	LS_A_TL2BR,//4
-	LS_A_L2R,
-	LS_A_BL2TR,
-	LS_A_BR2TL,
-	LS_A_R2L,
-	LS_A_TR2BL,
-	LS_A_T2B,
-	LS_A_BACKSTAB,
-	LS_A_BACK,
-	LS_A_BACK_CR,
-	LS_ROLL_STAB,
-	LS_A_LUNGE,
-	LS_A_JUMP_T__B_,
-	LS_A_FLIP_STAB,
-	LS_A_FLIP_SLASH,
-	LS_JUMPATTACK_DUAL,
-	LS_JUMPATTACK_ARIAL_LEFT,
-	LS_JUMPATTACK_ARIAL_RIGHT,
-	LS_JUMPATTACK_CART_LEFT,
-	LS_JUMPATTACK_CART_RIGHT,
-	LS_JUMPATTACK_STAFF_LEFT,
-	LS_JUMPATTACK_STAFF_RIGHT,
-	LS_BUTTERFLY_LEFT,
-	LS_BUTTERFLY_RIGHT,
-	LS_A_BACKFLIP_ATK,
-	LS_SPINATTACK_DUAL,
-	LS_SPINATTACK,
-	LS_LEAP_ATTACK,
-	LS_SWOOP_ATTACK_RIGHT,
-	LS_SWOOP_ATTACK_LEFT,
-	LS_TAUNTAUN_ATTACK_RIGHT,
-	LS_TAUNTAUN_ATTACK_LEFT,
-	LS_KICK_F,
-	LS_KICK_B,
-	LS_KICK_R,
-	LS_KICK_L,
-	LS_KICK_S,
-	LS_KICK_BF,
-	LS_KICK_RL,
-	LS_KICK_F_AIR,
-	LS_KICK_B_AIR,
-	LS_KICK_R_AIR,
-	LS_KICK_L_AIR,
-	LS_STABDOWN,
-	LS_STABDOWN_STAFF,
-	LS_STABDOWN_DUAL,
-	LS_DUAL_SPIN_PROTECT,
-	LS_STAFF_SOULCAL,
-	LS_A1_SPECIAL,
-	LS_A2_SPECIAL,
-	LS_A3_SPECIAL,
-	LS_UPSIDE_DOWN_ATTACK,
-	LS_PULL_ATTACK_STAB,
-	LS_PULL_ATTACK_SWING,
-	LS_SPINATTACK_ALORA,
-	LS_DUAL_FB,
-	LS_DUAL_LR,
-	LS_HILT_BASH,
-
-	//starts
-	LS_S_TL2BR,//26
-	LS_S_L2R,
-	LS_S_BL2TR,//# Start of attack chaining to SLASH LR2UL
-	LS_S_BR2TL,//# Start of attack chaining to SLASH LR2UL
-	LS_S_R2L,
-	LS_S_TR2BL,
-	LS_S_T2B,
-
-	//returns
-	LS_R_TL2BR,//33
-	LS_R_L2R,
-	LS_R_BL2TR,
-	LS_R_BR2TL,
-	LS_R_R2L,
-	LS_R_TR2BL,
-	LS_R_T2B,
-
-	//transitions
-	LS_T1_BR__R,//40
-	LS_T1_BR_TR,
-	LS_T1_BR_T_,
-	LS_T1_BR_TL,
-	LS_T1_BR__L,
-	LS_T1_BR_BL,
-	LS_T1__R_BR,//46
-	LS_T1__R_TR,
-	LS_T1__R_T_,
-	LS_T1__R_TL,
-	LS_T1__R__L,
-	LS_T1__R_BL,
-	LS_T1_TR_BR,//52
-	LS_T1_TR__R,
-	LS_T1_TR_T_,
-	LS_T1_TR_TL,
-	LS_T1_TR__L,
-	LS_T1_TR_BL,
-	LS_T1_T__BR,//58
-	LS_T1_T___R,
-	LS_T1_T__TR,
-	LS_T1_T__TL,
-	LS_T1_T___L,
-	LS_T1_T__BL,
-	LS_T1_TL_BR,//64
-	LS_T1_TL__R,
-	LS_T1_TL_TR,
-	LS_T1_TL_T_,
-	LS_T1_TL__L,
-	LS_T1_TL_BL,
-	LS_T1__L_BR,//70
-	LS_T1__L__R,
-	LS_T1__L_TR,
-	LS_T1__L_T_,
-	LS_T1__L_TL,
-	LS_T1__L_BL,
-	LS_T1_BL_BR,//76
-	LS_T1_BL__R,
-	LS_T1_BL_TR,
-	LS_T1_BL_T_,
-	LS_T1_BL_TL,
-	LS_T1_BL__L,
-
-	//Bounces
-	LS_B1_BR,
-	LS_B1__R,
-	LS_B1_TR,
-	LS_B1_T_,
-	LS_B1_TL,
-	LS_B1__L,
-	LS_B1_BL,
-
-	//Deflected attacks
-	LS_D1_BR,
-	LS_D1__R,
-	LS_D1_TR,
-	LS_D1_T_,
-	LS_D1_TL,
-	LS_D1__L,
-	LS_D1_BL,
-	LS_D1_B_,
-
-	//Reflected attacks
-	LS_V1_BR,
-	LS_V1__R,
-	LS_V1_TR,
-	LS_V1_T_,
-	LS_V1_TL,
-	LS_V1__L,
-	LS_V1_BL,
-	LS_V1_B_,
-
-	// Broken parries
-	LS_H1_T_,//
-	LS_H1_TR,
-	LS_H1_TL,
-	LS_H1_BR,
-	LS_H1_B_,
-	LS_H1_BL,
-
-	// Knockaways
-	LS_K1_T_,//
-	LS_K1_TR,
-	LS_K1_TL,
-	LS_K1_BR,
-	LS_K1_BL,
-
-	// Parries
-	LS_PARRY_UP,//
-	LS_PARRY_UR,
-	LS_PARRY_UL,
-	LS_PARRY_LR,
-	LS_PARRY_LL,
-
-	// Projectile Reflections
-	LS_REFLECT_UP,//
-	LS_REFLECT_UR,
-	LS_REFLECT_UL,
-	LS_REFLECT_LR,
-	LS_REFLECT_LL,
-
-	LS_MOVE_MAX//
-} saberMoveName_t;
-
-typedef enum {
-	Q_BR,
-	Q_R,
-	Q_TR,
-	Q_T,
-	Q_TL,
-	Q_L,
-	Q_BL,
-	Q_B,
-	Q_NUM_QUADS
-} saberQuadrant_t;
-
-typedef struct
-{
-	char *name;
-	int animToUse;
-	int	startQuad;
-	int	endQuad;
-	unsigned animSetFlags;
-	int blendTime;
-	int blocking;
-	saberMoveName_t chain_idle;			// What move to call if the attack button is not pressed at the end of this anim
-	saberMoveName_t chain_attack;		// What move to call if the attack button (and nothing else) is pressed
-	qboolean trailLength;
-} saberMoveData_t;
-
-
-extern saberMoveData_t	saberMoveData[LS_MOVE_MAX];
-
 bgEntity_t *PM_BGEntForNum( int num );
 qboolean BG_KnockDownable(playerState_t *ps);
-qboolean BG_LegalizedForcePowers(char *powerOut, int maxRank, qboolean freeSaber, int teamForce, int gametype, int fpDisabled);
 
 
 #ifdef __LCC__ //can't inline it then, it is declared over in bg_misc in this case
@@ -1501,21 +814,13 @@ void BG_G2ATSTAngles(void *ghoul2, int time, vec3_t cent_lerpAngles );
 int BG_AnimLength( int index, animNumber_t anim );
 
 qboolean BG_InSpecialJump( int anim );
-qboolean BG_InSaberStandAnim( int anim );
 qboolean BG_InReboundJump( int anim );
 qboolean BG_InReboundHold( int anim );
 qboolean BG_InReboundRelease( int anim );
 qboolean BG_InBackFlip( int anim );
 qboolean BG_DirectFlippingAnim( int anim );
-qboolean BG_SaberInAttack( int move );
-qboolean BG_SaberInSpecial( int move );
 qboolean BG_KickMove( int move );
-qboolean BG_SaberInIdle( int move );
 qboolean BG_FlippingAnim( int anim );
-qboolean BG_SpinningSaberAnim( int anim );
-qboolean BG_SaberInSpecialAttack( int anim );
-qboolean BG_SaberInKata( int saberMove );
-qboolean BG_InKataAnim(int anim);
 qboolean BG_KickingAnim( int anim );
 int BG_InGrappleMove(int anim);
 int BG_BrokenParryForAttack( int move );
@@ -1523,12 +828,6 @@ int BG_BrokenParryForParry( int move );
 int BG_KnockawayForParry( int move );
 qboolean BG_InRoll( playerState_t *ps, int anim );
 qboolean BG_InDeathAnim( int anim );
-qboolean BG_InSaberLockOld( int anim );
-qboolean BG_InSaberLock( int anim );
-
-void BG_SaberStartTransAnim( int clientNum, int saberAnimLevel, int weapon, int anim, float *animSpeed, int broken );
-
-void BG_ForcePowerDrain( playerState_t *ps, forcePowers_t forcePower, int overrideAmt );
 
 void	BG_EvaluateTrajectory( const trajectory_t *tr, int atTime, vec3_t result );
 void	BG_EvaluateTrajectoryDelta( const trajectory_t *tr, int atTime, vec3_t result );
@@ -1557,36 +856,14 @@ int BG_GetItemIndexByTag(int tag, int type);
 qboolean BG_IsItemSelectable(playerState_t *ps, int item);
 
 qboolean BG_HasYsalamiri(int gametype, playerState_t *ps);
-qboolean BG_CanUseFPNow(int gametype, playerState_t *ps, int time, forcePowers_t power);
-
-void *BG_Alloc ( int size );
-void *BG_AllocUnaligned ( int size );
-void *BG_TempAlloc( int size );
-void BG_TempFree( int size );
-char *BG_StringAlloc ( const char *source );
-qboolean BG_OutOfMemory ( void );
-
-void BG_BLADE_ActivateTrail ( bladeInfo_t *blade, float duration );
-void BG_BLADE_DeactivateTrail ( bladeInfo_t *blade, float duration );
-void BG_SI_Activate( saberInfo_t *saber );
-void BG_SI_Deactivate( saberInfo_t *saber );
-void BG_SI_BladeActivate( saberInfo_t *saber, int iBlade, qboolean bActive );
-qboolean BG_SI_Active(saberInfo_t *saber);
-void BG_SI_SetLength( saberInfo_t *saber, float length );
-void BG_SI_SetDesiredLength(saberInfo_t *saber, float len, int bladeNum);
-void BG_SI_SetLengthGradual( saberInfo_t *saber, int time );
-float BG_SI_Length(saberInfo_t *saber);
-float BG_SI_LengthMax(saberInfo_t *saber);
-void BG_SI_ActivateTrail ( saberInfo_t *saber, float duration );
-void BG_SI_DeactivateTrail ( saberInfo_t *saber, float duration );
+qboolean BG_CanUseFPNow(int gametype, playerState_t *ps, int time);
+
 extern void BG_AttachToRancor( void *ghoul2,float rancYaw,vec3_t rancOrigin,int time,qhandle_t *modelList,vec3_t modelScale,qboolean inMouth,vec3_t out_origin,vec3_t out_angles,vec3_t out_axis[3] );
 void BG_ClearRocketLock( playerState_t *ps );
 
 extern int WeaponReadyAnim[WP_NUM_WEAPONS];
 extern int WeaponAttackAnim[WP_NUM_WEAPONS];
 
-extern int forcePowerDarkLight[NUM_FORCE_POWERS];
-
 
 #define ARENAS_PER_TIER		4
 #define MAX_ARENAS			1024
@@ -1595,9 +872,5 @@ extern int forcePowerDarkLight[NUM_FORCE_POWERS];
 #define MAX_BOTS			1024
 #define MAX_BOTS_TEXT		8192
 
-#define	HYPERSPACE_TIME				4000 //For hyperspace triggers
-#define	HYPERSPACE_TELEPORT_FRAC	0.75f
-#define	HYPERSPACE_SPEED			10000.0f//was 30000
-#define	HYPERSPACE_TURN_RATE		45.0f
 
 #endif //__BG_PUBLIC_H__
diff --git a/codemp/game/bg_weapons.h b/codemp/game/bg_weapons.h
index 819c5bc..3ea0988 100644
--- a/codemp/game/bg_weapons.h
+++ b/codemp/game/bg_weapons.h
@@ -5,108 +5,364 @@
 #ifndef __WEAPONS_H__
 #define __WEAPONS_H__
 
+// means of death
+typedef enum 
+{
+	MOD_UNKNOWN,
+
+	// Knife
+	MOD_KNIFE,
+
+	// Pistols
+	MOD_M1911A1_PISTOL,
+	MOD_USSOCOM_PISTOL,         
+	MOD_SILVER_TALON,
+
+	// Secondarys
+	MOD_M590_SHOTGUN,
+	MOD_MICRO_UZI_SUBMACHINEGUN, 
+	MOD_M3A1_SUBMACHINEGUN,      
+	MOD_MP5,
+
+	// Primaries
+	MOD_USAS_12_SHOTGUN,         
+	MOD_M4_ASSAULT_RIFLE,        
+	MOD_AK74_ASSAULT_RIFLE,      
+	MOD_SIG551,
+
+	MOD_MSG90A1_SNIPER_RIFLE,    
+	MOD_M60_MACHINEGUN,          
+	MOD_MM1_GRENADE_LAUNCHER,    
+	MOD_RPG7_LAUNCHER,           
+
+	// Grenades
+	MOD_M84_GRENADE,
+	MOD_SMOHG92_GRENADE,
+	MOD_ANM14_GRENADE,
+	MOD_M15_GRENADE,
+
+	MOD_WATER,
+	MOD_CRUSH,
+	MOD_TELEFRAG,
+	MOD_FALLING,
+	MOD_SUICIDE,
+	MOD_TEAMCHANGE,
+	MOD_TARGET_LASER,
+	MOD_TRIGGER_HURT,
+	MOD_TRIGGER_HURT_NOSUICIDE
+
+} meansOfDeath_t;
+
 typedef enum {
 	WP_NONE,
 
-	WP_STUN_BATON,
-	WP_MELEE,
-	WP_SABER,
-	WP_BRYAR_PISTOL,
-	WP_BLASTER,
-	WP_DISRUPTOR,
-	WP_BOWCASTER,
-	WP_REPEATER,
-	WP_DEMP2,
-	WP_FLECHETTE,
-	WP_ROCKET_LAUNCHER,
-	WP_THERMAL,
-	WP_TRIP_MINE,
-	WP_DET_PACK,
-	WP_CONCUSSION,
-	WP_BRYAR_OLD,
-	WP_EMPLACED_GUN,
-	WP_TURRET,
-
-//	WP_GAUNTLET,
-//	WP_MACHINEGUN,			// Bryar
-//	WP_SHOTGUN,				// Blaster
-//	WP_GRENADE_LAUNCHER,	// Thermal
-//	WP_LIGHTNING,			// 
-//	WP_RAILGUN,				// 
-//	WP_GRAPPLING_HOOK,
+	// Knife
+	WP_KNIFE,
+
+	// Pistols
+	WP_M1911A1_PISTOL,
+	WP_USSOCOM_PISTOL,
+	WP_SILVER_TALON,
+
+	// Secondarys
+	WP_M590_SHOTGUN,
+	WP_MICRO_UZI_SUBMACHINEGUN,
+	WP_M3A1_SUBMACHINEGUN,
+	WP_MP5,
+
+	// Primaries
+	WP_USAS_12_SHOTGUN,
+	WP_M4_ASSAULT_RIFLE,
+	WP_AK74_ASSAULT_RIFLE,
+	WP_SIG551,
+
+	WP_MSG90A1,
+	WP_M60_MACHINEGUN,
+	WP_MM1_GRENADE_LAUNCHER,
+	WP_RPG7_LAUNCHER,
+
+	// Grenades
+	WP_M84_GRENADE,
+	WP_SMOHG92_GRENADE,
+	WP_ANM14_GRENADE,
+	WP_M15_GRENADE,
 
 	WP_NUM_WEAPONS
 } weapon_t;
 
-//anything > this will be considered not player useable
-#define LAST_USEABLE_WEAPON			WP_BRYAR_OLD
-
 typedef enum //# ammo_e
 {
+	AMMO_KNIFE,
+	AMMO_045,
+	AMMO_556,
+	AMMO_9,
+	AMMO_12 ,
+	AMMO_762,
+	AMMO_40,
+	AMMO_RPG7,
+	AMMO_M15,
+	AMMO_M84,
+	AMMO_SMOHG92,
+	AMMO_ANM14,
+
+	AMMO_762_BELT,
+
+	AMMO_MP5_9,
+
+	AMMO_MAX,
+
 	AMMO_NONE,
-	AMMO_FORCE,		// AMMO_PHASER
-	AMMO_BLASTER,	// AMMO_STARFLEET,
-	AMMO_POWERCELL,	// AMMO_ALIEN,
-	AMMO_METAL_BOLTS,
-	AMMO_ROCKETS,
-	AMMO_EMPLACED,
-	AMMO_THERMAL,
-	AMMO_TRIPMINE,
-	AMMO_DETPACK,
-	AMMO_MAX
 } ammo_t;
 
+#define WP_FIREMODE_NONE		0
+#define WP_FIREMODE_AUTO		1
+#define WP_FIREMODE_BURST		2
+#define WP_FIREMODE_SINGLE		3
+#define WP_FIREMODE_MAX			4
 
-typedef struct weaponData_s
+#define PROJECTILE_FIRE			0x0010	// projectile NOT bullet
+#define PROJECTILE_TIMED		0x0020	// projectile ONLY explodes after time is up
+#define PROJECTILE_GRAVITY		0x0040	// projectile obeys gravity
+#define PROJECTILE_DAMAGE_AREA	0x0080 // projectile does area damage over time
+#define UNLOCK_MUZZLEFLASH		0x0100	// muzzle flash is locked to muzzle bolt by default
+#define	PROJECTILE_LIGHTGRAVITY	0x0200	// projectile has light gravity
+
+typedef enum
 {
-//	char	classname[32];		// Spawning name
+	CAT_NONE = 0,
+	CAT_KNIFE,
+	CAT_PISTOL,
+	CAT_SHOTGUN,
+	CAT_SUB,
+	CAT_ASSAULT,
+	CAT_SNIPER,
+	CAT_HEAVY,
+	CAT_GRENADE,
+	CAT_MAX
+
+} ECategory;
+
+#define MAX_ZOOMNAME	8
+#define ZOOMLEVEL_MAX	3
+
+typedef struct zoomData_s
+{
+	int		fov;
+	char	name[MAX_ZOOMNAME];
+
+} zoomData_t;
+
+typedef struct attackData_s
+{
+	char			name[MAX_QPATH];
+	char			icon[MAX_QPATH];
+
+	const char*		melee;
+
+	meansOfDeath_t	mod;						// means of death
+	int				ammoIndex;					// Index to proper ammo slot
+	union 
+	{
+		int		range;							// Range of weapon 
+		int		velocity;						// speed of projectile
+	} rV;
 
-	int		ammoIndex;			// Index to proper ammo slot
-	int		ammoLow;			// Count when ammo is low
+	int			clipSize;						// how large is a clip
+	int			fireAmount;						// how much ammo to use per shot
+	int			fireFromClip;					// 0 = fire from approp. ammo pool, 1 = fire from clip
+	int			damage;							// how much damage is done per hit
+	float		inaccuracy;						// how inaccurate is weapon
+	float		zoomInaccuracy;					// how inaccurate is the weapon when zoomed
+	float		maxInaccuracy;					// maximum lvl of inaccuracy
+	int			pellets;						// how many individual 'bullets' are shot with one trigger pull?
+	int			weaponFlags;					// which fire modes are available, projectiles timed or impact, .etc
+	int			projectileLifetime;				// how long does projectile live (before exploding)
+	int			splashRadius;					// how large is splash damage radius
+	int			fireDelay;						// Extra delay when firing
+	qboolean	gore;							// is gore enabled for this attack?
+	int			extraClips;						// Extra clips you get when starting
+	float		bounceScale;					// how much something bounces
 
-	int		energyPerShot;		// Amount of energy used per shot
-	int		fireTime;			// Amount of time between firings
-	int		range;				// Range of weapon
-	
-	int		altEnergyPerShot;	// Amount of energy used for alt-fire
-	int		altFireTime;		// Amount of time between alt-firings
-	int		altRange;			// Range of alt-fire
+	vec3_t		minKickAngles;
+	vec3_t		maxKickAngles;
 
-	int		chargeSubTime;		// ms interval for subtracting ammo during charge
-	int		altChargeSubTime;	// above for secondary
+	// Names of effects, sounds, models, bones
+	char		muzzleEffect[MAX_QPATH];
+	char		muzzleEffectBone[MAX_QPATH];
+	char		muzzleEffectInWorld[MAX_QPATH];
+	char		tracerEffect[MAX_QPATH];
+	char		ejectBone[MAX_QPATH];
+	char		shellEject[MAX_QPATH];
+	char		explosionSound[MAX_QPATH];
+	char		explosionEffect[MAX_QPATH];
+	char		missileG2Model[MAX_QPATH];
 
-	int		chargeSub;			// amount to subtract during charge on each interval
-	int		altChargeSub;		// above for secondary
+	int			animFire;
+	int			animFireZoomed;
 
-	int		maxCharge;			// stop subtracting once charged for this many ms
-	int		altMaxCharge;		// above for secondary
+} attackData_t;
+
+typedef struct weaponData_s
+{
+	char			*classname;					// Spawning name
+	ECategory		category;					// what group of weapons is this one part of?
+	qboolean		safe;
+	char			worldModel[MAX_QPATH];		// world model
+	char			menuImage[MAX_QPATH];		// names of the icon files
+
+	int				animDrop;
+	int				animRaise;
+	int				animIdle;
+	int				animIdleZoomed;
+	int				animReload;
+	int				animReloadStart;
+	int				animReloadEnd;
+
+	attackData_t	attack[ATTACK_MAX];
+
+	zoomData_t		zoom[ZOOMLEVEL_MAX];
 } weaponData_t;
 
 
 typedef struct  ammoData_s
 {
-//	char	icon[32];	// Name of ammo icon file
-	int		max;		// Max amount player can hold of ammo
+	char	*name;				// name of ammo
+	char	icon[32];			// Name of ammo icon file
+	int		max;				// Max amount player can hold of ammo
+	float	goreScale;
 } ammoData_t;
 
 
+extern char *weaponNames[WP_NUM_WEAPONS];
 extern weaponData_t weaponData[WP_NUM_WEAPONS];
+extern char *ammoNames[AMMO_MAX];
 extern ammoData_t ammoData[AMMO_MAX];
 
 
 // Specific weapon information
 
-#define FIRST_WEAPON		WP_BRYAR_PISTOL		// this is the first weapon for next and prev weapon switching
-#define MAX_PLAYER_WEAPONS	WP_NUM_WEAPONS-1	// this is the max you can switch to and get with the give all.
+#define WP_FIRST_RANGED_WEAPON		WP_M1911A1_PISTOL	// this is the first weapon for next and prev weapon switching
+#define WP_FIRST_MELEE_WEAPON		WP_KNIFE
+#define MAX_PLAYER_WEAPONS			(WP_NUM_WEAPONS-1)	// this is the max you can switch to and get with the give all.
+
+#define	MAX_WEAPON_SOUNDS		12
+#define	MAX_WEAPON_SOUND_SLOTS	3
+
+#define MAX_SIDE_SURFACES 16
+
+typedef struct SOptionalWeapon
+{
+	char					mName[MAX_QPATH];
+	char					mMuzzle[MAX_QPATH];
+	char					*mSurfaces[MAX_SIDE_SURFACES];
+
+	struct SOptionalWeapon	*mNext;
+} TOptionalWeapon;
+
+typedef struct SBoltonWeapon
+{
+	char				mName[MAX_QPATH];
+	char				mModel[MAX_QPATH];
+	char				mParent[MAX_QPATH];
+	char				mBoltToBone[MAX_QPATH];
+	char				*mRightSide[MAX_SIDE_SURFACES];
+
+	char				mJointBone[MAX_QPATH];
+	char				mJointParentBone[MAX_QPATH];
+	char				mJointForward[10];
+	char				mJointRight[10];
+	char				mJointUp[10];
+} TBoltonWeapon;
+
+typedef struct SNoteTrack
+{
+	char					mNote[64];
+	int						mFrame;
+
+	struct SNoteTrack		*mNext;
+} TNoteTrack;
+
+#define	MAX_WEAPON_ANIM_CHOICES		4
+
+typedef struct SAnimInfoWeapon
+{
+	char					mName[MAX_QPATH];
+	char					mType[MAX_QPATH];
+	char					*mAnim[MAX_WEAPON_ANIM_CHOICES];
+	char					*mTransition[MAX_WEAPON_ANIM_CHOICES];
+	char					*mEnd[MAX_WEAPON_ANIM_CHOICES];
+	float					mSpeed;
+	int						mLODBias;
+	int						mNumChoices;
+							
+	int						mStartFrame[MAX_WEAPON_ANIM_CHOICES];
+	int						mNumFrames[MAX_WEAPON_ANIM_CHOICES];
+	int						mFPS[MAX_WEAPON_ANIM_CHOICES];
+
+	struct SNoteTrack		*mNoteTracks[MAX_WEAPON_ANIM_CHOICES];
+	struct SAnimInfoWeapon	*mNext;
+} TAnimInfoWeapon;
 
+typedef struct SAnimWeapon
+{
+	char					mName[MAX_QPATH];
+	char					mMuzzle[MAX_QPATH];
 
-#define DEFAULT_SHOTGUN_SPREAD	700
-#define DEFAULT_SHOTGUN_COUNT	11
+	struct SAnimInfoWeapon	*mInfos;
+	struct SAnimInfoWeapon	*mWeaponModelInfo;		// "weaponmodel" info
+	struct SAnimWeapon		*mNext;
 
-#define	LIGHTNING_RANGE		768
+} TAnimWeapon;
 
+typedef struct SWeaponModel
+{
+	char						mName[MAX_QPATH];
+	char						mModel[MAX_QPATH];
+	char						mBufferName[MAX_QPATH];
+	char						mBufferModel[MAX_QPATH];
+	char						mBufferBoltToBone[MAX_QPATH];
+	char						mBufferMuzzle[MAX_QPATH];
+	char						mBufferAltMuzzle[MAX_QPATH];
+	char						mLeftHandsBoltToBone[MAX_QPATH];
+	char						mRightHandsBoltToBone[MAX_QPATH];
+	char						*mFrontSurfaces[MAX_SIDE_SURFACES],
+								*mRightSideSurfaces[MAX_SIDE_SURFACES],
+								*mLeftSideSurfaces[MAX_SIDE_SURFACES];
 
+	struct SOptionalWeapon		*mOptionalList;
+	struct SBoltonWeapon		*mBolton;
+} TWeaponModel;
 
+#define MAX_CALLBACK_SURFACES	4
+
+typedef struct SOnOffSurface
+{
+	char	mName[64];
+	int		mStatus;
+} TOnOffSurface;
+
+typedef struct SSurfaceCallback
+{
+	char					mName[64];
+	struct SOnOffSurface	mOnOffSurfaces[MAX_CALLBACK_SURFACES];
+} TSurfaceCallback;
+
+#define MAX_SURFACE_CALLBACKS	2
+
+typedef struct SWeaponInfo
+{
+	char						*mName;
+	float						mForeshorten;
+	vec3_t						mViewOffset;
+	char						mSoundNames[MAX_WEAPON_SOUNDS][MAX_QPATH];
+	char						mSounds[MAX_WEAPON_SOUNDS][MAX_WEAPON_SOUND_SLOTS][MAX_QPATH];
+	struct SSurfaceCallback		mSurfaceCallbacks[MAX_SURFACE_CALLBACKS];
+	struct SAnimWeapon			*mAnimList;
+	struct SWeaponModel			mWeaponModel;
+} TWeaponParseInfo;
 
+extern TWeaponParseInfo	weaponParseInfo[WP_NUM_WEAPONS];
+extern char				weaponLeftHand[MAX_QPATH];
+extern char				weaponRightHand[MAX_QPATH];
 
 #endif//#ifndef __WEAPONS_H__
diff --git a/codemp/game/g_main.c b/codemp/game/g_main.c
index f0566a2..62eedf4 100644
--- a/codemp/game/g_main.c
+++ b/codemp/game/g_main.c
@@ -81,9 +81,9 @@ This must be the very first function compiled into the .q3vm file
 		return ConsoleCommand();
 	case BOTAI_START_FRAME:
 		return BotAIStartFrame( arg0 );
-	case GAME_ROFF_NOTETRACK_CALLBACK:
+	/*case GAME_ROFF_NOTETRACK_CALLBACK:
 		G_ROFF_NotetrackCallback( &g_entities[arg0], (const char *)arg1 );
-		return 0;
+		return 0;*/
 	case GAME_SPAWN_RMG_ENTITY:
 		if (G_ParseSpawnVars(qfalse))
 		{
@@ -92,7 +92,7 @@ This must be the very first function compiled into the .q3vm file
 		return 0;
 
 	//rww - begin icarus callbacks
-	case GAME_ICARUS_PLAYSOUND:
+	/*case GAME_ICARUS_PLAYSOUND:
 		{
 			T_G_ICARUS_PLAYSOUND *sharedMem = (T_G_ICARUS_PLAYSOUND *)gSharedBuffer;
 			return Q3_PlaySound(sharedMem->taskID, sharedMem->entID, sharedMem->name, sharedMem->channel);
@@ -204,9 +204,9 @@ This must be the very first function compiled into the .q3vm file
 			T_G_ICARUS_GETSETIDFORSTRING *sharedMem = (T_G_ICARUS_GETSETIDFORSTRING *)gSharedBuffer;
 			return GetIDForString(setTable, sharedMem->string);
 		}
-	//rww - end icarus callbacks
+	//rww - end icarus callbacks*/
 
-	case GAME_NAV_CLEARPATHTOPOINT:
+	/*case GAME_NAV_CLEARPATHTOPOINT:
 		return NAV_ClearPathToPoint(&g_entities[arg0], (float *)arg1, (float *)arg2, (float *)arg3, arg4, arg5);
 	case GAME_NAV_CLEARLOS:
 		return NPC_ClearLOS2(&g_entities[arg0], (const float *)arg1);
@@ -226,7 +226,7 @@ This must be the very first function compiled into the .q3vm file
 		CP_FindCombatPointWaypoints();
 		return 0;
 	case GAME_GETITEMINDEXBYTAG:
-		return BG_GetItemIndexByTag(arg0, arg1);
+		return BG_GetItemIndexByTag(arg0, arg1);*/
 	}
 
 	return -1;
diff --git a/codemp/game/g_public.h b/codemp/game/g_public.h
index 173cfa7..26daafc 100644
--- a/codemp/game/g_public.h
+++ b/codemp/game/g_public.h
@@ -113,10 +113,6 @@ typedef enum {
 	// this should NOT be used for any game related tasks,
 	// because it is not journaled
 
-	//Also for profiling.. do not use for game related tasks.
-	G_PRECISIONTIMER_START,
-	G_PRECISIONTIMER_END,
-
 	// console variable interaction
 	G_CVAR_REGISTER,	// ( vmCvar_t *vmCvar, const char *varName, const char *defaultValue, int flags );
 	G_CVAR_UPDATE,	// ( vmCvar_t *vmCvar );
@@ -147,6 +143,11 @@ typedef enum {
 	// the game needs to let the server system know where and how big the gentities
 	// are, so it can look at them directly without going through an interface
 
+	G_GET_WORLD_BOUNDS,		// ( vec3_t mins, vec3_t maxs )
+							// Returns the mins and maxs of the world
+
+	G_RMG_INIT,
+
 	G_DROP_CLIENT,		// ( int clientNum, const char *reason );
 	// kick a client off the server with a message
 
@@ -173,18 +174,14 @@ typedef enum {
 	G_GET_SERVERINFO,	// ( char *buffer, int bufferSize );
 	// the serverinfo info string has all the cvars visible to server browsers
 
-	G_SET_SERVER_CULL,
-	//server culling to reduce traffic on open maps -rww
-
 	G_SET_BRUSH_MODEL,	// ( gentity_t *ent, const char *name );
 	// sets mins and maxs based on the brushmodel name
 
+	G_SET_ACTIVE_SUBBSP,	// int index
+
 	G_TRACE,	// ( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask );
 	// collision detection against all linked entities
 
-	G_G2TRACE,	// ( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask );
-	// collision detection against all linked entities with ghoul2 check
-
 	G_POINT_CONTENTS,	// ( const vec3_t point, int passEntityNum );
 	// point contents against all linked entities
 
@@ -223,10 +220,9 @@ typedef enum {
 	// false when all tokens have been parsed.
 	// This should only be done at GAME_INIT time.
 
-	G_SIEGEPERSSET,
-	G_SIEGEPERSGET,
-
 	G_FS_GETFILELIST,
+	G_BOT_GET_MEMORY,
+	G_BOT_FREE_MEMORY,
 	G_DEBUG_POLYGON_CREATE,
 	G_DEBUG_POLYGON_DELETE,
 	G_REAL_TIME,
@@ -235,44 +231,6 @@ typedef enum {
 	G_TRACECAPSULE,	// ( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask );
 	G_ENTITY_CONTACTCAPSULE,	// ( const vec3_t mins, const vec3_t maxs, const gentity_t *ent );
 
-//	SP_REGISTER_SERVER_CMD,
-	SP_GETSTRINGTEXTSTRING,
-
-	G_ROFF_CLEAN,				// qboolean	ROFF_Clean(void);
-	G_ROFF_UPDATE_ENTITIES,		// void		ROFF_UpdateEntities(void);
-	G_ROFF_CACHE,				// int		ROFF_Cache(char *file);
-	G_ROFF_PLAY,				// qboolean	ROFF_Play(int entID, int roffID, qboolean doTranslation);
-	G_ROFF_PURGE_ENT,			// qboolean ROFF_PurgeEnt( int entID )
-
-	//rww - dynamic vm memory allocation!
-	G_TRUEMALLOC,
-	G_TRUEFREE,
-
-	//rww - icarus traps
-	G_ICARUS_RUNSCRIPT,
-	G_ICARUS_REGISTERSCRIPT,
-
-	G_ICARUS_INIT,
-	G_ICARUS_VALIDENT,
-	G_ICARUS_ISINITIALIZED,
-	G_ICARUS_MAINTAINTASKMANAGER,
-	G_ICARUS_ISRUNNING,
-	G_ICARUS_TASKIDPENDING,
-	G_ICARUS_INITENT,
-	G_ICARUS_FREEENT,
-	G_ICARUS_ASSOCIATEENT,
-	G_ICARUS_SHUTDOWN,
-	G_ICARUS_TASKIDSET,
-	G_ICARUS_TASKIDCOMPLETE,
-	G_ICARUS_SETVAR,
-	G_ICARUS_VARIABLEDECLARED,
-	G_ICARUS_GETFLOATVARIABLE,
-	G_ICARUS_GETSTRINGVARIABLE,
-	G_ICARUS_GETVECTORVARIABLE,
-
-	G_SET_SHARED_BUFFER,
-
-	//BEGIN VM STUFF
 	G_MEMSET = 100,
 	G_MEMCPY,
 	G_STRNCPY,
@@ -280,7 +238,6 @@ typedef enum {
 	G_COS,
 	G_ATAN2,
 	G_SQRT,
-	G_MATRIXMULTIPLY,
 	G_ANGLEVECTORS,
 	G_PERPENDICULARVECTOR,
 	G_FLOOR,
@@ -292,54 +249,9 @@ typedef enum {
 	G_ACOS,
 	G_ASIN,
 
-	//END VM STUFF
-
-	//rww - BEGIN NPC NAV TRAPS
-	G_NAV_INIT = 200,
-	G_NAV_FREE,
-	G_NAV_LOAD,
-	G_NAV_SAVE,
-	G_NAV_ADDRAWPOINT,
-	G_NAV_CALCULATEPATHS,
-	G_NAV_HARDCONNECT,
-	G_NAV_SHOWNODES,
-	G_NAV_SHOWEDGES,
-	G_NAV_SHOWPATH,
-	G_NAV_GETNEARESTNODE,
-	G_NAV_GETBESTNODE,
-	G_NAV_GETNODEPOSITION,
-	G_NAV_GETNODENUMEDGES,
-	G_NAV_GETNODEEDGE,
-	G_NAV_GETNUMNODES,
-	G_NAV_CONNECTED,
-	G_NAV_GETPATHCOST,
-	G_NAV_GETEDGECOST,
-	G_NAV_GETPROJECTEDNODE,
-	G_NAV_CHECKFAILEDNODES,
-	G_NAV_ADDFAILEDNODE,
-	G_NAV_NODEFAILED,
-	G_NAV_NODESARENEIGHBORS,
-	G_NAV_CLEARFAILEDEDGE,
-	G_NAV_CLEARALLFAILEDEDGES,
-	G_NAV_EDGEFAILED,
-	G_NAV_ADDFAILEDEDGE,
-	G_NAV_CHECKFAILEDEDGE,
-	G_NAV_CHECKALLFAILEDEDGES,
-	G_NAV_ROUTEBLOCKED,
-	G_NAV_GETBESTNODEALTROUTE,
-	G_NAV_GETBESTNODEALT2,
-	G_NAV_GETBESTPATHBETWEENENTS,
-	G_NAV_GETNODERADIUS,
-	G_NAV_CHECKBLOCKEDEDGES,
-	G_NAV_CLEARCHECKEDNODES,
-	G_NAV_CHECKEDNODE,
-	G_NAV_SETCHECKEDNODE,
-	G_NAV_FLAGALLNODES,
-	G_NAV_GETPATHSCALCULATED,
-	G_NAV_SETPATHSCALCULATED,
-	//rww - END NPC NAV TRAPS
-
-	BOTLIB_SETUP = 250,				// ( void );
+	G_MATRIXMULTIPLY,
+
+	BOTLIB_SETUP = 200,				// ( void );
 	BOTLIB_SHUTDOWN,				// ( void );
 	BOTLIB_LIBVAR_SET,
 	BOTLIB_LIBVAR_GET,
@@ -499,85 +411,73 @@ typedef enum {
 	BOTLIB_PC_FREE_SOURCE,
 	BOTLIB_PC_READ_TOKEN,
 	BOTLIB_PC_SOURCE_FILE_AND_LINE,
+	BOTLIB_PC_LOAD_GLOBAL_DEFINES,
+	BOTLIB_PC_REMOVE_ALL_GLOBAL_DEFINES,
 
-	/*
-Ghoul2 Insert Start
-*/
-	G_R_REGISTERSKIN,
 	G_G2_LISTBONES,
 	G_G2_LISTSURFACES,
 	G_G2_HAVEWEGHOULMODELS,
 	G_G2_SETMODELS,
 	G_G2_GETBOLT,
-	G_G2_GETBOLT_NOREC,
-	G_G2_GETBOLT_NOREC_NOROT,
 	G_G2_INITGHOUL2MODEL,
-	G_G2_SETSKIN,
-	G_G2_SIZE,
 	G_G2_ADDBOLT,
 	G_G2_SETBOLTINFO,
 	G_G2_ANGLEOVERRIDE,
 	G_G2_PLAYANIM,
-	G_G2_GETBONEANIM,
 	G_G2_GETGLANAME,
 	G_G2_COPYGHOUL2INSTANCE,
 	G_G2_COPYSPECIFICGHOUL2MODEL,
 	G_G2_DUPLICATEGHOUL2INSTANCE,
-	G_G2_HASGHOUL2MODELONINDEX,
 	G_G2_REMOVEGHOUL2MODEL,
-	G_G2_REMOVEGHOUL2MODELS,
 	G_G2_CLEANMODELS,
-	G_G2_COLLISIONDETECT,
-	G_G2_COLLISIONDETECTCACHE,
-
-	G_G2_SETROOTSURFACE,
-	G_G2_SETSURFACEONOFF,
-	G_G2_SETNEWORIGIN,
-	G_G2_DOESBONEEXIST,
-	G_G2_GETSURFACERENDERSTATUS,
-
-	G_G2_ABSURDSMOOTHING,
-
-/*
-	//rww - RAGDOLL_BEGIN
-*/
-	G_G2_SETRAGDOLL,
-	G_G2_ANIMATEG2MODELS,
-/*
-	//rww - RAGDOLL_END
-*/
-	//additional ragdoll options -rww
-	G_G2_RAGPCJCONSTRAINT,
-	G_G2_RAGPCJGRADIENTSPEED,
-	G_G2_RAGEFFECTORGOAL,
-	G_G2_GETRAGBONEPOS,
-	G_G2_RAGEFFECTORKICK,
-	G_G2_RAGFORCESOLVE,
-
-	//rww - ik move method, allows you to specify a bone and move it to a world point (within joint constraints)
-	//by using the majority of gil's existing bone angling stuff from the ragdoll code.
-	G_G2_SETBONEIKSTATE,
-	G_G2_IKMOVE,
-
-	G_G2_REMOVEBONE,
-
-	G_G2_ATTACHINSTANCETOENTNUM,
-	G_G2_CLEARATTACHEDINSTANCE,
-	G_G2_CLEANENTATTACHMENTS,
-	G_G2_OVERRIDESERVER,
-
-	G_G2_GETSURFACENAME,
-
-	G_SET_ACTIVE_SUBBSP,
+
+	// CGenericParser2 (void *) routines
+	G_GP_PARSE,
+	G_GP_PARSE_FILE,
+	G_GP_CLEAN,
+	G_GP_DELETE,
+	G_GP_GET_BASE_PARSE_GROUP,
+
+	// CGPGroup (void *) routines
+	G_GPG_GET_NAME,
+	G_GPG_GET_NEXT,
+	G_GPG_GET_INORDER_NEXT,
+	G_GPG_GET_INORDER_PREVIOUS,
+	G_GPG_GET_PAIRS,
+	G_GPG_GET_INORDER_PAIRS,
+	G_GPG_GET_SUBGROUPS,
+	G_GPG_GET_INORDER_SUBGROUPS,
+	G_GPG_FIND_SUBGROUP,
+	G_GPG_FIND_PAIR,
+	G_GPG_FIND_PAIRVALUE,
+
+	// CGPValue (void *) routines
+	G_GPV_GET_NAME,
+	G_GPV_GET_NEXT,
+	G_GPV_GET_INORDER_NEXT,
+	G_GPV_GET_INORDER_PREVIOUS,
+	G_GPV_IS_LIST,
+	G_GPV_GET_TOP_VALUE,
+	G_GPV_GET_LIST,
+
 	G_CM_REGISTER_TERRAIN,
-	G_RMG_INIT,
+	G_GET_MODEL_FORMALNAME,
 
-	G_BOT_UPDATEWAYPOINTS,
-	G_BOT_CALCULATEPATHS
-/*
-Ghoul2 Insert End
-*/
+	G_VM_LOCALALLOC,
+	G_VM_LOCALALLOCUNALIGNED,
+	G_VM_LOCALTEMPALLOC,
+	G_VM_LOCALTEMPFREE,
+	G_VM_LOCALSTRINGALLOC,
 
+	G_G2_COLLISIONDETECT,
+	G_G2_REGISTERSKIN,
+	G_G2_SETSKIN,
+	G_G2_GETANIMFILENAMEINDEX,
+
+	G_GT_INIT,
+	G_GT_RUNFRAME,
+	G_GT_START,
+	G_GT_SENDEVENT,
 } gameImport_t;
 
 //bstate.h
@@ -761,6 +661,10 @@ typedef enum {
 
 	GAME_RUN_FRAME,					// ( int levelTime );
 
+	GAME_GHOUL_INIT,
+
+	GAME_GHOUL_SHUTDOWN,
+
 	GAME_CONSOLE_COMMAND,			// ( void );
 	// ConsoleCommand will be called when a command has been issued
 	// that is not recognized as a builtin function.
@@ -769,39 +673,9 @@ typedef enum {
 
 	BOTAI_START_FRAME,				// ( int time );
 
-	GAME_ROFF_NOTETRACK_CALLBACK,	// int entnum, char *notetrack
-
-	GAME_SPAWN_RMG_ENTITY, //rwwRMG - added
-
-	//rww - icarus callbacks
-	GAME_ICARUS_PLAYSOUND,
-	GAME_ICARUS_SET,
-	GAME_ICARUS_LERP2POS,
-	GAME_ICARUS_LERP2ORIGIN,
-	GAME_ICARUS_LERP2ANGLES,
-	GAME_ICARUS_GETTAG,
-	GAME_ICARUS_LERP2START,
-	GAME_ICARUS_LERP2END,
-	GAME_ICARUS_USE,
-	GAME_ICARUS_KILL,
-	GAME_ICARUS_REMOVE,
-	GAME_ICARUS_PLAY,
-	GAME_ICARUS_GETFLOAT,
-	GAME_ICARUS_GETVECTOR,
-	GAME_ICARUS_GETSTRING,
-	GAME_ICARUS_SOUNDINDEX,
-	GAME_ICARUS_GETSETIDFORSTRING,
-	GAME_NAV_CLEARPATHTOPOINT,
-	GAME_NAV_CLEARLOS,
-	GAME_NAV_CLEARPATHBETWEENPOINTS,
-	GAME_NAV_CHECKNODEFAILEDFORENT,
-	GAME_NAV_ENTISUNLOCKEDDOOR,
-	GAME_NAV_ENTISDOOR,
-	GAME_NAV_ENTISBREAKABLE,
-	GAME_NAV_ENTISREMOVABLEUSABLE,
-	GAME_NAV_FINDCOMBATPOINTWAYPOINTS,
-	
-	GAME_GETITEMINDEXBYTAG
+	GAME_SPAWN_RMG_ENTITY,
+
+	GAME_GAMETYPE_COMMAND,			// ( int cmd, int arg0, int arg1, int arg2, int arg3, int arg4 );
 } gameExport_t;
 
 typedef struct
diff --git a/codemp/game/g_syscalls.c b/codemp/game/g_syscalls.c
index 0eea80e..e6002af 100644
--- a/codemp/game/g_syscalls.c
+++ b/codemp/game/g_syscalls.c
@@ -38,7 +38,7 @@ int		trap_Milliseconds( void ) {
 //Start should be suppled with a pointer to an empty pointer (e.g. void *blah; trap_PrecisionTimer_Start(&blah);),
 //the empty pointer will be filled with an exe address to our timer (this address means nothing in vm land however).
 //You must pass this pointer back unmodified to the timer end func.
-void trap_PrecisionTimer_Start(void **theNewTimer)
+/*void trap_PrecisionTimer_Start(void **theNewTimer)
 {
 	Q_syscall(G_PRECISIONTIMER_START, theNewTimer);
 }
@@ -47,7 +47,7 @@ void trap_PrecisionTimer_Start(void **theNewTimer)
 int trap_PrecisionTimer_End(void *theTimer)
 {
 	return Q_syscall(G_PRECISIONTIMER_END, theTimer);
-}
+}*/
 
 void	trap_Cvar_Register( vmCvar_t *cvar, const char *var_name, const char *value, int flags ) {
 	Q_syscall( G_CVAR_REGISTER, cvar, var_name, value, flags );
@@ -139,10 +139,10 @@ void trap_GetServerinfo( char *buffer, int bufferSize ) {
 }
 
 //server culling to reduce traffic on open maps -rww
-void trap_SetServerCull(float cullDistance)
+/*void trap_SetServerCull(float cullDistance)
 {
 	Q_syscall(G_SET_SERVER_CULL, PASSFLOAT(cullDistance));
-}
+}*/
 
 void trap_SetBrushModel( gentity_t *ent, const char *name ) {
 	Q_syscall( G_SET_BRUSH_MODEL, ent, name );
@@ -153,22 +153,22 @@ void trap_Trace( trace_t *results, const vec3_t start, const vec3_t mins, const
 }
 
 //g2TraceType 0 is no g2 col, 1 is collision against anything not EF_DEAD, 2 is collision against all.
-void trap_G2Trace( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask, int g2TraceType, int traceLod ) {
+/*void trap_G2Trace( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask, int g2TraceType, int traceLod ) {
 	Q_syscall( G_G2TRACE, results, start, mins, maxs, end, passEntityNum, contentmask, g2TraceType, traceLod );
-}
+}*/
 
 int trap_PointContents( const vec3_t point, int passEntityNum ) {
 	return Q_syscall( G_POINT_CONTENTS, point, passEntityNum );
 }
 
 
-qboolean trap_InPVS( const vec3_t p1, const vec3_t p2 ) {
+/*qboolean trap_InPVS( const vec3_t p1, const vec3_t p2 ) {
 	return Q_syscall( G_IN_PVS, p1, p2 );
 }
 
 qboolean trap_InPVSIgnorePortals( const vec3_t p1, const vec3_t p2 ) {
 	return Q_syscall( G_IN_PVS_IGNORE_PORTALS, p1, p2 );
-}
+}*/
 
 void trap_AdjustAreaPortalState( gentity_t *ent, qboolean open ) {
 	Q_syscall( G_ADJUST_AREA_PORTAL_STATE, ent, open );
@@ -210,14 +210,14 @@ qboolean trap_GetEntityToken( char *buffer, int bufferSize ) {
 	return Q_syscall( G_GET_ENTITY_TOKEN, buffer, bufferSize );
 }
 
-void trap_SiegePersSet(siegePers_t *pers)
+/*void trap_SiegePersSet(siegePers_t *pers)
 {
 	Q_syscall(G_SIEGEPERSSET, pers);
 }
 void trap_SiegePersGet(siegePers_t *pers)
 {
 	Q_syscall(G_SIEGEPERSGET, pers);
-}
+}*/
 
 int trap_FS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize ) {
 	return Q_syscall( G_FS_GETFILELIST, path, extension, listbuf, bufsize );
@@ -252,7 +252,7 @@ qboolean trap_EntityContactCapsule( const vec3_t mins, const vec3_t maxs, const
 //	return Q_syscall( SP_REGISTER_SERVER_CMD, package );
 //}
 
-int trap_SP_GetStringTextString(const char *text, char *buffer, int bufferLength)
+/*int trap_SP_GetStringTextString(const char *text, char *buffer, int bufferLength)
 {
 	return Q_syscall( SP_GETSTRINGTEXTSTRING, text, buffer, bufferLength );
 }
@@ -604,7 +604,7 @@ void trap_Nav_SetPathsCalculated(qboolean newVal)
 void trap_SV_RegisterSharedMemory(char *memory)
 {
 	Q_syscall(G_SET_SHARED_BUFFER, memory);
-}
+}*/
 
 // BotLib traps start here
 int trap_BotLibSetup( void ) {
@@ -1179,10 +1179,10 @@ int trap_PC_SourceFileAndLine( int handle, char *filename, int *line ) {
 /*
 Ghoul2 Insert Start
 */
-qhandle_t trap_R_RegisterSkin( const char *name )
+/*qhandle_t trap_R_RegisterSkin( const char *name )
 {
 	return Q_syscall( G_R_REGISTERSKIN, name );
-}
+}*/
 
 // CG Specific API calls
 void trap_G2_ListModelBones(void *ghlInfo, int frame)
@@ -1211,7 +1211,7 @@ qboolean trap_G2API_GetBoltMatrix(void *ghoul2, const int modelIndex, const int
 	return (qboolean)(Q_syscall(G_G2_GETBOLT, ghoul2, modelIndex, boltIndex, matrix, angles, position, frameNum, modelList, scale));
 }
 
-qboolean trap_G2API_GetBoltMatrix_NoReconstruct(void *ghoul2, const int modelIndex, const int boltIndex, mdxaBone_t *matrix,
+/*qboolean trap_G2API_GetBoltMatrix_NoReconstruct(void *ghoul2, const int modelIndex, const int boltIndex, mdxaBone_t *matrix,
 								const vec3_t angles, const vec3_t position, const int frameNum, qhandle_t *modelList, vec3_t scale)
 { //Same as above but force it to not reconstruct the skeleton before getting the bolt position
 	return (qboolean)(Q_syscall(G_G2_GETBOLT_NOREC, ghoul2, modelIndex, boltIndex, matrix, angles, position, frameNum, modelList, scale));
@@ -1221,7 +1221,7 @@ qboolean trap_G2API_GetBoltMatrix_NoRecNoRot(void *ghoul2, const int modelIndex,
 								const vec3_t angles, const vec3_t position, const int frameNum, qhandle_t *modelList, vec3_t scale)
 { //Same as above but force it to not reconstruct the skeleton before getting the bolt position
 	return (qboolean)(Q_syscall(G_G2_GETBOLT_NOREC_NOROT, ghoul2, modelIndex, boltIndex, matrix, angles, position, frameNum, modelList, scale));
-}
+}*/
 
 int trap_G2API_InitGhoul2Model(void **ghoul2Ptr, const char *fileName, int modelIndex, qhandle_t customSkin,
 						  qhandle_t customShader, int modelFlags, int lodBias)
@@ -1234,10 +1234,10 @@ qboolean trap_G2API_SetSkin(void *ghoul2, int modelIndex, qhandle_t customSkin,
 	return Q_syscall(G_G2_SETSKIN, ghoul2, modelIndex, customSkin, renderSkin);
 }
 
-int trap_G2API_Ghoul2Size ( void* ghlInfo )
+/*int trap_G2API_Ghoul2Size ( void* ghlInfo )
 {
 	return Q_syscall(G_G2_SIZE, ghlInfo );
-}
+}*/
 
 int trap_G2API_AddBolt(void *ghoul2, int modelIndex, const char *boneName)
 {
@@ -1262,11 +1262,11 @@ qboolean trap_G2API_SetBoneAnim(void *ghoul2, const int modelIndex, const char *
 	return Q_syscall(G_G2_PLAYANIM, ghoul2, modelIndex, boneName, startFrame, endFrame, flags, PASSFLOAT(animSpeed), currentTime, PASSFLOAT(setFrame), blendTime);
 }
 
-qboolean trap_G2API_GetBoneAnim(void *ghoul2, const char *boneName, const int currentTime, float *currentFrame,
+/*qboolean trap_G2API_GetBoneAnim(void *ghoul2, const char *boneName, const int currentTime, float *currentFrame,
 						   int *startFrame, int *endFrame, int *flags, float *animSpeed, int *modelList, const int modelIndex)
 {
 	return Q_syscall(G_G2_GETBONEANIM, ghoul2, boneName, currentTime, currentFrame, startFrame, endFrame, flags, animSpeed, modelList, modelIndex);
-}
+}*/
 
 void trap_G2API_GetGLAName(void *ghoul2, int modelIndex, char *fillBuf)
 {
@@ -1288,20 +1288,20 @@ void trap_G2API_DuplicateGhoul2Instance(void *g2From, void **g2To)
 	Q_syscall(G_G2_DUPLICATEGHOUL2INSTANCE, g2From, g2To);
 }
 
-qboolean trap_G2API_HasGhoul2ModelOnIndex(void *ghlInfo, int modelIndex)
+/*qboolean trap_G2API_HasGhoul2ModelOnIndex(void *ghlInfo, int modelIndex)
 {
 	return Q_syscall(G_G2_HASGHOUL2MODELONINDEX, ghlInfo, modelIndex);
-}
+}*/
 
 qboolean trap_G2API_RemoveGhoul2Model(void *ghlInfo, int modelIndex)
 {
 	return Q_syscall(G_G2_REMOVEGHOUL2MODEL, ghlInfo, modelIndex);
 }
 
-qboolean trap_G2API_RemoveGhoul2Models(void *ghlInfo)
+/*qboolean trap_G2API_RemoveGhoul2Models(void *ghlInfo)
 {
 	return Q_syscall(G_G2_REMOVEGHOUL2MODELS, ghlInfo);
-}
+}*/
 
 void trap_G2API_CleanGhoul2Models(void **ghoul2Ptr)
 {
@@ -1326,7 +1326,7 @@ void trap_G2API_CollisionDetect (
 	Q_syscall ( G_G2_COLLISIONDETECT, collRecMap, ghoul2, angles, position, frameNumber, entNum, rayStart, rayEnd, scale, traceFlags, useLod, PASSFLOAT(fRadius) );
 }
 
-void trap_G2API_CollisionDetectCache ( 
+/*void trap_G2API_CollisionDetectCache ( 
 	CollisionRecord_t *collRecMap, 
 	void* ghoul2, 
 	const vec3_t angles, 
@@ -1462,7 +1462,7 @@ void trap_G2API_CleanEntAttachments(void)
 qboolean trap_G2API_OverrideServer(void *serverInstance)
 {
 	return Q_syscall(G_G2_OVERRIDESERVER, serverInstance);
-}
+}*/
 
 /*
 Ghoul2 Insert End
@@ -1483,7 +1483,7 @@ void trap_RMG_Init(int terrainID)
 	Q_syscall(G_RMG_INIT, terrainID);
 }
 
-void trap_Bot_UpdateWaypoints(int wpnum, wpobject_t **wps)
+/*void trap_Bot_UpdateWaypoints(int wpnum, wpobject_t **wps)
 {
 	Q_syscall(G_BOT_UPDATEWAYPOINTS, wpnum, wps);
 }
@@ -1491,4 +1491,4 @@ void trap_Bot_UpdateWaypoints(int wpnum, wpobject_t **wps)
 void trap_Bot_CalculatePaths(int rmg)
 {
 	Q_syscall(G_BOT_CALCULATEPATHS, rmg);
-}
+}*/
diff --git a/codemp/game/g_xcvar.h b/codemp/game/g_xcvar.h
index 9e26cc2..9a22fa6 100644
--- a/codemp/game/g_xcvar.h
+++ b/codemp/game/g_xcvar.h
@@ -38,7 +38,7 @@ XCVAR_DEF( d_saberSPStyleDamage,		"1",			NULL,				CVAR_ARCHIVE,									qfalse )
 XCVAR_DEF( d_saberStanceDebug,			"0",			NULL,				CVAR_NONE,										qfalse )
 XCVAR_DEF( d_siegeSeekerNPC,			"0",			NULL,				CVAR_CHEAT,										qtrue )
 XCVAR_DEF( dedicated,					"0",			NULL,				CVAR_NONE,										qfalse )
-XCVAR_DEF( developer,					"0",			NULL,				CVAR_NONE,										qfalse )
+XCVAR_DEF( developer,					"1",			NULL,				CVAR_NONE,										qfalse )
 XCVAR_DEF( dmflags,						"0",			NULL,				CVAR_SERVERINFO|CVAR_ARCHIVE,					qtrue )
 XCVAR_DEF( duel_fraglimit,				"10",			NULL,				CVAR_SERVERINFO|CVAR_ARCHIVE|CVAR_NORESTART,	qtrue )
 XCVAR_DEF( fraglimit,					"20",			NULL,				CVAR_SERVERINFO|CVAR_ARCHIVE|CVAR_NORESTART,	qtrue )
diff --git a/codemp/game/game.vcxproj b/codemp/game/game.vcxproj
index d019bf5..4e5d40b 100644
--- a/codemp/game/game.vcxproj
+++ b/codemp/game/game.vcxproj
@@ -18,10 +18,12 @@
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
+    <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
+    <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
diff --git a/codemp/game/surfaceflags.h b/codemp/game/surfaceflags.h
index a01f1e1..54ad0ab 100644
--- a/codemp/game/surfaceflags.h
+++ b/codemp/game/surfaceflags.h
@@ -28,7 +28,6 @@
 #define	CONTENTS_INSIDE			0x10000000	// volume is considered to be inside (i.e. indoors)
 
 #define CONTENTS_SLIME			0x00020000	// CHC needs this since we use same tools
-#define CONTENTS_LIGHTSABER		0x00040000	// ""
 #define CONTENTS_TELEPORTER		0x00080000	// ""
 #define CONTENTS_ITEM			0x00100000	// ""
 #define CONTENTS_NOSHOT			0x00200000	// shots pass through me
diff --git a/codemp/ghoul2/G2.h b/codemp/ghoul2/G2.h
index b3f5ea6..c5e3bf3 100644
--- a/codemp/ghoul2/G2.h
+++ b/codemp/ghoul2/G2.h
@@ -8,22 +8,18 @@
 #define BONE_ANGLES_PREMULT			0x0001
 #define BONE_ANGLES_POSTMULT		0x0002
 #define BONE_ANGLES_REPLACE			0x0004
+#define	BONE_ANGLES_REPLACE_TO_ANIM	0x0400
+#define	BONE_ANGLES_RAGDOLL			0x0800
 
-//added for a trace optimization. set in routines where a bone is
-//set to be transformed in any way. -rww
-#define	BONE_NEED_TRANSFORM			0x8000
-
-//rww - RAGDOLL_BEGIN
-#define BONE_ANGLES_RAGDOLL			0x2000  // the rag flags give more details
-//rww - RAGDOLL_END
-#define BONE_ANGLES_IK				0x4000  // the rag flags give more details
-
-#define BONE_ANGLES_TOTAL			( BONE_ANGLES_PREMULT | BONE_ANGLES_POSTMULT | BONE_ANGLES_REPLACE )
+#define BONE_ANGLES_TOTAL			(BONE_ANGLES_RAGDOLL | BONE_ANGLES_PREMULT | BONE_ANGLES_POSTMULT | BONE_ANGLES_REPLACE | BONE_ANGLES_REPLACE_TO_ANIM )
 #define BONE_ANIM_OVERRIDE			0x0008
 #define BONE_ANIM_OVERRIDE_LOOP		0x0010
+#define BONE_ANIM_OVERRIDE_DEFAULT	( 0x0020 + BONE_ANIM_OVERRIDE )
 #define BONE_ANIM_OVERRIDE_FREEZE	( 0x0040 + BONE_ANIM_OVERRIDE )
 #define BONE_ANIM_BLEND				0x0080
-#define BONE_ANIM_TOTAL				( BONE_ANIM_OVERRIDE | BONE_ANIM_OVERRIDE_LOOP | BONE_ANIM_OVERRIDE_FREEZE | BONE_ANIM_BLEND)
+#define BONE_ANIM_BLEND_FROM_PARENT	0x0100
+#define BONE_ANIM_BLEND_TO_PARENT	0x0200
+#define BONE_ANIM_TOTAL				( BONE_ANIM_OVERRIDE | BONE_ANIM_OVERRIDE_LOOP | BONE_ANIM_OVERRIDE_DEFAULT | BONE_ANIM_OVERRIDE_FREEZE | BONE_ANIM_BLEND	| BONE_ANIM_BLEND_TO_PARENT | BONE_ANIM_BLEND_FROM_PARENT )
 
 
 // defines to setup the
diff --git a/codemp/ghoul2/G2_gore.h b/codemp/ghoul2/G2_gore.h
index b19d367..f4c8e9d 100644
--- a/codemp/ghoul2/G2_gore.h
+++ b/codemp/ghoul2/G2_gore.h
@@ -47,7 +47,6 @@ struct SGoreSurface
 	int			mGoreTag;
 	int			mDeleteTime;
 	int			mFadeTime;
-	bool		mFadeRGB;
 
 	int			mGoreGrowStartTime;
 	int			mGoreGrowEndTime;    // set this to -1 to disable growing
diff --git a/codemp/ghoul2/ghoul2_shared.h b/codemp/ghoul2/ghoul2_shared.h
index fb5c8ad..790a1b0 100644
--- a/codemp/ghoul2/ghoul2_shared.h
+++ b/codemp/ghoul2/ghoul2_shared.h
@@ -30,8 +30,6 @@ struct model_s;
 #define G2T_CG_TIME (1)
 #define NUM_G2T_TIME (2)
 
-//void		G2API_SetTime(int currentTime,int clock);
-//int		G2API_GetTime(int argTime); // this may or may not return arg depending on ghoul2_time cvar
 //rww - RAGDOLL_END
 
 //===================================================================
@@ -185,43 +183,6 @@ struct boltInfo_t{
 	{}
 };
 
-#ifdef _SOF2
-typedef enum
-{
-	PGORE_NONE,
-	PGORE_ARMOR,
-	PGORE_BULLETSMALL,
-	PGORE_BULLETMED,
-	PGORE_BULLETBIG,
-	PGORE_HEGRENADE,
-	PGORE_COUNT
-} goreEnum_t;
-
-struct goreEnumShader_t
-{
-	goreEnum_t		shaderEnum;
-	char			shaderName[MAX_QPATH];
-};
-
-struct SSkinGoreData
-{
-	vec3_t			angles;
-	vec3_t			position;
-	int				currentTime;
-	int				entNum;
-	vec3_t			rayDirection;	// in world space
-	vec3_t			hitLocation;	// in world space
-	vec3_t			scale;
-	float			SSize;			// size of splotch in the S texture direction in world units
-	float			TSize;			// size of splotch in the T texture direction in world units
-	float			theta;			// angle to rotate the splotch
-
-//	qhandle_t		shader;			// handle to shader for gore, this better be rendered after the shader of the underlying surface					
-									// this shader should also have "clamp" mode, not tiled.
-	goreEnum_t		shaderEnum;		// enum that'll get switched over to the shader's actual handle
-};
-#endif // _SOF2
-
 #define MAX_GHOUL_COUNT_BITS 8 // bits required to send across the MAX_G2_MODELS inside of the networking - this is the only restriction on ghoul models possible per entity
 
 typedef vector <surfaceInfo_t> surfaceInfo_v;
diff --git a/codemp/icarus/GameInterface.cpp b/codemp/icarus/GameInterface.cpp
index aa3de8d..2b97232 100644
--- a/codemp/icarus/GameInterface.cpp
+++ b/codemp/icarus/GameInterface.cpp
@@ -11,14 +11,14 @@
 #include "interface.h"
 #include "GameInterface.h"
 #include "qcommon/RoffSystem.h"
-#include "Q3_Interface.h"
+//#include "Q3_Interface.h"
 
 ICARUS_Instance		*iICARUS;
 bufferlist_t		ICARUS_BufferList;
 entlist_t			ICARUS_EntList;
 
 extern unsigned Com_BlockChecksum (const void *buffer, int length);
-extern	void	Q3_DebugPrint( int level, const char *format, ... );
+//extern	void	Q3_DebugPrint( int level, const char *format, ... );
 
 int			ICARUS_entFilter = -1;
 
@@ -124,10 +124,10 @@ int ICARUS_RunScript( sharedEntity_t *ent, const char *name )
 	if S_FAILED(gSequencers[ent->s.number]->Run( buf, len ))
 		return false;
 
-	if ( ( ICARUS_entFilter == -1 ) || ( ICARUS_entFilter == ent->s.number ) )
+	/*if ( ( ICARUS_entFilter == -1 ) || ( ICARUS_entFilter == ent->s.number ) )
 	{
 		Q3_DebugPrint( WL_VERBOSE, "%d Script %s executed by %s %s\n", svs.time, (char *) name, ent->classname, ent->targetname );
-	}
+	}*/
 
 	return true;
 }
@@ -140,7 +140,7 @@ Allocates a new ICARUS instance
 =================
 */
 
-void ICARUS_Init( void )
+/*void ICARUS_Init( void )
 {
 	//Link all interface functions
 	Interface_Init( &interface_export );
@@ -153,7 +153,7 @@ void ICARUS_Init( void )
 		Com_Error( ERR_DROP, "Unable to initialize ICARUS instance\n" );
 		return;
 	}
-}
+}*/
 
 /*
 =================
@@ -397,7 +397,7 @@ bool ICARUS_RegisterScript( const char *name, qboolean bCalledDuringInterrogate
 	return true;
 }
 
-void ICARUS_SoundPrecache(const char *filename)
+/*void ICARUS_SoundPrecache(const char *filename)
 {
 	T_G_ICARUS_SOUNDINDEX *sharedMem = (T_G_ICARUS_SOUNDINDEX *)sv.mSharedMemory;
 
@@ -413,7 +413,7 @@ int ICARUS_GetIDForString( const char *string )
 	strcpy(sharedMem->string, string);
 
 	return VM_Call(gvm, GAME_ICARUS_GETSETIDFORSTRING);
-}
+}*/
 
 /*
 -------------------------
@@ -426,7 +426,6 @@ ICARUS_InterrogateScript
 void ICARUS_InterrogateScript( const char *filename )
 {
 	CBlockStream	stream;
-	CBlockMember	*blockMember;
 	CBlock			block;
 
 	if (!Q_stricmp(filename,"NULL") || !Q_stricmp(filename,"default"))
@@ -465,9 +464,8 @@ void ICARUS_InterrogateScript( const char *filename )
 	if ( stream.Open( buf, len ) == qfalse )
 		return;
 
-	const char	*sVal1, *sVal2;
+	const char	*sVal1;
 	char		temp[1024];
-	int			setID;
 
 	//Now iterate through all blocks of the script, searching for keywords
 	while ( stream.BlockAvailable() )
@@ -516,13 +514,13 @@ void ICARUS_InterrogateScript( const char *filename )
 			
 			break;
 		
-		case ID_SOUND:
+		/*case ID_SOUND:
 			//We can't just call over to S_RegisterSound or whatever because this is on the server.
 			sVal1 = (const char *) block.GetMemberData( 1 );	//0 is channel, 1 is filename
 			ICARUS_SoundPrecache(sVal1);
-			break;
+			break;*/
 
-		case ID_SET:
+		/*case ID_SET:
 			blockMember = block.GetMember( 0 );
 
 			//NOTENOTE: This will not catch special case get() inlines! (There's not really a good way to do that)
@@ -572,7 +570,7 @@ void ICARUS_InterrogateScript( const char *filename )
 					break;
 				}
 			}
-			break;
+			break;*/
 
 		default:
 			break;
diff --git a/codemp/icarus/Q3_Interface.cpp b/codemp/icarus/Q3_Interface.cpp
index 21d41bd..4d0d7ea 100644
--- a/codemp/icarus/Q3_Interface.cpp
+++ b/codemp/icarus/Q3_Interface.cpp
@@ -308,7 +308,7 @@ Q3_PlaySound
 Plays a sound from an entity
 =============
 */
-static int Q3_PlaySound( int taskID, int entID, const char *name, const char *channel )
+/*static int Q3_PlaySound( int taskID, int entID, const char *name, const char *channel )
 {
 	T_G_ICARUS_PLAYSOUND *sharedMem = (T_G_ICARUS_PLAYSOUND *)sv.mSharedMemory;
 
@@ -318,7 +318,7 @@ static int Q3_PlaySound( int taskID, int entID, const char *name, const char *ch
 	strcpy(sharedMem->channel, channel);
 
 	return VM_Call(gvm, GAME_ICARUS_PLAYSOUND);
-}
+}*/
 
 
 /*
@@ -383,7 +383,7 @@ Q3_Set
   Argument		: const char *data
 ============
 */
-static void Q3_Set( int taskID, int entID, const char *type_name, const char *data )
+/*static void Q3_Set( int taskID, int entID, const char *type_name, const char *data )
 {
 	T_G_ICARUS_SET *sharedMem = (T_G_ICARUS_SET *)sv.mSharedMemory;
 
@@ -396,7 +396,7 @@ static void Q3_Set( int taskID, int entID, const char *type_name, const char *da
 	{
 		gTaskManagers[entID]->Completed( taskID );
 	}
-}
+}*/
 
 
 /*
diff --git a/codemp/icarus/Q3_Interface.h b/codemp/icarus/Q3_Interface.h
index 53e8da0..438af1c 100644
--- a/codemp/icarus/Q3_Interface.h
+++ b/codemp/icarus/Q3_Interface.h
@@ -178,7 +178,6 @@ typedef enum //# setType_e
 	SET_TREASONED,//## %t="BOOL_TYPES" # Player has turned on his own- scripts will stop, NPCs will turn on him and level changes load the brig
 	SET_DISABLE_SHADER_ANIM,//## %t="BOOL_TYPES" # Allows turning off an animating shader in a script
 	SET_SHADER_ANIM,//## %t="BOOL_TYPES" # Sets a shader with an image map to be under frame control
-	SET_SABERACTIVE,//## %t="BOOL_TYPES" # Turns saber on/off
 	SET_ADJUST_AREA_PORTALS,//## %t="BOOL_TYPES" # Only set this on things you move with script commands that you *want* to open/close area portals.  Default is off.
 	SET_DMG_BY_HEAVY_WEAP_ONLY,//## %t="BOOL_TYPES" # When true, only a heavy weapon class missile/laser can damage this ent.
 	SET_SHIELDED,//## %t="BOOL_TYPES" # When true, ion_cannon is shielded from any kind of damage.
@@ -217,18 +216,6 @@ typedef enum //# setType_e
 	SET_ITEM,//## %t="ITEM_NAMES" # Give items
 	SET_MUSIC_STATE,//## %t="MUSIC_STATES" # Set the state of the dynamic music
 
-	SET_FORCE_HEAL_LEVEL,//## %t="FORCE_LEVELS" # Change force power level
-	SET_FORCE_JUMP_LEVEL,//## %t="FORCE_LEVELS" # Change force power level
-	SET_FORCE_SPEED_LEVEL,//## %t="FORCE_LEVELS" # Change force power level
-	SET_FORCE_PUSH_LEVEL,//## %t="FORCE_LEVELS" # Change force power level
-	SET_FORCE_PULL_LEVEL,//## %t="FORCE_LEVELS" # Change force power level
-	SET_FORCE_MINDTRICK_LEVEL,//## %t="FORCE_LEVELS" # Change force power level
-	SET_FORCE_GRIP_LEVEL,//## %t="FORCE_LEVELS" # Change force power level
-	SET_FORCE_LIGHTNING_LEVEL,//## %t="FORCE_LEVELS" # Change force power level
-	SET_SABER_THROW,//## %t="FORCE_LEVELS" # Change force power level
-	SET_SABER_DEFENSE,//## %t="FORCE_LEVELS" # Change force power level
-	SET_SABER_OFFENSE,//## %t="FORCE_LEVELS" # Change force power level
-
 	SET_OBJECTIVE_SHOW,	//## %t="OBJECTIVES" # Show objective on mission screen
 	SET_OBJECTIVE_HIDE,	//## %t="OBJECTIVES" # Hide objective from mission screen
 	SET_OBJECTIVE_SUCCEEDED,//## %t="OBJECTIVES" # Mark objective as completed
diff --git a/codemp/icarus/Q3_Registers.cpp b/codemp/icarus/Q3_Registers.cpp
index bc0c713..26eeb9a 100644
--- a/codemp/icarus/Q3_Registers.cpp
+++ b/codemp/icarus/Q3_Registers.cpp
@@ -4,7 +4,7 @@
 #include "game/g_public.h"
 #include "Q3_Registers.h"
 
-extern	void	Q3_DebugPrint( int level, const char *format, ... );
+//extern	void	Q3_DebugPrint( int level, const char *format, ... );
 
 varString_m		varStrings;
 varFloat_m		varFloats;
@@ -55,7 +55,7 @@ void Q3_DeclareVariable( int type, const char *name )
 
 	if ( numVariables > MAX_VARIABLES )
 	{
-		Q3_DebugPrint( WL_ERROR, "too many variables already declared, maximum is %d\n", MAX_VARIABLES );
+		//Q3_DebugPrint( WL_ERROR, "too many variables already declared, maximum is %d\n", MAX_VARIABLES );
 		return;
 	}
 
@@ -74,7 +74,7 @@ void Q3_DeclareVariable( int type, const char *name )
 		break;
 
 	default:
-		Q3_DebugPrint( WL_ERROR, "unknown 'type' for declare() function!\n" );
+		//Q3_DebugPrint( WL_ERROR, "unknown 'type' for declare() function!\n" );
 		return;
 		break;
 	}
@@ -195,8 +195,8 @@ void Q3_InitVariables( void )
 	varFloats.clear();
 	varVectors.clear();
 
-	if ( numVariables > 0 )
-		Q3_DebugPrint( WL_WARNING, "%d residual variables found!\n", numVariables );
+	/*if ( numVariables > 0 )
+		Q3_DebugPrint( WL_WARNING, "%d residual variables found!\n", numVariables );*/
 
 	numVariables = 0;
 }
diff --git a/codemp/png/png.cpp b/codemp/png/png.cpp
index 2d3b468..aa640cd 100644
--- a/codemp/png/png.cpp
+++ b/codemp/png/png.cpp
@@ -594,7 +594,7 @@ bool PNG_Save(const char *name, byte *data, int width, int height, int bytedepth
 	png_error = PNG_ERROR_OK;
 
 	// Create the file
-	fp = ri.FS_FOpenFileWrite(name);
+	fp = ri.FS_FOpenFileWrite(name, false);
 	if(!fp)
 	{
 		png_error = PNG_ERROR_CREATE_FAIL;
diff --git a/codemp/qcommon/RoffSystem.cpp b/codemp/qcommon/RoffSystem.cpp
index f9ce967..19df37f 100644
--- a/codemp/qcommon/RoffSystem.cpp
+++ b/codemp/qcommon/RoffSystem.cpp
@@ -889,7 +889,7 @@ qboolean CROFFSystem::ApplyROFF( SROFFEntity *roff_ent, CROFFSystem::CROFF *roff
 	SetLerp( angleTrajectory, TR_LINEAR, angle, 
 				roff->mMoveRotateList[roff_ent->mROFFFrame].mRotateOffset, svs.time, roff->mLerp );
 
-	if (roff->mMoveRotateList[roff_ent->mROFFFrame].mStartNote >= 0)
+	/*if (roff->mMoveRotateList[roff_ent->mROFFFrame].mStartNote >= 0)
 	{
 		int		i;
 
@@ -897,7 +897,7 @@ qboolean CROFFSystem::ApplyROFF( SROFFEntity *roff_ent, CROFFSystem::CROFF *roff
 		{
 			ProcessNote(roff_ent, roff->mNoteTrackIndexes[roff->mMoveRotateList[roff_ent->mROFFFrame].mStartNote + i]);
 		}
-	}
+	}*/
 
 	// Advance ROFF frames and lock to a 10hz cycle
 	roff_ent->mROFFFrame++;
@@ -924,7 +924,7 @@ qboolean CROFFSystem::ApplyROFF( SROFFEntity *roff_ent, CROFFSystem::CROFF *roff
  *    none                                                                                      *
  *                                                                                              *
  ************************************************************************************************/
-void CROFFSystem::ProcessNote(SROFFEntity *roff_ent, char *note)
+/*void CROFFSystem::ProcessNote(SROFFEntity *roff_ent, char *note)
 {
 	char	temp[1024];
 	int		pos, size;
@@ -958,7 +958,7 @@ void CROFFSystem::ProcessNote(SROFFEntity *roff_ent, char *note)
 			}
 		}
 	}
-}
+}*/
 
 //---------------------------------------------------------------------------
 // CROFFSystem::ClearLerp
diff --git a/codemp/qcommon/RoffSystem.h b/codemp/qcommon/RoffSystem.h
index 669ea88..230c883 100644
--- a/codemp/qcommon/RoffSystem.h
+++ b/codemp/qcommon/RoffSystem.h
@@ -147,7 +147,7 @@ private:
 	qboolean	ApplyROFF( SROFFEntity *roff_ent,
 					CROFFSystem::CROFF *roff );	// True = success; False = roff complete
 
-	void	ProcessNote(SROFFEntity *roff_ent, char *note);
+	//void	ProcessNote(SROFFEntity *roff_ent, char *note);
 
 	void	SetLerp( trajectory_t *tr, 
 					trType_t, vec3_t origin, 
diff --git a/codemp/qcommon/cm_shader.cpp b/codemp/qcommon/cm_shader.cpp
index 757aa92..e200359 100644
--- a/codemp/qcommon/cm_shader.cpp
+++ b/codemp/qcommon/cm_shader.cpp
@@ -490,7 +490,7 @@ void CM_ShutdownShaderProperties(void)
 {
 	if(cmShaderTable.count())
 	{
-//		Com_Printf("Shutting down cmShaderTable .....\n");
+		Com_Printf("Shutting down cmShaderTable .....\n");
 		cmShaderTable.clear();
 	}
 }
diff --git a/codemp/qcommon/common.cpp b/codemp/qcommon/common.cpp
index 081c69d..9a3f916 100644
--- a/codemp/qcommon/common.cpp
+++ b/codemp/qcommon/common.cpp
@@ -4,13 +4,12 @@
 #include "qcommon/exe_headers.h"
 
 #include "GenericParser2.h"
-#include "stringed_ingame.h"
 #include "qcommon/game_version.h"
 #ifndef __linux__
 #include "qcommon/platform.h"
 #endif
 
-#include "../server/NPCNav/navigator.h"
+//#include "../server/NPCNav/navigator.h"
 
 #define	MAXPRINTMSG	4096
 
@@ -1082,7 +1081,7 @@ void Com_Init( char *commandLine ) {
 
 		Cvar_Init ();
 
-		navigator.Init();
+		//navigator.Init();
 
 		// prepare enough of the subsystems to handle
 		// cvar and command buffer management
@@ -1111,7 +1110,7 @@ void Com_Init( char *commandLine ) {
 
 		Com_InitJournaling();
 
-		Cbuf_AddText ("exec mpdefault.cfg\n");
+		Cbuf_AddText ("exec sof2mp_default.cfg\n");
 
 		// skip the jampconfig.cfg if "safe" is on the command line
 		if ( !Com_SafeMode() ) {
@@ -1144,9 +1143,13 @@ void Com_Init( char *commandLine ) {
 		com_maxfps = Cvar_Get ("com_maxfps", "125", CVAR_ARCHIVE);
 		com_blood = Cvar_Get ("com_blood", "1", CVAR_ARCHIVE);
 
+#ifdef _DEBUG
+		com_developer = Cvar_Get ("developer", "1", CVAR_TEMP );
+#else
 		com_developer = Cvar_Get ("developer", "0", CVAR_TEMP );
-		com_vmdebug = Cvar_Get ("vmdebug", "0", CVAR_TEMP );
-		com_logfile = Cvar_Get ("logfile", "0", CVAR_TEMP );
+#endif
+		com_vmdebug = Cvar_Get ("vmdebug", "1", CVAR_TEMP );
+		com_logfile = Cvar_Get ("logfile", "2", CVAR_TEMP );
 
 		com_timescale = Cvar_Get ("timescale", "1", CVAR_CHEAT | CVAR_SYSTEMINFO );
 		com_fixedtime = Cvar_Get ("fixedtime", "0", CVAR_CHEAT);
@@ -1217,8 +1220,6 @@ void Com_Init( char *commandLine ) {
 		s = va("%s %s %s", JK_VERSION, PLATFORM_STRING, __DATE__ );
 		com_version = Cvar_Get ("version", s, CVAR_ROM | CVAR_SERVERINFO );
 
-		SE_Init();
-
 		Sys_Init();
 		Netchan_Init( Com_Milliseconds() & 0xffff );	// pick a port value that should be nice and random
 		VM_Init();
@@ -1286,7 +1287,7 @@ void Com_WriteConfigToFile( const char *filename ) {
 		return;
 	}
 
-	FS_Printf (f, "// generated by Star Wars Jedi Academy MP, do not modify\n");
+	FS_Printf (f, "// generated by soldier of fortune 2, do not modify\n");
 	Key_WriteBindings (f);
 	Cvar_WriteVariables (f);
 	FS_FCloseFile( f );
@@ -1579,7 +1580,6 @@ try
 Com_Shutdown
 =================
 */
-void MSG_shutdownHuffman();
 void Com_Shutdown (void) 
 {
 	CM_ClearMap();
@@ -1594,17 +1594,6 @@ void Com_Shutdown (void)
 		FS_FCloseFile( com_journalFile );
 		com_journalFile = 0;
 	}
-
-	MSG_shutdownHuffman();
-/*
-	// Only used for testing changes to huffman frequency table when tuning.
-	{
-		extern float Huff_GetCR(void);
-		char mess[256];
-		sprintf(mess,"Eff. CR = %f\n",Huff_GetCR());
-		OutputDebugString(mess);
-	}
-*/
 }
 
 
diff --git a/codemp/qcommon/cvar.cpp b/codemp/qcommon/cvar.cpp
index 3e01c41..62c59dd 100644
--- a/codemp/qcommon/cvar.cpp
+++ b/codemp/qcommon/cvar.cpp
@@ -323,10 +323,10 @@ cvar_t *Cvar_Get( const char *var_name, const char *var_value, int flags ) {
 
 	// link the variable in
 	var->next = cvar_vars;
-	if(cvar_vars)
-		cvar_vars->prev = var;
+	/*if(cvar_vars)
+		cvar_vars->prev = var;*/
 
-	var->prev = NULL;
+	//var->prev = NULL;
 	cvar_vars = var;
 
 	var->flags = flags;
@@ -334,13 +334,13 @@ cvar_t *Cvar_Get( const char *var_name, const char *var_value, int flags ) {
 	cvar_modifiedFlags |= var->flags;
 
 	hash = generateHashValue(var_name);
-	var->hashIndex = hash;
+	//var->hashIndex = hash;
 
 	var->hashNext = hashTable[hash];
-	if(hashTable[hash])
-		hashTable[hash]->hashPrev = var;
+	/*if(hashTable[hash])
+		hashTable[hash]->hashPrev = var;*/
 
-	var->hashPrev = NULL;
+	//var->hashPrev = NULL;
 	hashTable[hash] = var;
 
 	return var;
@@ -972,19 +972,19 @@ cvar_t *Cvar_Unset(cvar_t *cv)
 	if(cv->resetString)
 		Cvar_FreeString(cv->resetString);
 
-	if(cv->prev)
+	/*if(cv->prev)
 		cv->prev->next = cv->next;
-	else
+	else*/
 		cvar_vars = cv->next;
-	if(cv->next)
-		cv->next->prev = cv->prev;
+	/*if(cv->next)
+		cv->next->prev = cv->prev;*/
 
-	if(cv->hashPrev)
+	/*if(cv->hashPrev)
 		cv->hashPrev->hashNext = cv->hashNext;
 	else
 		hashTable[cv->hashIndex] = cv->hashNext;
 	if(cv->hashNext)
-		cv->hashNext->hashPrev = cv->hashPrev;
+		cv->hashNext->hashPrev = cv->hashPrev;*/
 
 	Com_Memset(cv, '\0', sizeof(*cv));
 
diff --git a/codemp/qcommon/files_common.cpp b/codemp/qcommon/files_common.cpp
index ad4fddd..df93ff7 100644
--- a/codemp/qcommon/files_common.cpp
+++ b/codemp/qcommon/files_common.cpp
@@ -499,8 +499,8 @@ void FS_InitFilesystem( void ) {
 	// if we can't find default.cfg, assume that the paths are
 	// busted and error out now, rather than getting an unreadable
 	// graphics screen when the font fails to load
-	if ( FS_ReadFile( "mpdefault.cfg", NULL ) <= 0 ) {
-		Com_Error( ERR_FATAL, "Couldn't load mpdefault.cfg" );
+	if ( FS_ReadFile( "sof2mp_default.cfg", NULL ) <= 0 ) {
+		Com_Error( ERR_FATAL, "Couldn't load sof2mp_default.cfg" );
 		// bk001208 - SafeMode see below, FIXME?
 	}
 
diff --git a/codemp/qcommon/files_pc.cpp b/codemp/qcommon/files_pc.cpp
index 21c7c47..e710d06 100644
--- a/codemp/qcommon/files_pc.cpp
+++ b/codemp/qcommon/files_pc.cpp
@@ -497,7 +497,7 @@ FS_FOpenFileWrite
 
 ===========
 */
-fileHandle_t FS_FOpenFileWrite( const char *filename ) {
+fileHandle_t FS_FOpenFileWrite( const char *filename, const bool astext ) {
 	char			*ospath;
 	fileHandle_t	f;
 
@@ -521,7 +521,7 @@ fileHandle_t FS_FOpenFileWrite( const char *filename ) {
 	// enabling the following line causes a recursive function call loop
 	// when running with +set logfile 1 +set developer 1
 	//Com_DPrintf( "writing to: %s\n", ospath );
-	fsh[f].handleFiles.file.o = fopen( ospath, "wb" );
+	fsh[f].handleFiles.file.o = fopen( ospath, (astext ? "w" : "wb") );
 
 	Q_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );
 
@@ -538,7 +538,7 @@ FS_FOpenFileAppend
 
 ===========
 */
-fileHandle_t FS_FOpenFileAppend( const char *filename ) {
+fileHandle_t FS_FOpenFileAppend( const char *filename, const bool astext = false ) {
 	char			*ospath;
 	fileHandle_t	f;
 
@@ -564,7 +564,7 @@ fileHandle_t FS_FOpenFileAppend( const char *filename ) {
 		return 0;
 	}
 
-	fsh[f].handleFiles.file.o = fopen( ospath, "ab" );
+	fsh[f].handleFiles.file.o = fopen( ospath, (astext ? "a" : "ab") );
 	fsh[f].handleSync = qfalse;
 	if (!fsh[f].handleFiles.file.o) {
 		f = 0;
@@ -3006,7 +3006,7 @@ void FS_Restart( int checksumFeed ) {
 	// if we can't find default.cfg, assume that the paths are
 	// busted and error out now, rather than getting an unreadable
 	// graphics screen when the font fails to load
-	if ( FS_ReadFile( "mpdefault.cfg", NULL ) <= 0 ) {
+	if ( FS_ReadFile( "sof2mp_default.cfg", NULL ) <= 0 ) {
 		// this might happen when connecting to a pure server not using BASEGAME/pak0.pk3
 		// (for instance a TA demo server)
 		if (lastValidBase[0]) {
@@ -3019,7 +3019,7 @@ void FS_Restart( int checksumFeed ) {
 			Com_Error( ERR_DROP, "Invalid game folder\n" );
 			return;
 		}
-		Com_Error( ERR_FATAL, "Couldn't load mpdefault.cfg" );
+		Com_Error( ERR_FATAL, "Couldn't load sof2mp_default.cfg" );
 	}
 
 	// bk010116 - new check before safeMode
@@ -3074,6 +3074,7 @@ Handle based file calls for virtual machines
 int		FS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode ) {
 	int		r;
 	qboolean	sync;
+	bool astext = false;
 
 	sync = qfalse;
 
@@ -3081,17 +3082,27 @@ int		FS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode ) {
 	case FS_READ:
 		r = FS_FOpenFileRead( qpath, f, qtrue );
 		break;
+	case FS_WRITE_TEXT:
+		astext = true;
 	case FS_WRITE:
-		*f = FS_FOpenFileWrite( qpath );
+		*f = FS_FOpenFileWrite( qpath, astext );
 		r = 0;
 		if (*f == 0) {
 			r = -1;
 		}
 		break;
+	case FS_APPEND_SYNC_TEXT:
+		sync = qtrue;
+	case FS_APPEND_TEXT:
+		*f = FS_FOpenFileAppend( qpath, true );
+		r = 0;
+		if (*f == 0) {
+			r = -1;
+		}
 	case FS_APPEND_SYNC:
 		sync = qtrue;
 	case FS_APPEND:
-		*f = FS_FOpenFileAppend( qpath );
+		*f = FS_FOpenFileAppend( qpath, astext );
 		r = 0;
 		if (*f == 0) {
 			r = -1;
diff --git a/codemp/qcommon/game_version.h b/codemp/qcommon/game_version.h
index 36aaba9..dfe0ca1 100644
--- a/codemp/qcommon/game_version.h
+++ b/codemp/qcommon/game_version.h
@@ -7,16 +7,16 @@
 // Current version of the multi player game
 #define VERSION_MAJOR_RELEASE		1
 #define VERSION_MINOR_RELEASE		0
-#define VERSION_EXTERNAL_BUILD		1
+#define VERSION_EXTERNAL_BUILD		3
 #define VERSION_INTERNAL_BUILD		0
 
 #define VERSION_STRING				STR(VERSION_MAJOR_RELEASE) ", " STR(VERSION_MINOR_RELEASE) ", " STR(VERSION_EXTERNAL_BUILD) ", " STR(VERSION_INTERNAL_BUILD) // "1, 0, 1, 0"
-#define VERSION_STRING_DOTTED		STR(VERSION_MAJOR_RELEASE) "." STR(VERSION_MINOR_RELEASE) "." STR(VERSION_EXTERNAL_BUILD) "." STR(VERSION_INTERNAL_BUILD) // "1.0.0.0"
+#define VERSION_STRING_DOTTED		STR(VERSION_MAJOR_RELEASE) "." STR(VERSION_MINOR_RELEASE) STR(VERSION_EXTERNAL_BUILD) // "1.03"
 
 #if defined(_DEBUG)
-	#define	JK_VERSION		"(debug)OpenJK-MP: v"VERSION_STRING_DOTTED
+	#define	JK_VERSION		"(debug)SOF2MP GOLD V"VERSION_STRING_DOTTED
 #elif defined(FINAL_BUILD)
-	#define	JK_VERSION		"OpenJK-MP: v"VERSION_STRING_DOTTED
+	#define	JK_VERSION		"SOF2MP GOLD V"VERSION_STRING_DOTTED
 #else
-	#define	JK_VERSION		"(internal)OpenJK-MP: v"VERSION_STRING_DOTTED
+	#define	JK_VERSION		"(internal)SOF2MP GOLD V"VERSION_STRING_DOTTED
 #endif
diff --git a/codemp/qcommon/msg.cpp b/codemp/qcommon/msg.cpp
index 10a7a18..646ce83 100644
--- a/codemp/qcommon/msg.cpp
+++ b/codemp/qcommon/msg.cpp
@@ -11,11 +11,6 @@
 
 extern	cvar_t	*cl_shownet;
 
-
-
-//#define _NEWHUFFTABLE_		// Build "c:\\netchan.bin"
-//#define _USINGNEWHUFFTABLE_		// Build a new frequency table to cut and paste.
-
 static huffman_t		msgHuff;
 
 static qboolean			msgInit = qfalse;
@@ -36,23 +31,9 @@ Handles byte ordering and avoids alignment errors
 
 int oldsize = 0;
 
-bool g_nOverrideChecked = false;
-void MSG_CheckNETFPSFOverrides(qboolean psfOverrides);
-
 void MSG_initHuffman();
 
 void MSG_Init( msg_t *buf, byte *data, int length ) {
-	if (!g_nOverrideChecked)
-	{
-		//Check for netf overrides
-		MSG_CheckNETFPSFOverrides(qfalse);
-		
-		//Then for psf overrides
-		MSG_CheckNETFPSFOverrides(qtrue);
-
-		g_nOverrideChecked = true;
-	}
-
 	if (!msgInit)
 	{
 		MSG_initHuffman();
@@ -64,17 +45,6 @@ void MSG_Init( msg_t *buf, byte *data, int length ) {
 }
 
 void MSG_InitOOB( msg_t *buf, byte *data, int length ) {
-	if (!g_nOverrideChecked)
-	{
-		//Check for netf overrides
-		MSG_CheckNETFPSFOverrides(qfalse);
-		
-		//Then for psf overrides
-		MSG_CheckNETFPSFOverrides(qtrue);
-
-		g_nOverrideChecked = true;
-	}
-
 	if (!msgInit)
 	{
 		MSG_initHuffman();
@@ -191,9 +161,6 @@ void MSG_WriteBits( msg_t *msg, int value, int bits ) {
 		}
 		if (bits) {
 			for(i=0;i<bits;i+=8) {
-#ifdef _NEWHUFFTABLE_
-				fwrite(&value, 1, 1, fp);
-#endif // _NEWHUFFTABLE_
 				Huff_offsetTransmit (&msgHuff.compressor, (value&0xff), msg->data, &msg->bit);
 				value = (value>>8);
 			}
@@ -246,9 +213,6 @@ int MSG_ReadBits( msg_t *msg, int bits ) {
 		if (bits) {
 			for(i=0;i<bits;i+=8) {
 				Huff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);
-#ifdef _NEWHUFFTABLE_
-				fwrite(&get, 1, 1, fp);
-#endif // _NEWHUFFTABLE_
 				value |= (get<<(i+nbits));
 			}
 		}
@@ -464,12 +428,6 @@ char *MSG_ReadString( msg_t *msg ) {
 		if ( c == '%' ) {
 			c = '.';
 		}
-// eurofix: remove this so we can chat in european languages...	-ste
-//
-//		// don't allow higher ascii values
-//		if ( c > 127 ) {
-//			c = '.';
-//		}
 
 		string[l] = c;
 		l++;
@@ -667,9 +625,6 @@ usercmd_t communication
 #define	CM_UP		(1<<5)
 #define	CM_BUTTONS	(1<<6)
 #define CM_WEAPON	(1<<7)
-//rww - these are new
-#define CM_FORCE	(1<<8)
-#define CM_INVEN	(1<<9)
 
 /*
 =====================
@@ -692,11 +647,6 @@ void MSG_WriteDeltaUsercmd( msg_t *msg, usercmd_t *from, usercmd_t *to ) {
 	MSG_WriteDelta( msg, from->upmove, to->upmove, 8 );
 	MSG_WriteDelta( msg, from->buttons, to->buttons, 16 );
 	MSG_WriteDelta( msg, from->weapon, to->weapon, 8 );
-
-	MSG_WriteDelta( msg, from->forcesel, to->forcesel, 8 );
-	MSG_WriteDelta( msg, from->invensel, to->invensel, 8 );
-
-	MSG_WriteDelta( msg, from->generic_cmd, to->generic_cmd, 8 );
 }
 
 
@@ -719,11 +669,6 @@ void MSG_ReadDeltaUsercmd( msg_t *msg, usercmd_t *from, usercmd_t *to ) {
 	to->upmove = MSG_ReadDelta( msg, from->upmove, 8);
 	to->buttons = MSG_ReadDelta( msg, from->buttons, 16);
 	to->weapon = MSG_ReadDelta( msg, from->weapon, 8);
-
-	to->forcesel = MSG_ReadDelta( msg, from->forcesel, 8);
-	to->invensel = MSG_ReadDelta( msg, from->invensel, 8);
-
-	to->generic_cmd = MSG_ReadDelta( msg, from->generic_cmd, 8);
 }
 
 /*
@@ -746,10 +691,7 @@ void MSG_WriteDeltaUsercmdKey( msg_t *msg, int key, usercmd_t *from, usercmd_t *
 		from->rightmove == to->rightmove &&
 		from->upmove == to->upmove &&
 		from->buttons == to->buttons &&
-		from->weapon == to->weapon &&
-		from->forcesel == to->forcesel &&
-		from->invensel == to->invensel &&
-		from->generic_cmd == to->generic_cmd) {
+		from->weapon == to->weapon) {
 			MSG_WriteBits( msg, 0, 1 );				// no change
 			oldsize += 7;
 			return;
@@ -764,11 +706,6 @@ void MSG_WriteDeltaUsercmdKey( msg_t *msg, int key, usercmd_t *from, usercmd_t *
 	MSG_WriteDeltaKey( msg, key, from->upmove, to->upmove, 8 );
 	MSG_WriteDeltaKey( msg, key, from->buttons, to->buttons, 16 );
 	MSG_WriteDeltaKey( msg, key, from->weapon, to->weapon, 8 );
-
-	MSG_WriteDeltaKey( msg, key, from->forcesel, to->forcesel, 8 );
-	MSG_WriteDeltaKey( msg, key, from->invensel, to->invensel, 8 );
-
-	MSG_WriteDeltaKey( msg, key, from->generic_cmd, to->generic_cmd, 8 );
 }
 
 
@@ -793,11 +730,6 @@ void MSG_ReadDeltaUsercmdKey( msg_t *msg, int key, usercmd_t *from, usercmd_t *t
 		to->upmove = MSG_ReadDeltaKey( msg, key, from->upmove, 8);
 		to->buttons = MSG_ReadDeltaKey( msg, key, from->buttons, 16);
 		to->weapon = MSG_ReadDeltaKey( msg, key, from->weapon, 8);
-
-		to->forcesel = MSG_ReadDeltaKey( msg, key, from->forcesel, 8);
-		to->invensel = MSG_ReadDeltaKey( msg, key, from->invensel, 8);
-
-		to->generic_cmd = MSG_ReadDeltaKey( msg, key, from->generic_cmd, 8);
 	} else {
 		to->angles[0] = from->angles[0];
 		to->angles[1] = from->angles[1];
@@ -807,11 +739,6 @@ void MSG_ReadDeltaUsercmdKey( msg_t *msg, int key, usercmd_t *from, usercmd_t *t
 		to->upmove = from->upmove;
 		to->buttons = from->buttons;
 		to->weapon = from->weapon;
-
-		to->forcesel = from->forcesel;
-		to->invensel = from->invensel;
-
-		to->generic_cmd = from->generic_cmd;
 	}
 }
 
@@ -828,208 +755,67 @@ typedef struct {
 	char	*name;
 	int		offset;
 	int		bits;		// 0 = float
-#ifndef FINAL_BUILD
-	unsigned	mCount;
-#endif
 
 } netField_t;
 
 // using the stringizing operator to save typing...
 #define	NETF(x) #x,(int)&((entityState_t*)0)->x
 
-//rww - Remember to update ext_data/MP/netf_overrides.txt if you change any of this!
-//(for the sake of being consistent)
-
 netField_t	entityStateFields[] = 
 {
 { NETF(pos.trTime), 32 },
-{ NETF(pos.trBase[1]), 0 },
 { NETF(pos.trBase[0]), 0 },
-{ NETF(apos.trBase[1]), 0 },
-{ NETF(pos.trBase[2]), 0 },
-{ NETF(apos.trBase[0]), 0 },
+{ NETF(pos.trBase[1]), 0 },
 { NETF(pos.trDelta[0]), 0 },
 { NETF(pos.trDelta[1]), 0 },
+{ NETF(pos.trBase[2]), 0 },
+{ NETF(apos.trBase[1]), 0 },
+{ NETF(pos.trDelta[2]), 0 },
+{ NETF(apos.trBase[0]), 0 },
+{ NETF(event), 10 },
+{ NETF(angles2[1]), 0 },
 { NETF(eType), 8 },
+{ NETF(torsoAnim), 12 },
+{ NETF(torsoTimer), 13 },
+{ NETF(eventParm), 0 },
+{ NETF(legsAnim), 12 },
+{ NETF(groundEntityNum), GENTITYNUM_BITS },
+{ NETF(pos.trType), 8 },
+{ NETF(eFlags), 32 },
+{ NETF(otherEntityNum), GENTITYNUM_BITS },
+{ NETF(weapon), 8 },
+{ NETF(clientNum), 8 },
 { NETF(angles[1]), 0 },
-{ NETF(pos.trDelta[2]), 0 },
+{ NETF(pos.trDuration), 32 },
+{ NETF(apos.trType), 8 },
 { NETF(origin[0]), 0 },
 { NETF(origin[1]), 0 },
 { NETF(origin[2]), 0 },
-// does this need to be 8 bits?
-{ NETF(weapon), 8 },
-{ NETF(apos.trType), 8 },
-// changed from 12 to 16
-{ NETF(legsAnim), 16 },			// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-// suspicious
-{ NETF(torsoAnim), 16 },		// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-// large use beyond GENTITYNUM_BITS - should use generic1 insead
-{ NETF(genericenemyindex), 32 }, //Do not change to GENTITYNUM_BITS, used as a time offset for seeker
-{ NETF(eFlags), 32 },
-{ NETF(pos.trDuration), 32 },
-// might be able to reduce
-{ NETF(teamowner), 8 },
-{ NETF(groundEntityNum), GENTITYNUM_BITS },
-{ NETF(pos.trType), 8 },
-{ NETF(angles[2]), 0 },
-{ NETF(angles[0]), 0 },
 { NETF(solid), 24 },
-// flag states barely used - could be moved elsewhere
-{ NETF(fireflag), 2 },
-{ NETF(event), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-// used mostly for players and npcs - appears to be static / never changing
-{ NETF(customRGBA[3]), 8 }, //0-255
-// used mostly for players and npcs - appears to be static / never changing
-{ NETF(customRGBA[0]), 8 }, //0-255
-// only used in fx system (which rick did) and chunks
-{ NETF(speed), 0 },
-// why are npc's clientnum's that big?
-{ NETF(clientNum), GENTITYNUM_BITS }, //with npc's clientnum can be > MAX_CLIENTS so use entnum bits now instead.
-{ NETF(apos.trBase[2]), 0 },
-{ NETF(apos.trTime), 32 },
-// used mostly for players and npcs - appears to be static / never changing
-{ NETF(customRGBA[1]), 8 }, //0-255
-// used mostly for players and npcs - appears to be static / never changing
-{ NETF(customRGBA[2]), 8 }, //0-255
-// multiple meanings
-{ NETF(saberEntityNum), GENTITYNUM_BITS },
-// could probably just eliminate and assume a big number
-{ NETF(g2radius), 8 },
+{ NETF(gametypeitems), 8 },
+{ NETF(modelindex), 8 },
 { NETF(otherEntityNum2), GENTITYNUM_BITS },
-// used all over the place
-{ NETF(owner), GENTITYNUM_BITS },
-{ NETF(modelindex2), 8 },
-// why was this changed from 0 to 8 ?
-{ NETF(eventParm), 8 },
-// unknown about size?
-{ NETF(saberMove), 8 },
-{ NETF(apos.trDelta[1]), 0 },
-{ NETF(boneAngles1[1]), 0 },
-// why raised from 8 to -16?
-{ NETF(modelindex), -16 },
-// barely used, could probably be replaced
-{ NETF(emplacedOwner), 32 }, //As above, also used as a time value (for electricity render time)
-{ NETF(apos.trDelta[0]), 0 },
-{ NETF(apos.trDelta[2]), 0 },
-// shouldn't these be better off as flags?  otherwise, they may consume more bits this way
-{ NETF(torsoFlip), 1 },
-{ NETF(angles2[1]), 0 },
-// used mostly in saber and npc
-{ NETF(lookTarget), GENTITYNUM_BITS },
-{ NETF(origin2[2]), 0 },
-// randomly used, not sure why this was used instead of svc_noclient
-//	if (cent->currentState.modelGhoul2 == 127)
-//	{ //not ready to be drawn or initialized..
-//		return;
-//	}
-{ NETF(modelGhoul2), 8 },
 { NETF(loopSound), 8 },
+{ NETF(generic1), 8 },
+{ NETF(mSoundSet), 6 },
+{ NETF(origin2[2]), 0 },
 { NETF(origin2[0]), 0 },
-// multiple purpose bit flag
-{ NETF(shouldtarget), 1 },
-// widely used, does not appear that they have to be 16 bits
-{ NETF(trickedentindex), 16 }, //See note in PSF
-{ NETF(otherEntityNum), GENTITYNUM_BITS },
 { NETF(origin2[1]), 0 },
-{ NETF(time2), 32 },
-{ NETF(legsFlip), 1 },
-// fully used
-{ NETF(bolt2), GENTITYNUM_BITS },
-{ NETF(constantLight), 32 },
+{ NETF(modelindex2), 8 },
+{ NETF(angles[0]), 0 },
 { NETF(time), 32 },
-// why doesn't lookTarget just indicate this?
-{ NETF(hasLookTarget), 1 },
-{ NETF(boneAngles1[2]), 0 },
-// used for both force pass and an emplaced gun - gun is just a flag indicator
-{ NETF(activeForcePass), 6 },
-// used to indicate health
-{ NETF(health), 10 }, //if something's health exceeds 1024, then.. too bad!
-// appears to have multiple means, could be eliminated by indicating a sound set differently
-{ NETF(loopIsSoundset), 1 },
-{ NETF(saberHolstered), 2 },
-//NPC-SPECIFIC:
-// both are used for NPCs sabers, though limited
-{ NETF(npcSaber1), 9 },
-{ NETF(maxhealth), 10 },
-{ NETF(trickedentindex2), 16 },
-// appear to only be 18 powers?
-{ NETF(forcePowersActive), 32 },
-// used, doesn't appear to be flexible
-{ NETF(iModelScale), 10 }, //0-1024 (guess it's gotta be increased if we want larger allowable scale.. but 1024% is pretty big)
-// full bits used
-{ NETF(powerups), 16 },
-// can this be reduced?
-{ NETF(soundSetIndex), 8 }, //rww - if MAX_AMBIENT_SETS is changed from 256, REMEMBER TO CHANGE THIS
-// looks like this can be reduced to 4? (ship parts = 4, people parts = 2)
-{ NETF(brokenLimbs), 8 }, //up to 8 limbs at once (not that that many are used)
-{ NETF(csSounds_Std), 8 }, //soundindex must be 8 unless max sounds is changed
-// used extensively
-{ NETF(saberInFlight), 1 },
+{ NETF(apos.trTime), 32 },
+{ NETF(apos.trDuration), 32 },
+{ NETF(apos.trBase[2]), 0 },
+{ NETF(apos.trDelta[0]), 0 },
+{ NETF(apos.trDelta[1]), 0 },
+{ NETF(apos.trDelta[2]), 0 },
+{ NETF(time2), 32 },
+{ NETF(angles[2]), 0 },
 { NETF(angles2[0]), 0 },
-{ NETF(frame), 16 },
 { NETF(angles2[2]), 0 },
-// why not use torsoAnim and set a flag to do the same thing as forceFrame (saberLockFrame)
-{ NETF(forceFrame), 16 }, //if you have over 65536 frames, then this will explode. Of course if you have that many things then lots of things will probably explode.
-{ NETF(generic1), 8 },
-// do we really need 4 indexes?
-{ NETF(boneIndex1), 6 }, //up to 64 bones can be accessed by this indexing method
-// only 54 classes, could cut down 2 bits
-{ NETF(NPC_class), 8 },
-{ NETF(apos.trDuration), 32 },
-// there appears to be only 2 different version of parms passed - a flag would better be suited
-{ NETF(boneOrient), 9 }, //3 bits per orientation dir
-// this looks to be a single bit flag
-{ NETF(bolt1), 8 },
-{ NETF(trickedentindex3), 16 },
-// in use for vehicles
-{ NETF(m_iVehicleNum), GENTITYNUM_BITS }, // 10 bits fits all possible entity nums (2^10 = 1024). - AReis
-{ NETF(trickedentindex4), 16 },
-// but why is there an opposite state of surfaces field?
-{ NETF(surfacesOff), 32 },
-{ NETF(eFlags2), 10 },
-// should be bit field
-{ NETF(isJediMaster), 1 },
-// should be bit field
-{ NETF(isPortalEnt), 1 },
-// possible multiple definitions
-{ NETF(heldByClient), 6 },
-// this does not appear to be used in any production or non-cheat fashion - REMOVE
-{ NETF(ragAttach), GENTITYNUM_BITS },
-// used only in one spot for seige
-{ NETF(boltToPlayer), 6 },
-{ NETF(npcSaber2), 9 },
-{ NETF(csSounds_Combat), 8 },
-{ NETF(csSounds_Extra), 8 },
-{ NETF(csSounds_Jedi), 8 },
-// used only for surfaces on NPCs
-{ NETF(surfacesOn), 32 }, //allow up to 32 surfaces in the bitflag
-{ NETF(boneIndex2), 6 },
-{ NETF(boneIndex3), 6 },
-{ NETF(boneIndex4), 6 },
-{ NETF(boneAngles1[0]), 0 },
-{ NETF(boneAngles2[0]), 0 },
-{ NETF(boneAngles2[1]), 0 },
-{ NETF(boneAngles2[2]), 0 },
-{ NETF(boneAngles3[0]), 0 },
-{ NETF(boneAngles3[1]), 0 },
-{ NETF(boneAngles3[2]), 0 },
-{ NETF(boneAngles4[0]), 0 },
-{ NETF(boneAngles4[1]), 0 },
-{ NETF(boneAngles4[2]), 0 },
-
-//rww - for use by mod authors only
-{ NETF(userInt1), 1 },
-{ NETF(userInt2), 1 },
-{ NETF(userInt3), 1 },
-{ NETF(userFloat1), 1 },
-{ NETF(userFloat2), 1 },
-{ NETF(userFloat3), 1 },
-{ NETF(userVec1[0]), 1 },
-{ NETF(userVec1[1]), 1 },
-{ NETF(userVec1[2]), 1 },
-{ NETF(userVec2[0]), 1 },
-{ NETF(userVec2[1]), 1 },
-{ NETF(userVec2[2]), 1 }
+{ NETF(frame), 16 },
+{ NETF(leanOffset), 6 },
 };
 
 // if (int)f == f and (int)f + ( 1<<(FLOAT_INT_BITS-1) ) < ( 1 << FLOAT_INT_BITS )
@@ -1088,9 +874,6 @@ void MSG_WriteDeltaEntity( msg_t *msg, struct entityState_s *from, struct entity
 		toF = (int *)( (byte *)to + field->offset );
 		if ( *fromF != *toF ) {
 			lc = i+1;
-#ifndef FINAL_BUILD
-			field->mCount++;
-#endif
 		}
 	}
 
@@ -1185,7 +968,11 @@ void MSG_ReadDeltaEntity( msg_t *msg, entityState_t *from, entityState_t *to,
 		Com_Error( ERR_DROP, "Bad delta entity number: %i", number );
 	}
 
-	startBit = msg->bit;
+	if ( msg->bit == 0 ) {
+		startBit = msg->readcount * 8 - GENTITYNUM_BITS;
+	} else {
+		startBit = ( msg->readcount - 1 ) * 8 + msg->bit - GENTITYNUM_BITS;
+	}
 
 	// check for a remove
 	if ( MSG_ReadBits( msg, 1 ) == 1 ) {
@@ -1225,17 +1012,10 @@ void MSG_ReadDeltaEntity( msg_t *msg, entityState_t *from, entityState_t *to,
 
 	to->number = number;
 
-#ifdef _DONETPROFILE_
-	int startBytes,endBytes;
-#endif
-
 	for ( i = 0, field = entityStateFields ; i < lc ; i++, field++ ) {
 		fromF = (int *)( (byte *)from + field->offset );
 		toF = (int *)( (byte *)to + field->offset );
 
-#ifdef _DONETPROFILE_
-		startBytes=msg->readcount;
-#endif
 		if ( ! MSG_ReadBits( msg, 1 ) ) {
 			// no change
 			*toF = *fromF;
@@ -1274,10 +1054,6 @@ void MSG_ReadDeltaEntity( msg_t *msg, entityState_t *from, entityState_t *to,
 				}
 			}
 		}
-#ifdef _DONETPROFILE_
-		endBytes=msg->readcount;
-		ClReadProf().AddField(field->name,endBytes-startBytes);
-#endif
 	}
 	for ( i = lc, field = &entityStateFields[lc] ; i < numFields ; i++, field++ ) {
 		fromF = (int *)( (byte *)from + field->offset );
@@ -1287,7 +1063,11 @@ void MSG_ReadDeltaEntity( msg_t *msg, entityState_t *from, entityState_t *to,
 	}
 
 	if ( print ) {
-		endBit = msg->bit;
+		if ( msg->bit == 0 ) {
+			endBit = msg->readcount * 8 - GENTITYNUM_BITS;
+		} else {
+			endBit = ( msg->readcount - 1 ) * 8 + msg->bit - GENTITYNUM_BITS;
+		}
 		Com_Printf( " (%i bits)\n", endBit - startBit  );
 	}
 }
@@ -1303,817 +1083,88 @@ plyer_state_t communication
 // using the stringizing operator to save typing...
 #define	PSF(x) #x,(int)&((playerState_t*)0)->x
 
-//rww - Remember to update ext_data/MP/psf_overrides.txt if you change any of this!
-//(for the sake of being consistent)
-
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-#ifdef _OPTIMIZED_VEHICLE_NETWORKING
-//Instead of sending 2 full playerStates for the pilot and the vehicle, send a smaller,
-//specialized pilot playerState and vehicle playerState.  Also removes some vehicle
-//fields from the normal playerState -mcg
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-
 netField_t	playerStateFields[] = 
 {
-{ PSF(commandTime), 32 },				
-{ PSF(origin[1]), 0 },
+{ PSF(commandTime), 32 },
 { PSF(origin[0]), 0 },
-{ PSF(viewangles[1]), 0 },
-{ PSF(viewangles[0]), 0 },
-{ PSF(origin[2]), 0 },
-{ PSF(velocity[0]), 0 },
-{ PSF(velocity[1]), 0 },
-{ PSF(velocity[2]), 0 },
-{ PSF(bobCycle), 8 },
-{ PSF(weaponTime), -16 },
-{ PSF(delta_angles[1]), 16 },
-{ PSF(speed), 0 }, //sadly, the vehicles require negative speed values, so..
-{ PSF(legsAnim), 16 },			// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-{ PSF(delta_angles[0]), 16 },
-{ PSF(torsoAnim), 16 },			// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-{ PSF(groundEntityNum), GENTITYNUM_BITS },
-{ PSF(eFlags), 32 },
-{ PSF(fd.forcePower), 8 },
-{ PSF(eventSequence), 16 },
-{ PSF(torsoTimer), 16 },
-{ PSF(legsTimer), 16 },
-{ PSF(viewheight), -8 },
-{ PSF(fd.saberAnimLevel), 4 },
-{ PSF(rocketLockIndex), GENTITYNUM_BITS },
-{ PSF(fd.saberDrawAnimLevel), 4 },
-{ PSF(genericEnemyIndex), 32 }, //NOTE: This isn't just an index all the time, it's often used as a time value, and thus needs 32 bits
-{ PSF(events[0]), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-{ PSF(events[1]), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-{ PSF(customRGBA[0]), 8 }, //0-255
-{ PSF(movementDir), 4 },
-{ PSF(saberEntityNum), GENTITYNUM_BITS }, //Also used for channel tracker storage, but should never exceed entity number
-{ PSF(customRGBA[3]), 8 }, //0-255
-{ PSF(weaponstate), 4 },
-{ PSF(saberMove), 32 }, //This value sometimes exceeds the max LS_ value and gets set to a crazy amount, so it needs 32 bits
-{ PSF(standheight), 10 },
-{ PSF(crouchheight), 10 },
-{ PSF(basespeed), -16 },
-{ PSF(pm_flags), 16 },
-{ PSF(jetpackFuel), 8 },
-{ PSF(cloakFuel), 8 },
-{ PSF(pm_time), -16 },
-{ PSF(customRGBA[1]), 8 }, //0-255
-{ PSF(clientNum), GENTITYNUM_BITS },
-{ PSF(duelIndex), GENTITYNUM_BITS },
-{ PSF(customRGBA[2]), 8 }, //0-255
-{ PSF(gravity), 16 },
-{ PSF(weapon), 8 },
-{ PSF(delta_angles[2]), 16 },
-{ PSF(saberCanThrow), 1 },
-{ PSF(viewangles[2]), 0 },
-{ PSF(fd.forcePowersKnown), 32 },
-{ PSF(fd.forcePowerLevel[FP_LEVITATION]), 2 }, //unfortunately we need this for fall damage calculation (client needs to know the distance for the fall noise)
-{ PSF(fd.forcePowerDebounce[FP_LEVITATION]), 32 },
-{ PSF(fd.forcePowerSelected), 8 },
-{ PSF(torsoFlip), 1 },
-{ PSF(externalEvent), 10 },
-{ PSF(damageYaw), 8 },
-{ PSF(damageCount), 8 },
-{ PSF(inAirAnim), 1 }, //just transmit it for the sake of knowing right when on the client to play a land anim, it's only 1 bit
-{ PSF(eventParms[1]), 8 },
-{ PSF(fd.forceSide), 2 }, //so we know if we should apply greyed out shaders to dark/light force enlightenment
-{ PSF(saberAttackChainCount), 4 },
-{ PSF(pm_type), 8 },					
-{ PSF(externalEventParm), 8 },
-{ PSF(eventParms[0]), -16 },
-{ PSF(lookTarget), GENTITYNUM_BITS },
-//{ PSF(vehOrientation[0]), 0 },
-{ PSF(weaponChargeSubtractTime), 32 }, //? really need 32 bits??
-//{ PSF(vehOrientation[1]), 0 },
-//{ PSF(moveDir[1]), 0 },
-//{ PSF(moveDir[0]), 0 },
-{ PSF(weaponChargeTime), 32 }, //? really need 32 bits??
-//{ PSF(vehOrientation[2]), 0 },
-{ PSF(legsFlip), 1 },
-{ PSF(damageEvent), 8 },
-//{ PSF(moveDir[2]), 0 },
-{ PSF(rocketTargetTime), 32 },
-{ PSF(activeForcePass), 6 },
-{ PSF(electrifyTime), 32 },
-{ PSF(fd.forceJumpZStart), 0 },
-{ PSF(loopSound), 16 }, //rwwFIXMEFIXME: max sounds is 256, doesn't this only need to be 8?
-{ PSF(hasLookTarget), 1 },
-{ PSF(saberBlocked), 8 },
-{ PSF(damageType), 2 },
-{ PSF(rocketLockTime), 32 },
-{ PSF(forceHandExtend), 8 },
-{ PSF(saberHolstered), 2 },
-{ PSF(fd.forcePowersActive), 32 },
-{ PSF(damagePitch), 8 },
-{ PSF(m_iVehicleNum), GENTITYNUM_BITS }, // 10 bits fits all possible entity nums (2^10 = 1024). - AReis
-//{ PSF(vehTurnaroundTime), 32 },//only used by vehicle?
-{ PSF(generic1), 8 },
-{ PSF(jumppad_ent), 10 },
-{ PSF(hasDetPackPlanted), 1 },
-{ PSF(saberInFlight), 1 },
-{ PSF(forceDodgeAnim), 16 },
-{ PSF(zoomMode), 2 }, // NOTENOTE Are all of these necessary?
-{ PSF(hackingTime), 32 },
-{ PSF(zoomTime), 32 },	// NOTENOTE Are all of these necessary?
-{ PSF(brokenLimbs), 8 }, //up to 8 limbs at once (not that that many are used)
-{ PSF(zoomLocked), 1 },	// NOTENOTE Are all of these necessary?
-{ PSF(zoomFov), 0 },	// NOTENOTE Are all of these necessary?
-{ PSF(fd.forceRageRecoveryTime), 32 },
-{ PSF(fallingToDeath), 32 },
-{ PSF(fd.forceMindtrickTargetIndex), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(fd.forceMindtrickTargetIndex2), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-//{ PSF(vehWeaponsLinked), 1 },//only used by vehicle?
-{ PSF(lastHitLoc[2]), 0 },
-//{ PSF(hyperSpaceTime), 32 },//only used by vehicle?
-{ PSF(fd.forceMindtrickTargetIndex3), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(lastHitLoc[0]), 0 },
-{ PSF(eFlags2), 10 },
-{ PSF(fd.forceMindtrickTargetIndex4), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-//{ PSF(hyperSpaceAngles[1]), 0 },//only used by vehicle?
-{ PSF(lastHitLoc[1]), 0 }, //currently only used so client knows to orient disruptor disintegration.. seems a bit much for just that though.
-//{ PSF(vehBoarding), 1 }, //only used by vehicle? not like the normal boarding value, this is a simple "1 or 0" value
-{ PSF(fd.sentryDeployed), 1 },
-{ PSF(saberLockTime), 32 },
-{ PSF(saberLockFrame), 16 },
-//{ PSF(vehTurnaroundIndex), GENTITYNUM_BITS },//only used by vehicle?
-//{ PSF(vehSurfaces), 16 }, //only used by vehicle? allow up to 16 surfaces in the flag I guess
-{ PSF(fd.forcePowerLevel[FP_SEE]), 2 }, //needed for knowing when to display players through walls
-{ PSF(saberLockEnemy), GENTITYNUM_BITS },
-{ PSF(fd.forceGripCripple), 1 }, //should only be 0 or 1 ever
-{ PSF(emplacedIndex), GENTITYNUM_BITS },
-{ PSF(holocronBits), 32 },
-{ PSF(isJediMaster), 1 },
-{ PSF(forceRestricted), 1 },
-{ PSF(trueJedi), 1 },
-{ PSF(trueNonJedi), 1 },
-{ PSF(duelTime), 32 },
-{ PSF(duelInProgress), 1 },
-{ PSF(saberLockAdvance), 1 },
-{ PSF(heldByClient), 6 },
-{ PSF(ragAttach), GENTITYNUM_BITS },
-{ PSF(iModelScale), 10 }, //0-1024 (guess it's gotta be increased if we want larger allowable scale.. but 1024% is pretty big)
-{ PSF(hackingBaseTime), 16 }, //up to 65536ms, over 10 seconds would just be silly anyway
-//{ PSF(hyperSpaceAngles[0]), 0 },//only used by vehicle?
-//{ PSF(hyperSpaceAngles[2]), 0 },//only used by vehicle?
-
-//rww - for use by mod authors only
-{ PSF(userInt1), 1 },
-{ PSF(userInt2), 1 },
-{ PSF(userInt3), 1 },
-{ PSF(userFloat1), 1 },
-{ PSF(userFloat2), 1 },
-{ PSF(userFloat3), 1 },
-{ PSF(userVec1[0]), 1 },
-{ PSF(userVec1[1]), 1 },
-{ PSF(userVec1[2]), 1 },
-{ PSF(userVec2[0]), 1 },
-{ PSF(userVec2[1]), 1 },
-{ PSF(userVec2[2]), 1 }
-};
-
-netField_t	pilotPlayerStateFields[] = 
-{
-{ PSF(commandTime), 32 },				
 { PSF(origin[1]), 0 },
-{ PSF(origin[0]), 0 },
-{ PSF(viewangles[1]), 0 },
-{ PSF(viewangles[0]), 0 },
-{ PSF(origin[2]), 0 },
-{ PSF(weaponTime), -16 },
-{ PSF(delta_angles[1]), 16 },
-{ PSF(delta_angles[0]), 16 },
-{ PSF(eFlags), 32 },
-{ PSF(eventSequence), 16 },
-{ PSF(rocketLockIndex), GENTITYNUM_BITS },
-{ PSF(events[0]), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-{ PSF(events[1]), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-{ PSF(weaponstate), 4 },
-{ PSF(pm_flags), 16 },
-{ PSF(pm_time), -16 },
-{ PSF(clientNum), GENTITYNUM_BITS },
-{ PSF(weapon), 8 },
-{ PSF(delta_angles[2]), 16 },
-{ PSF(viewangles[2]), 0 },
-{ PSF(externalEvent), 10 },
-{ PSF(eventParms[1]), 8 },
-{ PSF(pm_type), 8 },					
-{ PSF(externalEventParm), 8 },
-{ PSF(eventParms[0]), -16 },
-{ PSF(weaponChargeSubtractTime), 32 }, //? really need 32 bits??
-{ PSF(weaponChargeTime), 32 }, //? really need 32 bits??
-{ PSF(rocketTargetTime), 32 },
-{ PSF(fd.forceJumpZStart), 0 },
-{ PSF(rocketLockTime), 32 },
-{ PSF(m_iVehicleNum), GENTITYNUM_BITS }, // 10 bits fits all possible entity nums (2^10 = 1024). - AReis
-{ PSF(generic1), 8 },//used by passengers
-{ PSF(eFlags2), 10 },
-
-//===THESE SHOULD NOT BE CHANGING OFTEN====================================================================
-{ PSF(legsAnim), 16 },			// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-{ PSF(torsoAnim), 16 },			// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-{ PSF(torsoTimer), 16 },
-{ PSF(legsTimer), 16 },
-{ PSF(jetpackFuel), 8 },
-{ PSF(cloakFuel), 8 },
-{ PSF(saberCanThrow), 1 },
-{ PSF(fd.forcePowerDebounce[FP_LEVITATION]), 32 },
-{ PSF(torsoFlip), 1 },
-{ PSF(legsFlip), 1 },
-{ PSF(fd.forcePowersActive), 32 },
-{ PSF(hasDetPackPlanted), 1 },
-{ PSF(fd.forceRageRecoveryTime), 32 },
-{ PSF(saberInFlight), 1 },
-{ PSF(fd.forceMindtrickTargetIndex), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(fd.forceMindtrickTargetIndex2), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(fd.forceMindtrickTargetIndex3), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(fd.forceMindtrickTargetIndex4), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(fd.sentryDeployed), 1 },
-{ PSF(fd.forcePowerLevel[FP_SEE]), 2 }, //needed for knowing when to display players through walls
-{ PSF(holocronBits), 32 },
-{ PSF(fd.forcePower), 8 },
-
-//===THE REST OF THESE SHOULD NOT BE RELEVANT, BUT, FOR SAFETY, INCLUDE THEM ANYWAY, JUST AT THE BOTTOM===============================================================
-{ PSF(velocity[0]), 0 },
-{ PSF(velocity[1]), 0 },
-{ PSF(velocity[2]), 0 },
 { PSF(bobCycle), 8 },
-{ PSF(speed), 0 }, //sadly, the vehicles require negative speed values, so..
-{ PSF(groundEntityNum), GENTITYNUM_BITS },
-{ PSF(viewheight), -8 },
-{ PSF(fd.saberAnimLevel), 4 },
-{ PSF(fd.saberDrawAnimLevel), 4 },
-{ PSF(genericEnemyIndex), 32 }, //NOTE: This isn't just an index all the time, it's often used as a time value, and thus needs 32 bits
-{ PSF(customRGBA[0]), 8 }, //0-255
-{ PSF(movementDir), 4 },
-{ PSF(saberEntityNum), GENTITYNUM_BITS }, //Also used for channel tracker storage, but should never exceed entity number
-{ PSF(customRGBA[3]), 8 }, //0-255
-{ PSF(saberMove), 32 }, //This value sometimes exceeds the max LS_ value and gets set to a crazy amount, so it needs 32 bits
-{ PSF(standheight), 10 },
-{ PSF(crouchheight), 10 },
-{ PSF(basespeed), -16 },
-{ PSF(customRGBA[1]), 8 }, //0-255
-{ PSF(duelIndex), GENTITYNUM_BITS },
-{ PSF(customRGBA[2]), 8 }, //0-255
-{ PSF(gravity), 16 },
-{ PSF(fd.forcePowersKnown), 32 },
-{ PSF(fd.forcePowerLevel[FP_LEVITATION]), 2 }, //unfortunately we need this for fall damage calculation (client needs to know the distance for the fall noise)
-{ PSF(fd.forcePowerSelected), 8 },
-{ PSF(damageYaw), 8 },
-{ PSF(damageCount), 8 },
-{ PSF(inAirAnim), 1 }, //just transmit it for the sake of knowing right when on the client to play a land anim, it's only 1 bit
-{ PSF(fd.forceSide), 2 }, //so we know if we should apply greyed out shaders to dark/light force enlightenment
-{ PSF(saberAttackChainCount), 4 },
-{ PSF(lookTarget), GENTITYNUM_BITS },
-{ PSF(moveDir[1]), 0 },
-{ PSF(moveDir[0]), 0 },
-{ PSF(damageEvent), 8 },
-{ PSF(moveDir[2]), 0 },
-{ PSF(activeForcePass), 6 },
-{ PSF(electrifyTime), 32 },
-{ PSF(damageType), 2 },
-{ PSF(loopSound), 16 }, //rwwFIXMEFIXME: max sounds is 256, doesn't this only need to be 8?
-{ PSF(hasLookTarget), 1 },
-{ PSF(saberBlocked), 8 },
-{ PSF(forceHandExtend), 8 },
-{ PSF(saberHolstered), 2 },
-{ PSF(damagePitch), 8 },
-{ PSF(jumppad_ent), 10 },
-{ PSF(forceDodgeAnim), 16 },
-{ PSF(zoomMode), 2 }, // NOTENOTE Are all of these necessary?
-{ PSF(hackingTime), 32 },
-{ PSF(zoomTime), 32 },	// NOTENOTE Are all of these necessary?
-{ PSF(brokenLimbs), 8 }, //up to 8 limbs at once (not that that many are used)
-{ PSF(zoomLocked), 1 },	// NOTENOTE Are all of these necessary?
-{ PSF(zoomFov), 0 },	// NOTENOTE Are all of these necessary?
-{ PSF(fallingToDeath), 32 },
-{ PSF(lastHitLoc[2]), 0 },
-{ PSF(lastHitLoc[0]), 0 },
-{ PSF(lastHitLoc[1]), 0 }, //currently only used so client knows to orient disruptor disintegration.. seems a bit much for just that though.
-{ PSF(saberLockTime), 32 },
-{ PSF(saberLockFrame), 16 },
-{ PSF(saberLockEnemy), GENTITYNUM_BITS },
-{ PSF(fd.forceGripCripple), 1 }, //should only be 0 or 1 ever
-{ PSF(emplacedIndex), GENTITYNUM_BITS },
-{ PSF(isJediMaster), 1 },
-{ PSF(forceRestricted), 1 },
-{ PSF(trueJedi), 1 },
-{ PSF(trueNonJedi), 1 },
-{ PSF(duelTime), 32 },
-{ PSF(duelInProgress), 1 },
-{ PSF(saberLockAdvance), 1 },
-{ PSF(heldByClient), 6 },
-{ PSF(ragAttach), GENTITYNUM_BITS },
-{ PSF(iModelScale), 10 }, //0-1024 (guess it's gotta be increased if we want larger allowable scale.. but 1024% is pretty big)
-{ PSF(hackingBaseTime), 16 }, //up to 65536ms, over 10 seconds would just be silly anyway
-//===NEVER SEND THESE, ONLY USED BY VEHICLES==============================================================
-
-//{ PSF(vehOrientation[0]), 0 },
-//{ PSF(vehOrientation[1]), 0 },
-//{ PSF(vehOrientation[2]), 0 },
-//{ PSF(vehTurnaroundTime), 32 },//only used by vehicle?
-//{ PSF(vehWeaponsLinked), 1 },//only used by vehicle?
-//{ PSF(hyperSpaceTime), 32 },//only used by vehicle?
-//{ PSF(vehTurnaroundIndex), GENTITYNUM_BITS },//only used by vehicle?
-//{ PSF(vehSurfaces), 16 }, //only used by vehicle? allow up to 16 surfaces in the flag I guess
-//{ PSF(vehBoarding), 1 }, //only used by vehicle? not like the normal boarding value, this is a simple "1 or 0" value
-//{ PSF(hyperSpaceAngles[1]), 0 },//only used by vehicle?
-//{ PSF(hyperSpaceAngles[0]), 0 },//only used by vehicle?
-//{ PSF(hyperSpaceAngles[2]), 0 },//only used by vehicle?
-
-//rww - for use by mod authors only
-{ PSF(userInt1), 1 },
-{ PSF(userInt2), 1 },
-{ PSF(userInt3), 1 },
-{ PSF(userFloat1), 1 },
-{ PSF(userFloat2), 1 },
-{ PSF(userFloat3), 1 },
-{ PSF(userVec1[0]), 1 },
-{ PSF(userVec1[1]), 1 },
-{ PSF(userVec1[2]), 1 },
-{ PSF(userVec2[0]), 1 },
-{ PSF(userVec2[1]), 1 },
-{ PSF(userVec2[2]), 1 }
-};
-
-netField_t	vehPlayerStateFields[] = 
-{
-{ PSF(commandTime), 32 },				
-{ PSF(origin[1]), 0 },
-{ PSF(origin[0]), 0 },
-{ PSF(viewangles[1]), 0 },
-{ PSF(viewangles[0]), 0 },
-{ PSF(origin[2]), 0 },
 { PSF(velocity[0]), 0 },
 { PSF(velocity[1]), 0 },
-{ PSF(velocity[2]), 0 },
-{ PSF(weaponTime), -16 },
-{ PSF(delta_angles[1]), 16 },
-{ PSF(speed), 0 }, //sadly, the vehicles require negative speed values, so..
-{ PSF(legsAnim), 16 },			// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-{ PSF(delta_angles[0]), 16 },
-{ PSF(groundEntityNum), GENTITYNUM_BITS },
-{ PSF(eFlags), 32 },
-{ PSF(eventSequence), 16 },
-{ PSF(legsTimer), 16 },
-{ PSF(rocketLockIndex), GENTITYNUM_BITS },
-//{ PSF(genericEnemyIndex), 32 }, //NOTE: This isn't just an index all the time, it's often used as a time value, and thus needs 32 bits
-{ PSF(events[0]), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-{ PSF(events[1]), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-//{ PSF(customRGBA[0]), 8 }, //0-255
-//{ PSF(movementDir), 4 },
-//{ PSF(customRGBA[3]), 8 }, //0-255
-{ PSF(weaponstate), 4 },
-//{ PSF(basespeed), -16 },
-{ PSF(pm_flags), 16 },
-{ PSF(pm_time), -16 },
-//{ PSF(customRGBA[1]), 8 }, //0-255
-{ PSF(clientNum), GENTITYNUM_BITS },
-//{ PSF(duelIndex), GENTITYNUM_BITS },
-//{ PSF(customRGBA[2]), 8 }, //0-255
-{ PSF(gravity), 16 },
-{ PSF(weapon), 8 },
-{ PSF(delta_angles[2]), 16 },
-{ PSF(viewangles[2]), 0 },
-{ PSF(externalEvent), 10 },
-{ PSF(eventParms[1]), 8 },
-{ PSF(pm_type), 8 },					
-{ PSF(externalEventParm), 8 },
-{ PSF(eventParms[0]), -16 },
-{ PSF(vehOrientation[0]), 0 },
-{ PSF(vehOrientation[1]), 0 },
-{ PSF(moveDir[1]), 0 },
-{ PSF(moveDir[0]), 0 },
-{ PSF(vehOrientation[2]), 0 },
-{ PSF(moveDir[2]), 0 },
-{ PSF(rocketTargetTime), 32 },
-//{ PSF(activeForcePass), 6 },//actually, you only need to know this for other vehicles, not your own
-{ PSF(electrifyTime), 32 },
-//{ PSF(fd.forceJumpZStart), 0 },//set on rider by vehicle, but not used by vehicle
-{ PSF(loopSound), 16 }, //rwwFIXMEFIXME: max sounds is 256, doesn't this only need to be 8?
-{ PSF(rocketLockTime), 32 },
-{ PSF(m_iVehicleNum), GENTITYNUM_BITS }, // 10 bits fits all possible entity nums (2^10 = 1024). - AReis
-{ PSF(vehTurnaroundTime), 32 },
-//{ PSF(generic1), 8 },//used by passengers of vehicles, but not vehicles themselves
-{ PSF(hackingTime), 32 },
-{ PSF(brokenLimbs), 8 }, //up to 8 limbs at once (not that that many are used)
-{ PSF(vehWeaponsLinked), 1 },
-{ PSF(hyperSpaceTime), 32 },
-{ PSF(eFlags2), 10 },
-{ PSF(hyperSpaceAngles[1]), 0 },
-{ PSF(vehBoarding), 1 }, //not like the normal boarding value, this is a simple "1 or 0" value
-{ PSF(vehTurnaroundIndex), GENTITYNUM_BITS },
-{ PSF(vehSurfaces), 16 }, //allow up to 16 surfaces in the flag I guess
-{ PSF(hyperSpaceAngles[0]), 0 },
-{ PSF(hyperSpaceAngles[2]), 0 },
-
-//rww - for use by mod authors only
-{ PSF(userInt1), 1 },
-{ PSF(userInt2), 1 },
-{ PSF(userInt3), 1 },
-{ PSF(userFloat1), 1 },
-{ PSF(userFloat2), 1 },
-{ PSF(userFloat3), 1 },
-{ PSF(userVec1[0]), 1 },
-{ PSF(userVec1[1]), 1 },
-{ PSF(userVec1[2]), 1 },
-{ PSF(userVec2[0]), 1 },
-{ PSF(userVec2[1]), 1 },
-{ PSF(userVec2[2]), 1 }
-};
-
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-#else//_OPTIMIZED_VEHICLE_NETWORKING
-//The unoptimized way, throw *all* the vehicle stuff into the playerState along with everything else... :(
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-
-netField_t	playerStateFields[] = 
-{
-{ PSF(commandTime), 32 },				
-{ PSF(origin[1]), 0 },
-{ PSF(origin[0]), 0 },
 { PSF(viewangles[1]), 0 },
 { PSF(viewangles[0]), 0 },
+{ PSF(weaponTime), -16 },
+{ PSF(weaponAnimTime), -16 },
+{ PSF(weaponFireBurstCount), 3 },
+{ PSF(weaponAnimId), -16 },
+{ PSF(weaponAnimIdChoice), -16 },
+{ PSF(weaponCallbackTime), 16 },
+{ PSF(weaponCallbackStep), -8 },
 { PSF(origin[2]), 0 },
-{ PSF(velocity[0]), 0 },
-{ PSF(velocity[1]), 0 },
 { PSF(velocity[2]), 0 },
-{ PSF(bobCycle), 8 },
-{ PSF(weaponTime), -16 },
-{ PSF(delta_angles[1]), 16 },
-{ PSF(speed), 0 }, //sadly, the vehicles require negative speed values, so..
-{ PSF(legsAnim), 16 },			// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-{ PSF(delta_angles[0]), 16 },
-{ PSF(torsoAnim), 16 },			// Maximum number of animation sequences is 2048.  Top bit is reserved for the togglebit
-{ PSF(groundEntityNum), GENTITYNUM_BITS },
-{ PSF(eFlags), 32 },
-{ PSF(fd.forcePower), 8 },
+{ PSF(pm_time), -16 },
 { PSF(eventSequence), 16 },
-{ PSF(torsoTimer), 16 },
-{ PSF(legsTimer), 16 },
-{ PSF(viewheight), -8 },
-{ PSF(fd.saberAnimLevel), 4 },
-{ PSF(rocketLockIndex), GENTITYNUM_BITS },
-{ PSF(fd.saberDrawAnimLevel), 4 },
-{ PSF(genericEnemyIndex), 32 }, //NOTE: This isn't just an index all the time, it's often used as a time value, and thus needs 32 bits
-{ PSF(events[0]), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-{ PSF(events[1]), 10 },			// There is a maximum of 256 events (8 bits transmission, 2 high bits for uniqueness)
-{ PSF(customRGBA[0]), 8 }, //0-255
+{ PSF(torsoAnim), 12 },
 { PSF(movementDir), 4 },
-{ PSF(saberEntityNum), GENTITYNUM_BITS }, //Also used for channel tracker storage, but should never exceed entity number
-{ PSF(customRGBA[3]), 8 }, //0-255
+{ PSF(events[0]), 10 },
+{ PSF(events[1]), 10 },
+{ PSF(events[2]), 10 },
+{ PSF(events[3]), 10 },
+{ PSF(legsAnim), 12 },
+{ PSF(pm_flags), 32 },
+{ PSF(pm_debounce), 16 },
+{ PSF(groundEntityNum), GENTITYNUM_BITS },
 { PSF(weaponstate), 4 },
-{ PSF(saberMove), 32 }, //This value sometimes exceeds the max LS_ value and gets set to a crazy amount, so it needs 32 bits
-{ PSF(standheight), 10 },
-{ PSF(crouchheight), 10 },
-{ PSF(basespeed), -16 },
-{ PSF(pm_flags), 16 },
-{ PSF(jetpackFuel), 8 },
-{ PSF(cloakFuel), 8 },
-{ PSF(pm_time), -16 },
-{ PSF(customRGBA[1]), 8 }, //0-255
-{ PSF(clientNum), GENTITYNUM_BITS },
-{ PSF(duelIndex), GENTITYNUM_BITS },
-{ PSF(customRGBA[2]), 8 }, //0-255
-{ PSF(gravity), 16 },
-{ PSF(weapon), 8 },
-{ PSF(delta_angles[2]), 16 },
-{ PSF(saberCanThrow), 1 },
-{ PSF(viewangles[2]), 0 },
-{ PSF(fd.forcePowersKnown), 32 },
-{ PSF(fd.forcePowerLevel[FP_LEVITATION]), 2 }, //unfortunately we need this for fall damage calculation (client needs to know the distance for the fall noise)
-{ PSF(fd.forcePowerDebounce[FP_LEVITATION]), 32 },
-{ PSF(fd.forcePowerSelected), 8 },
-{ PSF(torsoFlip), 1 },
+{ PSF(eFlags), 32 },
 { PSF(externalEvent), 10 },
-{ PSF(damageYaw), 8 },
-{ PSF(damageCount), 8 },
-{ PSF(inAirAnim), 1 }, //just transmit it for the sake of knowing right when on the client to play a land anim, it's only 1 bit
-{ PSF(eventParms[1]), 8 },
-{ PSF(fd.forceSide), 2 }, //so we know if we should apply greyed out shaders to dark/light force enlightenment
-{ PSF(saberAttackChainCount), 4 },
-{ PSF(pm_type), 8 },					
+{ PSF(gravity), 16 },
+{ PSF(speed), 16 },
+{ PSF(delta_angles[1]), 16 },
 { PSF(externalEventParm), 8 },
-{ PSF(eventParms[0]), -16 },
-{ PSF(lookTarget), GENTITYNUM_BITS },
-{ PSF(vehOrientation[0]), 0 },
-{ PSF(weaponChargeSubtractTime), 32 }, //? really need 32 bits??
-{ PSF(vehOrientation[1]), 0 },
-{ PSF(moveDir[1]), 0 },
-{ PSF(moveDir[0]), 0 },
-{ PSF(weaponChargeTime), 32 }, //? really need 32 bits??
-{ PSF(vehOrientation[2]), 0 },
-{ PSF(legsFlip), 1 },
+{ PSF(viewheight), -8 },
 { PSF(damageEvent), 8 },
-{ PSF(moveDir[2]), 0 },
-{ PSF(rocketTargetTime), 32 },
-{ PSF(activeForcePass), 6 },
-{ PSF(electrifyTime), 32 },
-{ PSF(fd.forceJumpZStart), 0 },
-{ PSF(loopSound), 16 }, //rwwFIXMEFIXME: max sounds is 256, doesn't this only need to be 8?
-{ PSF(hasLookTarget), 1 },
-{ PSF(saberBlocked), 8 },
-{ PSF(damageType), 2 },
-{ PSF(rocketLockTime), 32 },
-{ PSF(forceHandExtend), 8 },
-{ PSF(saberHolstered), 2 },
-{ PSF(fd.forcePowersActive), 32 },
+{ PSF(damageYaw), 8 },
 { PSF(damagePitch), 8 },
-{ PSF(m_iVehicleNum), GENTITYNUM_BITS }, // 10 bits fits all possible entity nums (2^10 = 1024). - AReis
-{ PSF(vehTurnaroundTime), 32 },
+{ PSF(damageCount), 8 },
+{ PSF(inaccuracy), 32 },
+{ PSF(inaccuracyTime), 16 },
+{ PSF(kickPitch), 18 },
 { PSF(generic1), 8 },
-{ PSF(jumppad_ent), 10 },
-{ PSF(hasDetPackPlanted), 1 },
-{ PSF(saberInFlight), 1 },
-{ PSF(forceDodgeAnim), 16 },
-{ PSF(zoomMode), 2 }, // NOTENOTE Are all of these necessary?
-{ PSF(hackingTime), 32 },
-{ PSF(zoomTime), 32 },	// NOTENOTE Are all of these necessary?
-{ PSF(brokenLimbs), 8 }, //up to 8 limbs at once (not that that many are used)
-{ PSF(zoomLocked), 1 },	// NOTENOTE Are all of these necessary?
-{ PSF(zoomFov), 0 },	// NOTENOTE Are all of these necessary?
-{ PSF(fd.forceRageRecoveryTime), 32 },
-{ PSF(fallingToDeath), 32 },
-{ PSF(fd.forceMindtrickTargetIndex), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(fd.forceMindtrickTargetIndex2), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(vehWeaponsLinked), 1 },
-{ PSF(lastHitLoc[2]), 0 },
-{ PSF(hyperSpaceTime), 32 },
-{ PSF(fd.forceMindtrickTargetIndex3), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(lastHitLoc[0]), 0 },
-{ PSF(eFlags2), 10 },
-{ PSF(fd.forceMindtrickTargetIndex4), 16 }, //NOTE: Not just an index, used as a (1 << val) bitflag for up to 16 clients
-{ PSF(hyperSpaceAngles[1]), 0 },
-{ PSF(lastHitLoc[1]), 0 }, //currently only used so client knows to orient disruptor disintegration.. seems a bit much for just that though.
-{ PSF(vehBoarding), 1 }, //not like the normal boarding value, this is a simple "1 or 0" value
-{ PSF(fd.sentryDeployed), 1 },
-{ PSF(saberLockTime), 32 },
-{ PSF(saberLockFrame), 16 },
-{ PSF(vehTurnaroundIndex), GENTITYNUM_BITS },
-{ PSF(vehSurfaces), 16 }, //allow up to 16 surfaces in the flag I guess
-{ PSF(fd.forcePowerLevel[FP_SEE]), 2 }, //needed for knowing when to display players through walls
-{ PSF(saberLockEnemy), GENTITYNUM_BITS },
-{ PSF(fd.forceGripCripple), 1 }, //should only be 0 or 1 ever
-{ PSF(emplacedIndex), GENTITYNUM_BITS },
-{ PSF(holocronBits), 32 },
-{ PSF(isJediMaster), 1 },
-{ PSF(forceRestricted), 1 },
-{ PSF(trueJedi), 1 },
-{ PSF(trueNonJedi), 1 },
-{ PSF(duelTime), 32 },
-{ PSF(duelInProgress), 1 },
-{ PSF(saberLockAdvance), 1 },
-{ PSF(heldByClient), 6 },
-{ PSF(ragAttach), GENTITYNUM_BITS },
-{ PSF(iModelScale), 10 }, //0-1024 (guess it's gotta be increased if we want larger allowable scale.. but 1024% is pretty big)
-{ PSF(hackingBaseTime), 16 }, //up to 65536ms, over 10 seconds would just be silly anyway
-{ PSF(hyperSpaceAngles[0]), 0 },
-{ PSF(hyperSpaceAngles[2]), 0 },
-
-//rww - for use by mod authors only
-{ PSF(userInt1), 1 },
-{ PSF(userInt2), 1 },
-{ PSF(userInt3), 1 },
-{ PSF(userFloat1), 1 },
-{ PSF(userFloat2), 1 },
-{ PSF(userFloat3), 1 },
-{ PSF(userVec1[0]), 1 },
-{ PSF(userVec1[1]), 1 },
-{ PSF(userVec1[2]), 1 },
-{ PSF(userVec2[0]), 1 },
-{ PSF(userVec2[1]), 1 },
-{ PSF(userVec2[2]), 1 }
-};
-
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-#endif//_OPTIMIZED_VEHICLE_NETWORKING
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-
-typedef struct bitStorage_s bitStorage_t;
-
-struct bitStorage_s
-{
-	bitStorage_t	*next;
-	int				bits;
+{ PSF(pm_type), 8 },
+{ PSF(delta_angles[0]), 16 },
+{ PSF(delta_angles[2]), 16 },
+{ PSF(torsoTimer), 13 },
+{ PSF(eventParms[0]), 32 },
+{ PSF(eventParms[1]), 32 },
+{ PSF(eventParms[2]), 32 },
+{ PSF(eventParms[3]), 32 },
+{ PSF(clientNum), 8 },
+{ PSF(weapon), 5 },
+{ PSF(viewangles[2]), 0 },
+{ PSF(loopSound), 16 },
+{ PSF(zoomTime), 32 },
+{ PSF(zoomFov), 6 },
+{ PSF(ladder), 6 },
+{ PSF(leanTime), 16 },
+{ PSF(grenadeTimer), 13 },
+{ PSF(respawnTimer), 32 },
 };
 
-static bitStorage_t		*g_netfBitStorage = NULL;
-static bitStorage_t		*g_psfBitStorage = NULL;
-
-//rww - Check the overrides files to see if the mod wants anything changed
-void MSG_CheckNETFPSFOverrides(qboolean psfOverrides)
-{
-	char overrideFile[4096];
-	char entryName[4096];
-	char bits[4096];
-	char *fileName;
-	int ibits;
-	int i = 0;
-	int j;
-	int len;
-	int numFields;
-	fileHandle_t f;
-	bitStorage_t **bitStorage;
-
-	if (psfOverrides)
-	{ //do PSF overrides instead of NETF
-		fileName = "psf_overrides.txt";
-		bitStorage = &g_psfBitStorage;
-		numFields = sizeof(playerStateFields)/sizeof(playerStateFields[0]);
-	}
-	else
-	{
-		fileName = "netf_overrides.txt";
-		bitStorage = &g_netfBitStorage;
-		numFields = sizeof(entityStateFields)/sizeof(entityStateFields[0]);
-	}
-
-	if (*bitStorage)
-	{ //if we have saved off the defaults before we want to stuff them all back in now
-		bitStorage_t *restore = *bitStorage;
-
-		while (i < numFields)
-		{
-			assert(restore);
-
-			if (psfOverrides)
-			{
-				playerStateFields[i].bits = restore->bits;
-			}
-			else
-			{
-				entityStateFields[i].bits = restore->bits;
-			}
-
-			i++;
-			restore = restore->next;
-		}
-	}
-
-	len = FS_FOpenFileRead(va("ext_data/MP/%s", fileName), &f, qfalse);
-
-	if (!f)
-	{ //silently exit since this file is not needed to proceed.
-		return;
-	}
-
-	if (len >= 4096)
-	{
-		Com_Printf("WARNING: %s is >= 4096 bytes and is being ignored\n", fileName);
-		FS_FCloseFile(f);
-		return;
-	}
-
-	//Get contents of the file
-	FS_Read(overrideFile, len, f);
-	FS_FCloseFile(f);
-
-	//because FS_Read does not do this for us.
-	overrideFile[len] = 0;
-
-	//If we haven't saved off the initial stuff yet then stuff it all into
-	//a list.
-	if (!*bitStorage)
-	{
-		i = 0;
-
-		while (i < numFields)
-		{
-			//Alloc memory for this new ptr
-			*bitStorage = (bitStorage_t *)Z_Malloc(sizeof(bitStorage_t), TAG_GENERAL, qtrue);
-
-			if (psfOverrides)
-			{
-				(*bitStorage)->bits = playerStateFields[i].bits;
-			}
-			else
-			{
-				(*bitStorage)->bits = entityStateFields[i].bits;
-			}
-
-			//Point to the ->next of the existing current ptr
-			bitStorage = &(*bitStorage)->next;
-			i++;
-		}
-	}
-
-	i = 0;
-	//Now parse through. Lines beginning with ; are disabled.
-	while (overrideFile[i])
-	{
-		if (overrideFile[i] == ';')
-		{ //parse to end of the line
-			while (overrideFile[i] != '\n')
-			{
-				i++;
-			}
-		}
-
-		if (overrideFile[i] != ';' &&
-			overrideFile[i] != '\n' &&
-			overrideFile[i] != '\r')
-		{ //on a valid char I guess, parse it
-			j = 0;
-
-			while (overrideFile[i] && overrideFile[i] != ',')
-			{
-				entryName[j] = overrideFile[i];
-				j++;
-				i++;
-			}
-			entryName[j] = 0;
-
-			if (!overrideFile[i])
-			{ //just give up, this shouldn't happen
-				Com_Printf("WARNING: Parsing error for %s\n", fileName);
-				return;
-			}
-
-			while (overrideFile[i] == ',' || overrideFile[i] == ' ')
-			{ //parse to the start of the value
-				i++;
-			}
-
-			j = 0;
-			while (overrideFile[i] != '\n' && overrideFile[i] != '\r')
-			{ //now read the value in
-				bits[j] = overrideFile[i];
-				j++;
-				i++;
-			}
-			bits[j] = 0;
-
-			if (bits[0])
-			{
-				if (!strcmp(bits, "GENTITYNUM_BITS"))
-				{ //special case
-					ibits = GENTITYNUM_BITS;
-				}
-				else
-				{
-	                ibits = atoi(bits);
-				}
-
-				j = 0;
-
-				//Now go through all the fields and see if we can find a match
-				while (j < numFields)
-				{
-					if (psfOverrides)
-					{ //check psf fields
-						if (!strcmp(playerStateFields[j].name, entryName))
-						{ //found it, set the bits
-							playerStateFields[j].bits = ibits;
-							break;
-						}
-					}
-					else
-					{ //otherwise check netf fields
-						if (!strcmp(entityStateFields[j].name, entryName))
-						{ //found it, set the bits
-							entityStateFields[j].bits = ibits;
-							break;
-						}
-					}
-					j++;
-				}
-
-				if (j == numFields)
-				{ //failed to find the value
-					Com_Printf("WARNING: Value '%s' from %s is not valid\n", entryName, fileName);
-				}
-			}
-			else
-			{ //also should not happen
-				Com_Printf("WARNING: Parsing error for %s\n", fileName);
-				return;
-			}
-		}
-
-		i++;
-	}
-}
-
-//MAKE SURE THIS MATCHES THE ENUM IN BG_PUBLIC.H!!!
-//This is in caps, because it is important.
-#define STAT_WEAPONS 4
-
 /*
 =============
 MSG_WriteDeltaPlayerstate
 
 =============
 */
-#ifdef _ONEBIT_COMBO
-void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct playerState_s *to, int *bitComboDelta, int *bitNumDelta, qboolean isVehiclePS ) {
-#else
 void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct playerState_s *to, qboolean isVehiclePS ) {
-#endif
 	int				i;
 	playerState_t	dummy;
 	int				statsbits;
 	int				persistantbits;
 	int				ammobits;
-	int				powerupbits;
+	int				clipbits;
+	int				altclipbits;
+	int				firemodebits;
 	int				numFields;
 	int				c;
 	netField_t		*field;
@@ -2121,10 +1172,6 @@ void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct p
 	int				*fromF, *toF;
 	float			fullFloat;
 	int				trunc, lc;
-#ifdef _ONEBIT_COMBO
-	int				bitComboMask = 0;
-	int				numBitsInMask = 0;
-#endif
 
 	if (!from) {
 		from = &dummy;
@@ -2133,32 +1180,7 @@ void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct p
 
 	c = msg->cursize;
 
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-#ifdef _OPTIMIZED_VEHICLE_NETWORKING
-	if ( isVehiclePS )
-	{//a vehicle playerstate
-		numFields = sizeof( vehPlayerStateFields ) / sizeof( vehPlayerStateFields[0] );
-		PSFields = vehPlayerStateFields;
-	}
-	else
-	{//regular client playerstate
-		if ( to->m_iVehicleNum
-			&& (to->eFlags&EF_NODRAW) )
-		{//pilot riding *inside* a vehicle!
-			MSG_WriteBits( msg, 1, 1 );	// Pilot player state
-			numFields = sizeof( pilotPlayerStateFields ) / sizeof( pilotPlayerStateFields[0] ) - 82;
-			PSFields = pilotPlayerStateFields;
-		}
-		else
-		{//normal client
-			MSG_WriteBits( msg, 0, 1 );	// Normal player state
-			numFields = sizeof( playerStateFields ) / sizeof( playerStateFields[0] );
-		}
-	}
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-#else// _OPTIMIZED_VEHICLE_NETWORKING
 	numFields = sizeof( playerStateFields ) / sizeof( playerStateFields[0] );
-#endif// _OPTIMIZED_VEHICLE_NETWORKING
 
 	lc = 0;
 	for ( i = 0, field = PSFields ; i < numFields ; i++, field++ ) {
@@ -2166,34 +1188,17 @@ void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct p
 		toF = (int *)( (byte *)to + field->offset );
 		if ( *fromF != *toF ) {
 			lc = i+1;
-#ifndef FINAL_BUILD
-			field->mCount++;
-#endif
 		}
 	}
 
 	MSG_WriteByte( msg, lc );	// # of changes
 
-#ifndef FINAL_BUILD
-	gLastBitIndex = lc;
-#endif
-
 	oldsize += numFields - lc;
 
 	for ( i = 0, field = PSFields ; i < lc ; i++, field++ ) {
 		fromF = (int *)( (byte *)from + field->offset );
 		toF = (int *)( (byte *)to + field->offset );
 
-#ifdef _ONEBIT_COMBO
-		if (numBitsInMask < 32 &&
-			field->bits == 1)
-		{
-			bitComboMask |= (*toF)<<numBitsInMask;
-			numBitsInMask++;
-			continue;
-		}
-#endif
-
 		if ( *fromF == *toF ) {
 			MSG_WriteBits( msg, 0, 1 );	// no change
 			continue;
@@ -2228,57 +1233,57 @@ void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct p
 	// send the arrays
 	//
 	statsbits = 0;
-	for (i=0 ; i<16 ; i++) {
+	for (i=0 ; i<MAX_STATS ; i++) {
 		if (to->stats[i] != from->stats[i]) {
 			statsbits |= 1<<i;
 		}
 	}
 	persistantbits = 0;
-	for (i=0 ; i<16 ; i++) {
+	for (i=0 ; i<MAX_PERSISTANT ; i++) {
 		if (to->persistant[i] != from->persistant[i]) {
 			persistantbits |= 1<<i;
 		}
 	}
 	ammobits = 0;
-	for (i=0 ; i<16 ; i++) {
+	for (i=0 ; i<MAX_AMMO ; i++) {
 		if (to->ammo[i] != from->ammo[i]) {
 			ammobits |= 1<<i;
 		}
 	}
-	powerupbits = 0;
-	for (i=0 ; i<16 ; i++) {
-		if (to->powerups[i] != from->powerups[i]) {
-			powerupbits |= 1<<i;
+	clipbits = 0;
+	for (i=0 ; i<MAX_WEAPONS ; i++) {
+		if (to->clip[ATTACK_NORMAL][i] != from->clip[ATTACK_NORMAL][i]) {
+			clipbits |= 1<<i;
+		}
+	}
+	altclipbits = 0;
+	for (i=0 ; i<MAX_WEAPONS ; i++) {
+		if (to->clip[ATTACK_ALTERNATE][i] != from->clip[ATTACK_ALTERNATE][i]) {
+			altclipbits |= 1<<i;
+		}
+	}
+	firemodebits = 0;
+	for (i=0 ; i<MAX_WEAPONS ; i++) {
+		if (to->firemode[i] != from->firemode[i]) {
+			firemodebits |= 1<<i;
 		}
 	}
 
-	if (!statsbits && !persistantbits && !ammobits && !powerupbits) {
+	if (!statsbits && !persistantbits && !ammobits && !clipbits && !altclipbits && !firemodebits) {
 		MSG_WriteBits( msg, 0, 1 );	// no change
 		oldsize += 4;
-#ifdef _ONEBIT_COMBO
-		goto sendBitMask;
-#else
 		return;
-#endif
 	}
 	MSG_WriteBits( msg, 1, 1 );	// changed
 
 	if ( statsbits ) {
 		MSG_WriteBits( msg, 1, 1 );	// changed
 		MSG_WriteShort( msg, statsbits );
-		for (i=0 ; i<16 ; i++)
+		for (i=0 ; i<MAX_STATS ; i++)
 		{
 			if (statsbits & (1<<i) )
 			{
-				if (i == STAT_WEAPONS)
-				{ //ugly.. but we're gonna need it anyway -rww
-					//(just send this one in MAX_WEAPONS bits, so that we can add up to MAX_WEAPONS weaps without hassle)
-					MSG_WriteBits(msg, to->stats[i], MAX_WEAPONS);
-				}
-				else
-				{
-					MSG_WriteShort (msg, to->stats[i]);
-				}
+				MSG_WriteLong (msg, to->stats[i]);
 			}
 		}
 	} else {
@@ -2289,7 +1294,7 @@ void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct p
 	if ( persistantbits ) {
 		MSG_WriteBits( msg, 1, 1 );	// changed
 		MSG_WriteShort( msg, persistantbits );
-		for (i=0 ; i<16 ; i++)
+		for (i=0 ; i<MAX_PERSISTANT ; i++)
 			if (persistantbits & (1<<i) )
 				MSG_WriteShort (msg, to->persistant[i]);
 	} else {
@@ -2300,46 +1305,43 @@ void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct p
 	if ( ammobits ) {
 		MSG_WriteBits( msg, 1, 1 );	// changed
 		MSG_WriteShort( msg, ammobits );
-		for (i=0 ; i<16 ; i++)
+		for (i=0 ; i<MAX_AMMO ; i++)
 			if (ammobits & (1<<i) )
 				MSG_WriteShort (msg, to->ammo[i]);
 	} else {
 		MSG_WriteBits( msg, 0, 1 );	// no change
 	}
 
+	if ( clipbits ) {
+		MSG_WriteBits( msg, 1, 1 );	// changed
+		MSG_WriteShort( msg, clipbits );
+		for (i=0 ; i<MAX_WEAPONS ; i++)
+			if (clipbits & (1<<i) )
+				MSG_WriteByte (msg, to->clip[ATTACK_NORMAL][i]);
+	} else {
+		MSG_WriteBits( msg, 0, 1 );	// no change
+	}
 
-	if ( powerupbits ) {
+	if ( altclipbits ) {
 		MSG_WriteBits( msg, 1, 1 );	// changed
-		MSG_WriteShort( msg, powerupbits );
-		for (i=0 ; i<16 ; i++)
-			if (powerupbits & (1<<i) )
-				MSG_WriteLong( msg, to->powerups[i] );
+		MSG_WriteShort( msg, altclipbits );
+		for (i=0 ; i<MAX_WEAPONS ; i++)
+			if (altclipbits & (1<<i) )
+				MSG_WriteByte (msg, to->clip[ATTACK_ALTERNATE][i]);
 	} else {
 		MSG_WriteBits( msg, 0, 1 );	// no change
 	}
 
-#ifdef _ONEBIT_COMBO
-sendBitMask:
-	if (numBitsInMask)
-	{ //don't need to send at all if we didn't pass any 1bit values
-		if (!bitComboDelta ||
-			bitComboMask != *bitComboDelta ||
-			numBitsInMask != *bitNumDelta)
-		{ //send the mask, it changed
-			MSG_WriteBits(msg, 1, 1);
-			MSG_WriteBits(msg, bitComboMask, numBitsInMask);
-			if (bitComboDelta)
-			{
-				*bitComboDelta = bitComboMask;
-				*bitNumDelta = numBitsInMask;
-			}
-		}
-		else
-		{ //send 1 bit 0 to indicate no change
-			MSG_WriteBits(msg, 0, 1);
-		}
+	if ( firemodebits ) {
+		MSG_WriteBits( msg, 1, 1 );	// changed
+		MSG_WriteShort( msg, firemodebits );
+		for (i=0 ; i<MAX_WEAPONS ; i++)
+			if (firemodebits & (1<<i) )
+				MSG_WriteBits (msg, to->firemode[i], WP_FIREMODE_MAX);
+	} else {
+		MSG_WriteBits( msg, 0, 1 );	// no change
 	}
-#endif
+
 }
 
 
@@ -2352,15 +1354,11 @@ void MSG_ReadDeltaPlayerstate (msg_t *msg, playerState_t *from, playerState_t *t
 	int			i, lc;
 	int			bits;
 	netField_t	*field;
-	netField_t  *PSFields = playerStateFields;
 	int			numFields;
 	int			startBit, endBit;
 	int			print;
 	int			*fromF, *toF;
 	int			trunc;
-#ifdef _ONEBIT_COMBO
-	int			numBitsInMask = 0;
-#endif
 	playerState_t	dummy;
 
 	if ( !from ) {
@@ -2384,54 +1382,14 @@ void MSG_ReadDeltaPlayerstate (msg_t *msg, playerState_t *from, playerState_t *t
 		print = 0;
 	}
 
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-#ifdef _OPTIMIZED_VEHICLE_NETWORKING
-	if ( isVehiclePS )
-	{//a vehicle playerstate
-		numFields = sizeof( vehPlayerStateFields ) / sizeof( vehPlayerStateFields[0] );
-		PSFields = vehPlayerStateFields;
-	}
-	else
-	{
-		int isPilot = MSG_ReadBits( msg, 1 );
-		if ( isPilot )
-		{//pilot riding *inside* a vehicle!
-			numFields = sizeof( pilotPlayerStateFields ) / sizeof( pilotPlayerStateFields[0] ) - 82;
-			PSFields = pilotPlayerStateFields;
-		}
-		else
-		{//normal client
-			numFields = sizeof( playerStateFields ) / sizeof( playerStateFields[0] );
-		}
-	}
-//=====_OPTIMIZED_VEHICLE_NETWORKING=======================================================================
-#else//_OPTIMIZED_VEHICLE_NETWORKING
 	numFields = sizeof( playerStateFields ) / sizeof( playerStateFields[0] );
-#endif//_OPTIMIZED_VEHICLE_NETWORKING
 
 	lc = MSG_ReadByte(msg);
 
-#ifdef _DONETPROFILE_
-	int startBytes,endBytes;
-#endif
-
-	for ( i = 0, field = PSFields ; i < lc ; i++, field++ ) {
+	for ( i = 0, field = playerStateFields ; i < lc ; i++, field++ ) {
 		fromF = (int *)( (byte *)from + field->offset );
 		toF = (int *)( (byte *)to + field->offset );
 
-#ifdef _ONEBIT_COMBO
-		if (numBitsInMask < 32 &&
-			field->bits == 1)
-		{
-			*toF = *fromF;
-			numBitsInMask++;
-			continue;
-		}
-#endif
-
-#ifdef _DONETPROFILE_
-		startBytes=msg->readcount;
-#endif
 		if ( ! MSG_ReadBits( msg, 1 ) ) {
 			// no change
 			*toF = *fromF;
@@ -2462,12 +1420,8 @@ void MSG_ReadDeltaPlayerstate (msg_t *msg, playerState_t *from, playerState_t *t
 				}
 			}
 		}
-#ifdef _DONETPROFILE_
-		endBytes=msg->readcount;
-		ClReadProf().AddField(field->name,endBytes-startBytes);
-#endif
 	}
-	for ( i=lc,field = &PSFields[lc];i<numFields; i++, field++) {
+	for ( i=lc,field = &playerStateFields[lc];i<numFields; i++, field++) {
 		fromF = (int *)( (byte *)from + field->offset );
 		toF = (int *)( (byte *)to + field->offset );
 		// no change
@@ -2475,87 +1429,73 @@ void MSG_ReadDeltaPlayerstate (msg_t *msg, playerState_t *from, playerState_t *t
 	}
 
 	// read the arrays
-#ifdef _DONETPROFILE_
-		startBytes=msg->readcount;
-#endif
 	if (MSG_ReadBits( msg, 1 ) ) {
 		// parse stats
 		if ( MSG_ReadBits( msg, 1 ) ) {
 			LOG("PS_STATS");
-			bits = MSG_ReadShort (msg);
-			for (i=0 ; i<16 ; i++) {
-				if (bits & (1<<i) )
-				{
-					if (i == STAT_WEAPONS)
-					{ //ugly.. but we're gonna need it anyway -rww
-						to->stats[i] = MSG_ReadBits(msg, MAX_WEAPONS);
-					}
-					else
-					{
-						to->stats[i] = MSG_ReadShort(msg);
-					}
+			bits = MSG_ReadBits (msg, MAX_STATS);
+			for (i=0 ; i<MAX_STATS ; i++) {
+				if (bits & (1<<i) )	{
+					to->stats[i] = MSG_ReadLong(msg);
 				}
 			}
 		}
-#ifdef _DONETPROFILE_
-		endBytes=msg->readcount;
-		ClReadProf().AddField("PS_STATS",endBytes-startBytes);
-#endif
 
 		// parse persistant stats
-#ifdef _DONETPROFILE_
-		startBytes=msg->readcount;
-#endif
 		if ( MSG_ReadBits( msg, 1 ) ) {
 			LOG("PS_PERSISTANT");
-			bits = MSG_ReadShort (msg);
-			for (i=0 ; i<16 ; i++) {
+			bits = MSG_ReadBits (msg, MAX_PERSISTANT);
+			for (i=0 ; i<MAX_PERSISTANT ; i++) {
 				if (bits & (1<<i) ) {
 					to->persistant[i] = MSG_ReadShort(msg);
 				}
 			}
 		}
-#ifdef _DONETPROFILE_
-		endBytes=msg->readcount;
-		ClReadProf().AddField("PS_PERSISTANT",endBytes-startBytes);
-#endif
 
 		// parse ammo
-#ifdef _DONETPROFILE_
-		startBytes=msg->readcount;
-#endif
 		if ( MSG_ReadBits( msg, 1 ) ) {
 			LOG("PS_AMMO");
-			bits = MSG_ReadShort (msg);
-			for (i=0 ; i<16 ; i++) {
+			bits = MSG_ReadBits (msg, MAX_AMMO);
+			for (i=0 ; i<MAX_AMMO ; i++) {
 				if (bits & (1<<i) ) {
 					to->ammo[i] = MSG_ReadShort(msg);
 				}
 			}
 		}
-#ifdef _DONETPROFILE_
-		endBytes=msg->readcount;
-		ClReadProf().AddField("PS_AMMO",endBytes-startBytes);
-#endif
 
-		// parse powerups
-#ifdef _DONETPROFILE_
-		startBytes=msg->readcount;
-#endif
+		// parse clips
+		if ( MSG_ReadBits( msg, 1 ) ) {
+			LOG("PS_CLIP");
+			bits = MSG_ReadBits (msg, MAX_WEAPONS);
+			for (i=0 ; i<MAX_WEAPONS ; i++) {
+				if (bits & (1<<i) ) {
+					to->clip[ATTACK_NORMAL][i] = MSG_ReadByte(msg);
+				}
+			}
+		}
+
+		// parse alt clip
+		if ( MSG_ReadBits( msg, 1 ) ) {
+			LOG("PS_ALTCLIP");
+			bits = MSG_ReadBits (msg, MAX_WEAPONS);
+			for (i=0 ; i<MAX_WEAPONS ; i++) {
+				if (bits & (1<<i) ) {
+					to->clip[ATTACK_ALTERNATE][i] = MSG_ReadByte(msg);
+				}
+			}
+		}
+
+		// pase firemodes
 		if ( MSG_ReadBits( msg, 1 ) ) {
-			LOG("PS_POWERUPS");
-			bits = MSG_ReadShort (msg);
-			for (i=0 ; i<16 ; i++) {
+			LOG("PS_FIREMODE");
+			bits = MSG_ReadBits (msg, MAX_WEAPONS);
+			for (i=0 ; i<MAX_WEAPONS ; i++) {
 				if (bits & (1<<i) ) {
-					to->powerups[i] = MSG_ReadLong(msg);
+					to->firemode[i] = MSG_ReadBits(msg, WP_FIREMODE_MAX);
 				}
 			}
 		}
 	}
-#ifdef _DONETPROFILE_
-		endBytes=msg->readcount;
-		ClReadProf().AddField("PS_POWERUPS",endBytes-startBytes);
-#endif
 
 	if ( print ) {
 		if ( msg->bit == 0 ) {
@@ -2565,291 +1505,8 @@ void MSG_ReadDeltaPlayerstate (msg_t *msg, playerState_t *from, playerState_t *t
 		}
 		Com_Printf( " (%i bits)\n", endBit - startBit  );
 	}
-
-#ifdef _ONEBIT_COMBO
-	if (numBitsInMask &&
-		MSG_ReadBits( msg, 1 ))
-	{ //mask changed...
-		int newBitMask = MSG_ReadBits(msg, numBitsInMask);
-		int nOneBit = 0;
-
-		//we have to go through all the fields again now to match the values
-		for ( i = 0, field = PSFields ; i < lc ; i++, field++ )
-		{
-			if (field->bits == 1)
-			{ //a 1 bit value, get the sent value from the mask
-				toF = (int *)( (byte *)to + field->offset );
-                *toF = (newBitMask>>nOneBit)&1;
-				nOneBit++;
-			}
-		}
-	}
-#endif
 }
 
-/*
-// New data gathered to tune Q3 to JK2MP. Takes longer to crunch and gain was minimal.
-int msg_hData[256] = 
-{
-	3163878,		// 0
-	473992,			// 1
-	564019,			// 2
-	136497,			// 3
-	129559,			// 4
-	283019,			// 5
-	75812,			// 6
-	179836,			// 7
-	85958,			// 8
-	168542,			// 9
-	78898,			// 10
-	82007,			// 11
-	48613,			// 12
-	138741,			// 13
-	35482,			// 14
-	47433,			// 15
-	65214,			// 16
-	51636,			// 17
-	63741,			// 18
-	52823,			// 19
-	42464,			// 20
-	44495,			// 21
-	45347,			// 22
-	40260,			// 23
-	59168,			// 24
-	44990,			// 25
-	52957,			// 26
-	42700,			// 27
-	42414,			// 28
-	36451,			// 29
-	45653,			// 30
-	44667,			// 31
-	125336,			// 32
-	38435,			// 33
-	53658,			// 34
-	42621,			// 35
-	40932,			// 36
-	33409,			// 37
-	35470,			// 38
-	40769,			// 39
-	33813,			// 40
-	32480,			// 41
-	33664,			// 42
-	32303,			// 43
-	32394,			// 44
-	34822,			// 45
-	37724,			// 46
-	48016,			// 47
-	94212,			// 48
-	53774,			// 49
-	54522,			// 50
-	44044,			// 51
-	42800,			// 52
-	47597,			// 53
-	29742,			// 54
-	30237,			// 55
-	34291,			// 56
-	106496,			// 57
-	20963,			// 58
-	19342,			// 59
-	20603,			// 60
-	19568,			// 61
-	23013,			// 62
-	23939,			// 63
-	44995,			// 64
-	37128,			// 65
-	44264,			// 66
-	46636,			// 67
-	56400,			// 68
-	32746,			// 69
-	23458,			// 70
-	29702,			// 71
-	25305,			// 72
-	20159,			// 73
-	19645,			// 74
-	20593,			// 75
-	21729,			// 76
-	19362,			// 77
-	24760,			// 78
-	22788,			// 79
-	25085,			// 80
-	21074,			// 81
-	97271,			// 82
-	22048,			// 83
-	24131,			// 84
-	19287,			// 85
-	20296,			// 86
-	20131,			// 87
-	86477,			// 88
-	25352,			// 89
-	20872,			// 90
-	21382,			// 91
-	38744,			// 92
-	137256,			// 93
-	26025,			// 94
-	22243,			// 95
-	23974,			// 96
-	43305,			// 97
-	28191,			// 98
-	34638,			// 99
-	37613,			// 100
-	46003,			// 101
-	31415,			// 102
-	25746,			// 103
-	28338,			// 104
-	34689,			// 105
-	24948,			// 106
-	27110,			// 107
-	39950,			// 108
-	32793,			// 109
-	42639,			// 110
-	47883,			// 111
-	37439,			// 112
-	23875,			// 113
-	36092,			// 114
-	46471,			// 115
-	37392,			// 116
-	33063,			// 117
-	29604,			// 118
-	42140,			// 119
-	61745,			// 120
-	45618,			// 121
-	51779,			// 122
-	49684,			// 123
-	57644,			// 124
-	65021,			// 125
-	67318,			// 126
-	88197,			// 127
-	258378,			// 128
-	76806,			// 129
-	72430,			// 130
-	64936,			// 131
-	62196,			// 132
-	56461,			// 133
-	166474,			// 134
-	70036,			// 135
-	40735,			// 136
-	29598,			// 137
-	26966,			// 138
-	26093,			// 139
-	25853,			// 140
-	26065,			// 141
-	26176,			// 142
-	26777,			// 143
-	26684,			// 144
-	23880,			// 145
-	22932,			// 146
-	24566,			// 147
-	24305,			// 148
-	26399,			// 149
-	23487,			// 150
-	24485,			// 151
-	25956,			// 152
-	26065,			// 153
-	26151,			// 154
-	23111,			// 155
-	23900,			// 156
-	22128,			// 157
-	24096,			// 158
-	20863,			// 159
-	24298,			// 160
-	22572,			// 161
-	22364,			// 162
-	20813,			// 163
-	21414,			// 164
-	21570,			// 165
-	20799,			// 166
-	20971,			// 167
-	22485,			// 168
-	20397,			// 169
-	88096,			// 170
-	17802,			// 171
-	20091,			// 172
-	84250,			// 173
-	21953,			// 174
-	21406,			// 175
-	23401,			// 176
-	19546,			// 177
-	19180,			// 178
-	18843,			// 179
-	20673,			// 180
-	19918,			// 181
-	20640,			// 182
-	20326,			// 183
-	21174,			// 184
-	21736,			// 185
-	22511,			// 186
-	20290,			// 187
-	23303,			// 188
-	19800,			// 189
-	25465,			// 190
-	22801,			// 191
-	28831,			// 192
-	26663,			// 193
-	36485,			// 194
-	45768,			// 195
-	49795,			// 196
-	36026,			// 197
-	24119,			// 198
-	18543,			// 199
-	19261,			// 200
-	17137,			// 201
-	19435,			// 202
-	23672,			// 203
-	22988,			// 204
-	18107,			// 205
-	18734,			// 206
-	19847,			// 207
-	101897,			// 208
-	18405,			// 209
-	21260,			// 210
-	17818,			// 211
-	18971,			// 212
-	19317,			// 213
-	19112,			// 214
-	19395,			// 215
-	20688,			// 216
-	18438,			// 217
-	18945,			// 218
-	29309,			// 219
-	19666,			// 220
-	18735,			// 221
-	87691,			// 222
-	18478,			// 223
-	22634,			// 224
-	20984,			// 225
-	20079,			// 226
-	18624,			// 227
-	20045,			// 228
-	18369,			// 229
-	19014,			// 230
-	83179,			// 231
-	20899,			// 232
-	17854,			// 233
-	19332,			// 234
-	17875,			// 235
-	28647,			// 236
-	17465,			// 237
-	20277,			// 238
-	18994,			// 239
-	22192,			// 240
-	17443,			// 241
-	20243,			// 242
-	28174,			// 243
-	134871,			// 244
-	17753,			// 245
-	18924,			// 246
-	18281,			// 247
-	18937,			// 248
-	17419,			// 249
-	20679,			// 250
-	17865,			// 251
-	17984,			// 252
-	58615,			// 253
-	35506,			// 254
-	123499,			// 255
-};
-*/
-
 // Q3 TA freq. table.
 int msg_hData[256] = {
 250315,			// 0
@@ -3110,15 +1767,9 @@ int msg_hData[256] = {
 13504,			// 255
 };
 
-#ifndef _USINGNEWHUFFTABLE_
-
 void MSG_initHuffman() {
 	int i,j;
 
-#ifdef _NEWHUFFTABLE_
-	fp=fopen("c:\\netchan.bin", "a");
-#endif // _NEWHUFFTABLE_
-	
 	msgInit = qtrue;
 	Huff_Init(&msgHuff);
 	for(i=0;i<256;i++) {
@@ -3128,55 +1779,6 @@ void MSG_initHuffman() {
 		}
 	}
 }
-
-#else
-
-void MSG_initHuffman() {
-
-	byte	*data;
-	int		size, i, ch;
-	int		array[256];
-
-	msgInit = qtrue;
-
-	Huff_Init(&msgHuff);
-	// load it in
-	size = FS_ReadFile( "netchan\\netchan.bin", (void **)&data );
-
-	for(i=0;i<256;i++) {
-		array[i] = 0;
-	}
-	for(i=0;i<size;i++) {
-		ch = data[i];
-		Huff_addRef(&msgHuff.compressor,	ch);			// Do update
-		Huff_addRef(&msgHuff.decompressor,	ch);			// Do update
-		array[ch]++;
-	}
-	Com_Printf("msg_hData {\n");
-	for(i=0;i<256;i++) {
-		if (array[i] == 0) {
-			Huff_addRef(&msgHuff.compressor,	i);			// Do update
-			Huff_addRef(&msgHuff.decompressor,	i);			// Do update
-		}
-		Com_Printf("%d,			// %d\n", array[i], i);
-	}
-	Com_Printf("};\n");
-	FS_FreeFile( data );
-	Cbuf_AddText( "condump dump.txt\n" );
-}
-
-#endif _USINGNEWHUFFTABLE_
-
-void MSG_shutdownHuffman()
-{
-#ifdef _NEWHUFFTABLE_
-	if(fp)
-	{
-		fclose(fp);
-	}
-#endif // _NEWHUFFTABLE_
-}
-
 /*
 =================
 MSG_ReportChangeVectors_f
@@ -3185,28 +1787,6 @@ Prints out a table from the current statistics for copying to code
 =================
 */
 void MSG_ReportChangeVectors_f( void ) {
-#ifndef FINAL_BUILD
-	int			numFields, i;
-	netField_t	*field;
-
-	numFields = sizeof(entityStateFields)/sizeof(entityStateFields[0]);
-
-	Com_Printf("Entity State Fields:\n");
-	for ( i = 0, field = entityStateFields ; i < numFields ; i++, field++ ) 
-	{
-		Com_Printf("%s\t\t%d\n", field->name, field->mCount);
-		field->mCount = 0;
-	}
-
-	Com_Printf("\nPlayer State Fields:\n");
-	numFields = sizeof( playerStateFields ) / sizeof( playerStateFields[0] );
-	for ( i = 0, field = playerStateFields ; i < numFields ; i++, field++ )
-	{
-		Com_Printf("%s\t\t%d\n", field->name, field->mCount);
-		field->mCount = 0;
-	}
-
-#endif	// FINAL_BUILD
 }
 
 //===========================================================================
diff --git a/codemp/qcommon/q_shared.h b/codemp/qcommon/q_shared.h
index 0b903b5..af86bfc 100644
--- a/codemp/qcommon/q_shared.h
+++ b/codemp/qcommon/q_shared.h
@@ -7,10 +7,10 @@
 // q_shared.h -- included first by ALL program modules.
 // A user mod should never modify this file
 
-#define PRODUCT_NAME			"openjk"
+#define PRODUCT_NAME			"sof2mp"
 
-#define CLIENT_WINDOW_TITLE "OpenJK (MP)"
-#define CLIENT_CONSOLE_TITLE "OpenJK Console (MP)"
+#define CLIENT_WINDOW_TITLE "SoF2 MP"
+#define CLIENT_CONSOLE_TITLE "Soldier of Fortune 2 Console"
 
 //NOTENOTE: Only change this to re-point ICARUS to a new script directory
 #define Q3_SCRIPT_DIR	"scripts"
@@ -625,47 +625,6 @@ typedef enum {
 	ERR_NEED_CD					// pop up the need-cd dialog
 } errorParm_t;
 
-
-// font rendering values used by ui and cgame
-
-/*#define PROP_GAP_WIDTH			3
-#define PROP_SPACE_WIDTH		8
-#define PROP_HEIGHT				27
-#define PROP_SMALL_SIZE_SCALE	0.75*/
-
-#define PROP_GAP_WIDTH			2
-//#define PROP_GAP_WIDTH			3
-#define PROP_SPACE_WIDTH		4
-#define PROP_HEIGHT				16
-
-#define PROP_TINY_SIZE_SCALE	1
-#define PROP_SMALL_SIZE_SCALE	1
-#define PROP_BIG_SIZE_SCALE		1
-#define PROP_GIANT_SIZE_SCALE	2
-
-#define PROP_TINY_HEIGHT		10
-#define PROP_GAP_TINY_WIDTH		1
-#define PROP_SPACE_TINY_WIDTH	3
-
-#define PROP_BIG_HEIGHT			24
-#define PROP_GAP_BIG_WIDTH		3
-#define PROP_SPACE_BIG_WIDTH	6
-
-#define BLINK_DIVISOR			200
-#define PULSE_DIVISOR			75
-
-#define UI_LEFT			0x00000000	// default
-#define UI_CENTER		0x00000001
-#define UI_RIGHT		0x00000002
-#define UI_FORMATMASK	0x00000007
-#define UI_SMALLFONT	0x00000010
-#define UI_BIGFONT		0x00000020	// default
-//#define UI_GIANTFONT	0x00000040
-#define UI_DROPSHADOW	0x00000800
-#define UI_BLINK		0x00001000
-#define UI_INVERSE		0x00002000
-#define UI_PULSE		0x00004000
-
 #if defined(_DEBUG) && !defined(BSPC)
 	#define HUNK_DEBUG
 #endif
@@ -717,307 +676,6 @@ typedef	int	fixed16_t;
 #define M_PI		3.14159265358979323846f	// matches value in gcc v2 math.h
 #endif
 
-
-typedef enum {
-	BLK_NO,
-	BLK_TIGHT,		// Block only attacks and shots around the saber itself, a bbox of around 12x12x12
-	BLK_WIDE		// Block all attacks in an area around the player in a rough arc of 180 degrees
-} saberBlockType_t;
-
-typedef enum {
-	BLOCKED_NONE,
-	BLOCKED_BOUNCE_MOVE,
-	BLOCKED_PARRY_BROKEN,
-	BLOCKED_ATK_BOUNCE,
-	BLOCKED_UPPER_RIGHT,
-	BLOCKED_UPPER_LEFT,
-	BLOCKED_LOWER_RIGHT,
-	BLOCKED_LOWER_LEFT,
-	BLOCKED_TOP,
-	BLOCKED_UPPER_RIGHT_PROJ,
-	BLOCKED_UPPER_LEFT_PROJ,
-	BLOCKED_LOWER_RIGHT_PROJ,
-	BLOCKED_LOWER_LEFT_PROJ,
-	BLOCKED_TOP_PROJ
-} saberBlockedType_t;
-
-
-
-typedef enum
-{
-	SABER_RED,
-	SABER_ORANGE,
-	SABER_YELLOW,
-	SABER_GREEN,
-	SABER_BLUE,
-	SABER_PURPLE,
-	NUM_SABER_COLORS
-} saber_colors_t;
-
-typedef enum
-{
-	FP_FIRST = 0,//marker
-	FP_HEAL = 0,//instant
-	FP_LEVITATION,//hold/duration
-	FP_SPEED,//duration
-	FP_PUSH,//hold/duration
-	FP_PULL,//hold/duration
-	FP_TELEPATHY,//instant
-	FP_GRIP,//hold/duration
-	FP_LIGHTNING,//hold/duration
-	FP_RAGE,//duration
-	FP_PROTECT,
-	FP_ABSORB,
-	FP_TEAM_HEAL,
-	FP_TEAM_FORCE,
-	FP_DRAIN,
-	FP_SEE,
-	FP_SABER_OFFENSE,
-	FP_SABER_DEFENSE,
-	FP_SABERTHROW,
-	NUM_FORCE_POWERS
-} forcePowers_t;
-
-typedef enum
-{
-	SABER_NONE = 0,
-	SABER_SINGLE,
-	SABER_STAFF,
-	SABER_DAGGER,
-	SABER_BROAD,
-	SABER_PRONG,
-	SABER_ARC,
-	SABER_SAI,
-	SABER_CLAW,
-	SABER_LANCE,
-	SABER_STAR,
-	SABER_TRIDENT,
-	SABER_SITH_SWORD,
-	NUM_SABERS
-} saberType_t;
-
-typedef struct 
-{
-	// Actual trail stuff
-	int		inAction;	// controls whether should we even consider starting one
-	int		duration;	// how long each trail seg stays in existence
-	int		lastTime;	// time a saber segement was last stored
-	vec3_t	base;
-	vec3_t	tip;
-
-	vec3_t	dualbase;
-	vec3_t	dualtip;
-
-	// Marks stuff
-	qboolean	haveOldPos[2];
-	vec3_t		oldPos[2];		
-	vec3_t		oldNormal[2];	// store this in case we don't have a connect-the-dots situation
-							//	..then we'll need the normal to project a mark blob onto the impact point
-} saberTrail_t;
-
-typedef struct
-{
-	qboolean	active;
-	saber_colors_t	color;
-	float		radius;
-	float		length;
-	float		lengthMax;
-	float		lengthOld;
-	float		desiredLength;
-	vec3_t		muzzlePoint;
-	vec3_t		muzzlePointOld;
-	vec3_t		muzzleDir;
-	vec3_t		muzzleDirOld;
-	saberTrail_t	trail;
-	int			hitWallDebounceTime;
-	int			storageTime;
-	int			extendDebounce;
-} bladeInfo_t;
-#define MAX_BLADES 8
-
-typedef enum
-{
-	SS_NONE = 0,
-	SS_FAST,
-	SS_MEDIUM,
-	SS_STRONG,
-	SS_DESANN,
-	SS_TAVION,
-	SS_DUAL,
-	SS_STAFF,
-	SS_NUM_SABER_STYLES
-} saber_styles_t;
-
-//SABER FLAGS
-//Old bools converted to a flag now
-#define SFL_NOT_LOCKABLE			(1<<0)//can't get into a saberlock
-#define SFL_NOT_THROWABLE			(1<<1)//can't be thrown - FIXME: maybe make this a max level of force saber throw that can be used with this saber?
-#define SFL_NOT_DISARMABLE			(1<<2)//can't be dropped
-#define SFL_NOT_ACTIVE_BLOCKING		(1<<3)//don't to try to block incoming shots with this saber
-#define SFL_TWO_HANDED				(1<<4)//uses both hands
-#define SFL_SINGLE_BLADE_THROWABLE	(1<<5)//can throw this saber if only the first blade is on
-#define SFL_RETURN_DAMAGE			(1<<6)//when returning from a saber throw, it keeps spinning and doing damage
-//NEW FLAGS
-#define SFL_ON_IN_WATER				(1<<7)//if set, weapon stays active even in water
-#define SFL_BOUNCE_ON_WALLS			(1<<8)//if set, the saber will bounce back when it hits solid architecture (good for real-sword type mods)
-#define SFL_BOLT_TO_WRIST			(1<<9)//if set, saber model is bolted to wrist, not in hand... useful for things like claws & shields, etc.
-//#define SFL_STICK_ON_IMPACT		(1<<?)//if set, the saber will stick in the wall when thrown and hits solid architecture (good for sabers that are meant to be thrown).
-//#define SFL_NO_ATTACK				(1<<?)//if set, you cannot attack with the saber (for sabers/weapons that are meant to be thrown only, not used as melee weapons).
-//Move Restrictions
-#define SFL_NO_PULL_ATTACK			(1<<10)//if set, cannot do pull+attack move (move not available in MP anyway)
-#define SFL_NO_BACK_ATTACK			(1<<11)//if set, cannot do back-stab moves
-#define SFL_NO_STABDOWN				(1<<12)//if set, cannot do stabdown move (when enemy is on ground)
-#define SFL_NO_WALL_RUNS			(1<<13)//if set, cannot side-run or forward-run on walls
-#define SFL_NO_WALL_FLIPS			(1<<14)//if set, cannot do backflip off wall or side-flips off walls
-#define SFL_NO_WALL_GRAB			(1<<15)//if set, cannot grab wall & jump off
-#define SFL_NO_ROLLS				(1<<16)//if set, cannot roll
-#define SFL_NO_FLIPS				(1<<17)//if set, cannot do flips
-#define SFL_NO_CARTWHEELS			(1<<18)//if set, cannot do cartwheels
-#define SFL_NO_KICKS				(1<<19)//if set, cannot do kicks (can't do kicks anyway if using a throwable saber/sword)
-#define SFL_NO_MIRROR_ATTACKS		(1<<20)//if set, cannot do the simultaneous attack left/right moves (only available in Dual Lightsaber Combat Style)
-#define SFL_NO_ROLL_STAB			(1<<21)//if set, cannot do roll-stab move at end of roll
-//SABER FLAGS2
-//Primary Blade Style
-#define SFL2_NO_WALL_MARKS			(1<<0)//if set, stops the saber from drawing marks on the world (good for real-sword type mods)
-#define SFL2_NO_DLIGHT				(1<<1)//if set, stops the saber from drawing a dynamic light (good for real-sword type mods)
-#define SFL2_NO_BLADE				(1<<2)//if set, stops the saber from drawing a blade (good for real-sword type mods)
-#define SFL2_NO_CLASH_FLARE			(1<<3)//if set, the saber will not do the big, white clash flare with other sabers
-#define SFL2_NO_DISMEMBERMENT		(1<<4)//if set, the saber never does dismemberment (good for pointed/blunt melee weapons)
-#define SFL2_NO_IDLE_EFFECT			(1<<5)//if set, the saber will not do damage or any effects when it is idle (not in an attack anim).  (good for real-sword type mods)
-#define SFL2_ALWAYS_BLOCK			(1<<6)//if set, the blades will always be blocking (good for things like shields that should always block)
-#define SFL2_NO_MANUAL_DEACTIVATE	(1<<7)//if set, the blades cannot manually be toggled on and off
-#define SFL2_TRANSITION_DAMAGE		(1<<8)//if set, the blade does damage in start, transition and return anims (like strong style does)
-//Secondary Blade Style
-#define SFL2_NO_WALL_MARKS2			(1<<9)//if set, stops the saber from drawing marks on the world (good for real-sword type mods)
-#define SFL2_NO_DLIGHT2				(1<<10)//if set, stops the saber from drawing a dynamic light (good for real-sword type mods)
-#define SFL2_NO_BLADE2				(1<<11)//if set, stops the saber from drawing a blade (good for real-sword type mods)
-#define SFL2_NO_CLASH_FLARE2		(1<<12)//if set, the saber will not do the big, white clash flare with other sabers
-#define SFL2_NO_DISMEMBERMENT2		(1<<13)//if set, the saber never does dismemberment (good for pointed/blunt melee weapons)
-#define SFL2_NO_IDLE_EFFECT2		(1<<14)//if set, the saber will not do damage or any effects when it is idle (not in an attack anim).  (good for real-sword type mods)
-#define SFL2_ALWAYS_BLOCK2			(1<<15)//if set, the blades will always be blocking (good for things like shields that should always block)
-#define SFL2_NO_MANUAL_DEACTIVATE2	(1<<16)//if set, the blades cannot manually be toggled on and off
-#define SFL2_TRANSITION_DAMAGE2		(1<<17)//if set, the blade does damage in start, transition and return anims (like strong style does)
-
-typedef struct
-{
-	char		name[64];						//entry in sabers.cfg, if any
-	char		fullName[64];				//the "Proper Name" of the saber, shown in UI
-	saberType_t	type;						//none, single or staff
-	char		model[MAX_QPATH];						//hilt model
-	qhandle_t	skin;						//registered skin id
-	int			soundOn;					//game soundindex for turning on sound
-	int			soundLoop;					//game soundindex for hum/loop sound
-	int			soundOff;					//game soundindex for turning off sound
-	int			numBlades;
-	bladeInfo_t	blade[MAX_BLADES];			//blade info - like length, trail, origin, dir, etc.
-	int			stylesLearned;				//styles you get when you get this saber, if any
-	int			stylesForbidden;			//styles you cannot use with this saber, if any
-	int			maxChain;					//how many moves can be chained in a row with this weapon (-1 is infinite, 0 is use default behavior)
-	int			forceRestrictions;			//force powers that cannot be used while this saber is on (bitfield) - FIXME: maybe make this a limit on the max level, per force power, that can be used with this type?
-	int			lockBonus;					//in saberlocks, this type of saber pushes harder or weaker
-	int			parryBonus;					//added to strength of parry with this saber
-	int			breakParryBonus;			//added to strength when hit a parry
-	int			breakParryBonus2;			//for bladeStyle2 (see bladeStyle2Start below)
-	int			disarmBonus;				//added to disarm chance when win saberlock or have a good parry (knockaway)
-	int			disarmBonus2;				//for bladeStyle2 (see bladeStyle2Start below)
-	saber_styles_t	singleBladeStyle;		//makes it so that you use a different style if you only have the first blade active
-//	char		*brokenSaber1;				//if saber is actually hit by another saber, it can be cut in half/broken and will be replaced with this saber in your right hand
-//	char		*brokenSaber2;				//if saber is actually hit by another saber, it can be cut in half/broken and will be replaced with this saber in your left hand
-//===NEW========================================================================================
-	//these values are global to the saber, like all of the ones above
-	int			saberFlags;					//from SFL_ list above
-	int			saberFlags2;				//from SFL2_ list above
-
-	//done in cgame (client-side code)
-	qhandle_t	spinSound;					//none - if set, plays this sound as it spins when thrown
-	qhandle_t	swingSound[3];				//none - if set, plays one of these 3 sounds when swung during an attack - NOTE: must provide all 3!!!
-
-	//done in game (server-side code)
-	float		moveSpeedScale;				//1.0 - you move faster/slower when using this saber
-	float		animSpeedScale;				//1.0 - plays normal attack animations faster/slower
-
-	//done in both cgame and game (BG code)
-	int	kataMove;				//LS_INVALID - if set, player will execute this move when they press both attack buttons at the same time 
-	int	lungeAtkMove;			//LS_INVALID - if set, player will execute this move when they crouch+fwd+attack 
-	int	jumpAtkUpMove;			//LS_INVALID - if set, player will execute this move when they jump+attack 
-	int	jumpAtkFwdMove;			//LS_INVALID - if set, player will execute this move when they jump+fwd+attack 
-	int	jumpAtkBackMove;		//LS_INVALID - if set, player will execute this move when they jump+back+attack
-	int	jumpAtkRightMove;		//LS_INVALID - if set, player will execute this move when they jump+rightattack
-	int	jumpAtkLeftMove;		//LS_INVALID - if set, player will execute this move when they jump+left+attack
-	int	readyAnim;				//-1 - anim to use when standing idle
-	int	drawAnim;				//-1 - anim to use when drawing weapon
-	int	putawayAnim;			//-1 - anim to use when putting weapon away
-	int	tauntAnim;				//-1 - anim to use when hit "taunt"
-	int	bowAnim;				//-1 - anim to use when hit "bow"
-	int	meditateAnim;			//-1 - anim to use when hit "meditate"
-	int	flourishAnim;			//-1 - anim to use when hit "flourish"
-	int	gloatAnim;				//-1 - anim to use when hit "gloat"
-
-	//***NOTE: you can only have a maximum of 2 "styles" of blades, so this next value, "bladeStyle2Start" is the number of the first blade to use these value on... all blades before this use the normal values above, all blades at and after this number use the secondary values below***
-	int			bladeStyle2Start;			//0 - if set, blades from this number and higher use the following values (otherwise, they use the normal values already set)
-
-	//***The following can be different for the extra blades - not setting them individually defaults them to the value for the whole saber (and first blade)***
-	
-	//===PRIMARY BLADES=====================
-	//done in cgame (client-side code)
-	int			trailStyle;					//0 - default (0) is normal, 1 is a motion blur and 2 is no trail at all (good for real-sword type mods)
-	int			g2MarksShader;				//none - if set, the game will use this shader for marks on enemies instead of the default "gfx/damage/saberglowmark"
-	int			g2WeaponMarkShader;			//none - if set, the game will ry to project this shader onto the weapon when it damages a person (good for a blood splatter on the weapon)
-	//int		bladeShader;				//none - if set, overrides the shader used for the saber blade?
-	//int		trailShader;				//none - if set, overrides the shader used for the saber trail?
-	qhandle_t	hitSound[3];				//none - if set, plays one of these 3 sounds when saber hits a person - NOTE: must provide all 3!!!
-	qhandle_t	blockSound[3];				//none - if set, plays one of these 3 sounds when saber/sword hits another saber/sword - NOTE: must provide all 3!!!
-	qhandle_t	bounceSound[3];				//none - if set, plays one of these 3 sounds when saber/sword hits a wall and bounces off (must set bounceOnWall to 1 to use these sounds) - NOTE: must provide all 3!!!
-	int			blockEffect;				//none - if set, plays this effect when the saber/sword hits another saber/sword (instead of "saber/saber_block.efx")
-	int			hitPersonEffect;			//none - if set, plays this effect when the saber/sword hits a person (instead of "saber/blood_sparks_mp.efx")
-	int			hitOtherEffect;				//none - if set, plays this effect when the saber/sword hits something else damagable (instead of "saber/saber_cut.efx")
-	int			bladeEffect;				//none - if set, plays this effect at the blade tag
-
-	//done in game (server-side code)
-	float		knockbackScale;				//0 - if non-zero, uses damage done to calculate an appropriate amount of knockback
-	float		damageScale;				//1 - scale up or down the damage done by the saber
-	float		splashRadius;				//0 - radius of splashDamage
-	int			splashDamage;				//0 - amount of splashDamage, 100% at a distance of 0, 0% at a distance = splashRadius
-	float		splashKnockback;			//0 - amount of splashKnockback, 100% at a distance of 0, 0% at a distance = splashRadius
-	
-	//===SECONDARY BLADES===================
-	//done in cgame (client-side code)
-	int			trailStyle2;				//0 - default (0) is normal, 1 is a motion blur and 2 is no trail at all (good for real-sword type mods)
-	int			g2MarksShader2;				//none - if set, the game will use this shader for marks on enemies instead of the default "gfx/damage/saberglowmark"
-	int			g2WeaponMarkShader2;		//none - if set, the game will ry to project this shader onto the weapon when it damages a person (good for a blood splatter on the weapon)
-	//int		bladeShader2;				//none - if set, overrides the shader used for the saber blade?
-	//int		trailShader2;				//none - if set, overrides the shader used for the saber trail?
-	qhandle_t	hit2Sound[3];				//none - if set, plays one of these 3 sounds when saber hits a person - NOTE: must provide all 3!!!
-	qhandle_t	block2Sound[3];				//none - if set, plays one of these 3 sounds when saber/sword hits another saber/sword - NOTE: must provide all 3!!!
-	qhandle_t	bounce2Sound[3];			//none - if set, plays one of these 3 sounds when saber/sword hits a wall and bounces off (must set bounceOnWall to 1 to use these sounds) - NOTE: must provide all 3!!!
-	int			blockEffect2;				//none - if set, plays this effect when the saber/sword hits another saber/sword (instead of "saber/saber_block.efx")
-	int			hitPersonEffect2;			//none - if set, plays this effect when the saber/sword hits a person (instead of "saber/blood_sparks_mp.efx")
-	int			hitOtherEffect2;			//none - if set, plays this effect when the saber/sword hits something else damagable (instead of "saber/saber_cut.efx")
-	int			bladeEffect2;				//none - if set, plays this effect at the blade tag
-
-	//done in game (server-side code)
-	float		knockbackScale2;			//0 - if non-zero, uses damage done to calculate an appropriate amount of knockback
-	float		damageScale2;				//1 - scale up or down the damage done by the saber
-	float		splashRadius2;				//0 - radius of splashDamage
-	int			splashDamage2;				//0 - amount of splashDamage, 100% at a distance of 0, 0% at a distance = splashRadius
-	float		splashKnockback2;			//0 - amount of splashKnockback, 100% at a distance of 0, 0% at a distance = splashRadius
-//=========================================================================================================================================
-
-} saberInfo_t;
-#define MAX_SABERS 2
-
-typedef enum forcePowerLevels_e
-{
-	FORCE_LEVEL_0,
-	FORCE_LEVEL_1,
-	FORCE_LEVEL_2,
-	FORCE_LEVEL_3,
-	NUM_FORCE_POWER_LEVELS
-} forcePowerLevels_t;
-
-#define	FORCE_LEVEL_4 (FORCE_LEVEL_3+1)
-#define	FORCE_LEVEL_5 (FORCE_LEVEL_4+1)
-
 //rww - a C-ified structure version of the class which fires off callbacks and gives arguments to update ragdoll status.
 enum sharedERagPhase
 {
@@ -1129,30 +787,6 @@ enum sharedEIKMoveState
 	IKS_DYNAMIC
 };
 
-//material stuff needs to be shared
-typedef enum //# material_e
-{
-	MAT_METAL = 0,	// scorched blue-grey metal
-	MAT_GLASS,		// not a real chunk type, just plays an effect with glass sprites
-	MAT_ELECTRICAL,	// sparks only
-	MAT_ELEC_METAL,	// sparks/electrical type metal
-	MAT_DRK_STONE,	// brown
-	MAT_LT_STONE,	// tan
-	MAT_GLASS_METAL,// glass sprites and METAl chunk
-	MAT_METAL2,		// electrical metal type
-	MAT_NONE,		// no chunks
-	MAT_GREY_STONE,	// grey
-	MAT_METAL3,		// METAL and METAL2 chunks
-	MAT_CRATE1,		// yellow multi-colored crate chunks
-	MAT_GRATE1,		// grate chunks
-	MAT_ROPE,		// for yavin trial...no chunks, just wispy bits
-	MAT_CRATE2,		// read multi-colored crate chunks
-	MAT_WHITE_METAL,// white angular chunks
-	MAT_SNOWY_ROCK,	// gray & brown chunks
-
-	NUM_MATERIALS
-} material_t;
-
 //rww - bot stuff that needs to be shared
 #define MAX_WPARRAY_SIZE 4096
 #define MAX_NEIGHBOR_SIZE 32
@@ -1181,6 +815,7 @@ typedef struct wpobject_s
 	int forceJumpTo;
 
 	int neighbornum;
+	//int neighbors[MAX_NEIGHBOR_SIZE];
 	wpneighbor_t neighbors[MAX_NEIGHBOR_SIZE];
 } wpobject_t;
 
@@ -1199,8 +834,8 @@ extern	vec3_t	bytedirs[NUMVERTEXNORMALS];
 #define SMALLCHAR_WIDTH		8
 #define SMALLCHAR_HEIGHT	16
 
-#define BIGCHAR_WIDTH		16
-#define BIGCHAR_HEIGHT		16
+#define BIGCHAR_WIDTH		12	// 16
+#define BIGCHAR_HEIGHT		13	// 16
 
 #define	GIANTCHAR_WIDTH		32
 #define	GIANTCHAR_HEIGHT	48
@@ -1281,12 +916,6 @@ CT_LTBLUE3,
 CT_BLUE3,
 CT_DKBLUE3,
 
-CT_HUD_GREEN,
-CT_HUD_RED,
-CT_ICON_BLUE,
-CT_NO_AMMO_RED,
-CT_HUD_ORANGE,
-
 CT_MAX
 } ct_table_t;
 
@@ -1307,8 +936,7 @@ extern	vec4_t		colorLtBlue;
 extern	vec4_t		colorDkBlue;
 
 #define Q_COLOR_ESCAPE	'^'
-// you MUST have the last bit on here about colour strings being less than 7 or taiwanese strings register as colour!!!!
-#define Q_IsColorString(p)	( p && *(p) == Q_COLOR_ESCAPE && *((p)+1) && *((p)+1) != Q_COLOR_ESCAPE && *((p)+1) <= '7' && *((p)+1) >= '0' )
+#define Q_IsColorString(p)	( p && *(p) == Q_COLOR_ESCAPE && *((p)+1) && *((p)+1) != Q_COLOR_ESCAPE )
 
 
 #define COLOR_BLACK		'0'
@@ -1616,7 +1244,11 @@ typedef enum {
 	FS_READ,
 	FS_WRITE,
 	FS_APPEND,
-	FS_APPEND_SYNC
+	FS_APPEND_SYNC,
+	FS_READ_TEXT,
+	FS_WRITE_TEXT,
+	FS_APPEND_TEXT,
+	FS_APPEND_SYNC_TEXT
 } fsMode_t;
 
 typedef enum {
@@ -1740,6 +1372,7 @@ default values.
 // These flags are only returned by the Cvar_Flags() function
 #define CVAR_MODIFIED		0x40000000		// Cvar was modified
 #define CVAR_NONEXISTENT	0x80000000		// Cvar doesn't exist.
+#define CVAR_LOCK_RANGE		0x00002000		// enforces the mins / maxs
 
 // nothing outside the Cvar_*() functions should modify these fields!
 typedef struct cvar_s {
@@ -1747,16 +1380,14 @@ typedef struct cvar_s {
 	char		*string;
 	char		*resetString;		// cvar_restart will reset to this value
 	char		*latchedString;		// for CVAR_LATCH vars
+	float		mMinValue, mMaxValue;
 	int			flags;
 	qboolean	modified;			// set each time the cvar is changed
 	int			modificationCount;	// incremented each time the cvar is changed
 	float		value;				// atof( string )
 	int			integer;			// atoi( string )
 	struct cvar_s *next;
-	struct cvar_s *prev;
 	struct cvar_s *hashNext;
-	struct cvar_s *hashPrev;
-	int			hashIndex;
 } cvar_t;
 
 #define	MAX_CVAR_VALUE_STRING	256
@@ -1836,15 +1467,15 @@ Ghoul2 Insert End
 */
 // a trace is returned when a box is swept through the world
 typedef struct {
-	byte		allsolid;	// if true, plane is not valid
-	byte		startsolid;	// if true, the initial point was in a solid area
-	short		entityNum;	// entity the contacted sirface is a part of
+	qboolean	allsolid;	// if true, plane is not valid
+	qboolean	startsolid;	// if true, the initial point was in a solid area
 
 	float		fraction;	// time completed, 1.0 = didn't hit anything
 	vec3_t		endpos;		// final position
 	cplane_t	plane;		// surface normal at impact, transformed to world space
 	int			surfaceFlags;	// surface hit
 	int			contents;	// contents on other side of surface hit
+	int			entityNum;	// entity the contacted sirface is a part of
 /*
 Ghoul2 Insert Start
 */
@@ -1881,6 +1512,7 @@ typedef struct {
 #define	KEYCATCH_UI					0x0002
 #define	KEYCATCH_MESSAGE		0x0004
 #define	KEYCATCH_CGAME			0x0008
+#define KEYCATCH_NUMBERSONLY	0x0010
 
 
 // sound channels
@@ -1891,16 +1523,16 @@ typedef enum {
 	CHAN_LOCAL,	//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" # menu sounds, etc
 	CHAN_WEAPON,//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" 
 	CHAN_VOICE, //## %s !!"W:\game\base\!!sound\voice\*.wav;*.mp3" # Voice sounds cause mouth animation
-	CHAN_VOICE_ATTEN, //## %s !!"W:\game\base\!!sound\voice\*.wav;*.mp3" # Causes mouth animation but still use normal sound falloff 
+	//CHAN_VOICE_ATTEN, //## %s !!"W:\game\base\!!sound\voice\*.wav;*.mp3" # Causes mouth animation but still use normal sound falloff 
 	CHAN_ITEM,  //## %s !!"W:\game\base\!!sound\*.wav;*.mp3"
 	CHAN_BODY,	//## %s !!"W:\game\base\!!sound\*.wav;*.mp3"
-	CHAN_AMBIENT,//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" # added for ambient sounds
 	CHAN_LOCAL_SOUND,	//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" #chat messages, etc
 	CHAN_ANNOUNCER,		//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" #announcer voices, etc
-	CHAN_LESS_ATTEN,	//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" #attenuates similar to chan_voice, but uses empty channel auto-pick behaviour
-	CHAN_MENU1,		//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" #menu stuff, etc
-	CHAN_VOICE_GLOBAL,  //## %s !!"W:\game\base\!!sound\voice\*.wav;*.mp3" # Causes mouth animation and is broadcast, like announcer
-	CHAN_MUSIC,	//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" #music played as a looping sound - added by BTO (VV)
+	CHAN_AMBIENT,//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" # added for ambient sounds
+	//CHAN_LESS_ATTEN,	//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" #attenuates similar to chan_voice, but uses empty channel auto-pick behaviour
+	//CHAN_MENU1,		//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" #menu stuff, etc
+	//CHAN_VOICE_GLOBAL,  //## %s !!"W:\game\base\!!sound\voice\*.wav;*.mp3" # Causes mouth animation and is broadcast, like announcer
+	//CHAN_MUSIC,	//## %s !!"W:\game\base\!!sound\*.wav;*.mp3" #music played as a looping sound - added by BTO (VV)
 } soundChannel_t;
 
 
@@ -1922,27 +1554,17 @@ typedef enum {
 //
 // per-level limits
 //
-#define	MAX_CLIENTS			32		// absolute limit
-#define MAX_RADAR_ENTITIES	MAX_GENTITIES
-#define MAX_TERRAINS		1//32 //rwwRMG: inserted
+#define	MAX_CLIENTS			64		// absolute limit
+//#define MAX_RADAR_ENTITIES	MAX_GENTITIES
+#define MAX_TERRAINS		32 //rwwRMG: inserted
 #define MAX_LOCATIONS		64
+#define MAX_LADDERS			64
+
+#define MAX_INSTANCE_TYPES		16
 
 #define	GENTITYNUM_BITS	10		// don't need to send any more
 #define	MAX_GENTITIES	(1<<GENTITYNUM_BITS)
 
-//I am reverting. I guess. For now.
-/*
-#define	GENTITYNUM_BITS		11
-							//rww - I am raising this 1 bit. SP actually has room for 1024 ents - none - world - 1 client.
-							//Which means 1021 useable entities. However we have 32 clients.. so if we keep our limit
-							//at 1024 we are not going to be able to load any SP levels at the edge of the ent limit.
-#define		MAX_GENTITIES	(1024+(MAX_CLIENTS-1))
-							//rww - we do have enough room to send over 2048 ents now. However, I cannot live with the guilt of
-							//actually increasing the entity limit to 2048 (as it would slow down countless things, and
-							//there are tons of ent list traversals all over the place). So I am merely going to give enough
-							//to compensate for our larger maxclients.
-*/
-
 // entitynums are communicated with GENTITY_BITS, so any reserved
 // values thatare going to be communcated over the net need to
 // also be in this range
@@ -1952,29 +1574,23 @@ typedef enum {
 
 
 // these are also in be_aas_def.h - argh (rjr)
-#define	MAX_MODELS			512		// these are sent over the net as -12 bits
-#define	MAX_SOUNDS			256		// so they cannot be blindly increased
-#define MAX_ICONS			64		// max registered icons you can have per map 
-#define MAX_FX				64		// max effects strings, I'm hoping that 64 will be plenty
-
-#define MAX_SUB_BSP			32 //rwwRMG - added
-
-/*
-Ghoul2 Insert Start
-*/
-#define	MAX_G2BONES		64		//rww - changed from MAX_CHARSKINS to MAX_G2BONES. value still equal.
-/*
-Ghoul2 Insert End
-*/
+#define	MAX_MODELS				256		// these are sent over the net as 8 bits
+#define	MAX_SOUNDS				256		// so they cannot be blindly increased
+#define MAX_AMBIENT_SOUNDSETS	64
+#define MAX_FX					64		// max effects strings, I'm hoping that 64 will be plenty
+#define MAX_SUB_BSP				32
+#define MAX_ICONS				32
+#define	MAX_CHARSKINS			64		// character skins
+#define	MAX_HUDICONS			16		// icons on hud
 
-#define MAX_AMBIENT_SETS		256 //rww - ambient soundsets must be sent over in config strings.
-
-#define	MAX_CONFIGSTRINGS	1700 //this is getting pretty high. Try not to raise it anymore than it already is.
+#define	MAX_CONFIGSTRINGS	1400 //this is getting pretty high. Try not to raise it anymore than it already is.
 
 // these are the only configstrings that the system reserves, all the
 // other ones are strictly for servergame to clientgame communication
 #define	CS_SERVERINFO		0		// an info string with all the serverinfo cvars
 #define	CS_SYSTEMINFO		1		// an info string for server system to client system configuration (timescale, etc)
+#define CS_PLAYERS			2		// info string for player user info
+#define CS_CUSTOM			(CS_PLAYERS + MAX_CLIENTS )
 
 #define	RESERVED_CONFIGSTRINGS	2	// game can't modify below this, only the system can
 
@@ -1987,109 +1603,24 @@ typedef struct {
 
 //=========================================================
 
-// all the different tracking "channels"
-typedef enum {
-	TRACK_CHANNEL_NONE = 50,
-	TRACK_CHANNEL_1,
-	TRACK_CHANNEL_2, // force speed
-	TRACK_CHANNEL_3, // force rage
-	TRACK_CHANNEL_4,
-	TRACK_CHANNEL_5, // force sight
-	NUM_TRACK_CHANNELS
-} trackchan_t;
-
-#define TRACK_CHANNEL_MAX (NUM_TRACK_CHANNELS-50)
-
-typedef struct forcedata_s {
-	int			forcePowerDebounce[NUM_FORCE_POWERS];	//for effects that must have an interval
-	int			forcePowersKnown;
-	int			forcePowersActive;
-	int			forcePowerSelected;
-	int			forceButtonNeedRelease;
-	int			forcePowerDuration[NUM_FORCE_POWERS];
-	int			forcePower;
-	int			forcePowerMax;
-	int			forcePowerRegenDebounceTime;
-	int			forcePowerLevel[NUM_FORCE_POWERS];		//so we know the max forceJump power you have
-	int			forcePowerBaseLevel[NUM_FORCE_POWERS];
-	int			forceUsingAdded;
-	float		forceJumpZStart;					//So when you land, you don't get hurt as much
-	float		forceJumpCharge;					//you're current forceJump charge-up level, increases the longer you hold the force jump button down
-	int			forceJumpSound;
-	int			forceJumpAddTime;
-	int			forceGripEntityNum;					//what entity I'm gripping
-	int			forceGripDamageDebounceTime;		//debounce for grip damage
-	float		forceGripBeingGripped;				//if > level.time then client is in someone's grip
-	int			forceGripCripple;					//if != 0 then make it so this client can't move quickly (he's being gripped)
-	int			forceGripUseTime;					//can't use if > level.time
-	float		forceGripSoundTime;
-	float		forceGripStarted;					//level.time when the grip was activated
-	int			forceHealTime;
-	int			forceHealAmount;
-
-	//This hurts me somewhat to do, but there's no other real way to allow completely "dynamic" mindtricking.
-	int			forceMindtrickTargetIndex; //0-15
-	int			forceMindtrickTargetIndex2; //16-32
-	int			forceMindtrickTargetIndex3; //33-48
-	int			forceMindtrickTargetIndex4; //49-64
-
-	int			forceRageRecoveryTime;
-	int			forceDrainEntNum;
-	float		forceDrainTime;
-
-	int			forceDoInit;
-
-	int			forceSide;
-	int			forceRank;
-
-	int			forceDeactivateAll;
-
-	int			killSoundEntIndex[TRACK_CHANNEL_MAX]; //this goes here so it doesn't get wiped over respawn
-
-	qboolean	sentryDeployed;
-
-	int			saberAnimLevelBase;//sigh...
-	int			saberAnimLevel;
-	int			saberDrawAnimLevel;
-
-	int			suicides;
-
-	int			privateDuelTime;
-} forcedata_t;
-
-
-typedef enum {
-	SENTRY_NOROOM = 1,
-	SENTRY_ALREADYPLACED,
-	SHIELD_NOROOM,
-	SEEKER_ALREADYDEPLOYED
-} itemUseFail_t;
-
 // bit field limits
 #define	MAX_STATS				16
 #define	MAX_PERSISTANT			16
-#define	MAX_POWERUPS			16
-#define	MAX_WEAPONS				19		
+#define	MAX_AMMO				16
+#define	MAX_WEAPONS				32		
+#define MAX_GAMETYPE_ITEMS		5
 
-#define	MAX_PS_EVENTS			2
+#define	MAX_PS_EVENTS			4
 
 #define PS_PMOVEFRAMECOUNTBITS	6
 
-#define FORCE_LIGHTSIDE			1
-#define FORCE_DARKSIDE			2
-
-#define MAX_FORCE_RANK			7
-
-#define FALL_FADE_TIME			3000
-
-//#define _ONEBIT_COMBO
-//Crazy optimization attempt to take all those 1 bit values and shove them into a single
-//send. May help us not have to send so many 1/0 bits to acknowledge modified values. -rww
+typedef enum
+{
+	ATTACK_NORMAL,
+	ATTACK_ALTERNATE,
+	ATTACK_MAX
 
-#define _OPTIMIZED_VEHICLE_NETWORKING
-//Instead of sending 2 full playerStates for the pilot and the vehicle, send a smaller,
-//specialized pilot playerState and vehicle playerState.  Also removes some vehicle
-//fields from the normal playerState -mcg
+} attackType_t;
 
 // playerState_t is the information needed by both the client and server
 // to predict player motion and actions
@@ -2101,278 +1632,115 @@ typedef enum {
 // playerState_t is a full superset of entityState_t as it is used by players,
 // so if a playerState_t is transmitted, the entityState_t can be fully derived
 // from it.
+
 typedef struct playerState_s {
 	int			commandTime;	// cmd->serverTime of last executed command
 	int			pm_type;
 	int			bobCycle;		// for view bobbing and footstep generation
-	int			pm_flags;		// ducked, jump_held, etc
+	int			pm_flags;		// ducked, etc
+	int			pm_debounce;	// debounce buttons
 	int			pm_time;
 
 	vec3_t		origin;
 	vec3_t		velocity;
 
-	vec3_t		moveDir; //NOT sent over the net - nor should it be.
-
 	int			weaponTime;
-	int			weaponChargeTime;
-	int			weaponChargeSubtractTime;
-	int			gravity;
-	float		speed;
-	int			basespeed; //used in prediction to know base server g_speed value when modifying speed between updates
-	int			delta_angles[3];	// add to command angles to get view direction
-									// changed by spawns, rotating objects, and teleporters
-
-	int			slopeRecalcTime; //this is NOT sent across the net and is maintained seperately on game and cgame in pmove code.
-
-	int			useTime;
-
-	int			groundEntityNum;// ENTITYNUM_NONE = in air
-
-	int			legsTimer;		// don't change low priority animations until this runs out
-	int			legsAnim;
-
-	int			torsoTimer;		// don't change low priority animations until this runs out
-	int			torsoAnim;
-
-	qboolean	legsFlip; //set to opposite when the same anim needs restarting, sent over in only 1 bit. Cleaner and makes porting easier than having that god forsaken ANIM_TOGGLEBIT.
-	qboolean	torsoFlip;
-
-	int			movementDir;	// a number 0 to 7 that represents the reletive angle
-								// of movement to the view angle (axial and diagonals)
-								// when at rest, the value will remain unchanged
-								// used to twist the legs during strafing
-
-	int			eFlags;			// copied to entityState_t->eFlags
-	int			eFlags2;		// copied to entityState_t->eFlags2, EF2_??? used much less frequently
-
-	int			eventSequence;	// pmove generated events
-	int			events[MAX_PS_EVENTS];
-	int			eventParms[MAX_PS_EVENTS];
+	int			weaponFireBurstCount;
+	int			weaponAnimId;
+	int			weaponAnimIdChoice;
+	int			weaponAnimTime;
+	int			weaponCallbackTime;
+	int			weaponCallbackStep;
 
-	int			externalEvent;	// events set on player from another source
-	int			externalEventParm;
-	int			externalEventTime;
-
-	int			clientNum;		// ranges from 0 to MAX_CLIENTS-1
-	int			weapon;			// copied to entityState_t->weapon
-	int			weaponstate;
-
-	vec3_t		viewangles;		// for fixed views
-	int			viewheight;
-
-	// damage feedback
-	int			damageEvent;	// when it changes, latch the other parms
-	int			damageYaw;
-	int			damagePitch;
-	int			damageCount;
-	int			damageType;
-
-	int			painTime;		// used for both game and client side to process the pain twitch - NOT sent across the network
-	int			painDirection;	// NOT sent across the network
-	float		yawAngle;		// NOT sent across the network
-	qboolean	yawing;			// NOT sent across the network
-	float		pitchAngle;		// NOT sent across the network
-	qboolean	pitching;		// NOT sent across the network
-
-	int			stats[MAX_STATS];
-	int			persistant[MAX_PERSISTANT];	// stats that aren't cleared on death
-	int			powerups[MAX_POWERUPS];	// level.time that the powerup runs out
-	int			ammo[MAX_WEAPONS];
+	int			gravity;
+	int			speed;
+	int			delta_angles[3];				// add to command angles to get view direction
+												// changed by spawns, rotating objects, and teleporters
+	int			groundEntityNum;				// ENTITYNUM_NONE = in air
+												
+	int			legsAnim;						// mask off ANIM_TOGGLEBIT
+												
+	int			torsoTimer;						// don't change low priority animations until this runs out
+	int			torsoAnim;						// mask off ANIM_TOGGLEBIT
+												
+	int			movementDir;					// a number 0 to 7 that represents the reletive angle
+												// of movement to the view angle (axial and diagonals)
+												// when at rest, the value will remain unchanged
+												// used to twist the legs during strafing
+												
+	int			eFlags;							// copied to entityState_t->eFlags
+												
+	int			eventSequence;					// pmove generated events
+	int			events[MAX_PS_EVENTS];			
+	int			eventParms[MAX_PS_EVENTS];		
+												
+	int			externalEvent;					// events set on player from another source
+	int			externalEventParm;				
+	int			externalEventTime;				
+												
+	int			clientNum;						// ranges from 0 to MAX_CLIENTS-1
+	int			weapon;							// copied to entityState_t->weapon
+	int			weaponstate;					
+												
+	vec3_t		viewangles;						// for fixed views
+	int			viewheight;						
+												
+	// damage feedback							
+	int			damageEvent;					// when it changes, latch the other parms
+	int			damageYaw;						
+	int			damagePitch;					
+	int			damageCount;					
+												
+	int			painTime;						// used for both game and client side to process the pain twitch - NOT sent across the network
+	int			painDirection;					// NOT sent across the network
+										
+	int			stats[MAX_STATS];				
+	int			persistant[MAX_PERSISTANT];		// stats that aren't cleared on death
+	int			ammo[MAX_AMMO];
+	int			clip[ATTACK_MAX][MAX_WEAPONS];
+	int			firemode[MAX_WEAPONS];
 
 	int			generic1;
 	int			loopSound;
-	int			jumppad_ent;	// jumppad entity hit this frame
+
+	// Incaccuracy values for firing
+	int			inaccuracy;
+	int			inaccuracyTime;
+	int			kickPitch;
 
 	// not communicated over the net at all
-	int			ping;			// server to game info for scoreboard
-	int			pmove_framecount;	// FIXME: don't transmit over the network
+	int			ping;							// server to game info for scoreboard
+	int			pmove_framecount;				// FIXME: don't transmit over the network
 	int			jumppad_frame;
 	int			entityEventSequence;
+	vec3_t		pvsOrigin;						// view origin used to calculate PVS (also the lean origin)
+												// THIS VARIABLE MUST AT LEAST BE THE PLAYERS ORIGIN ALL OF THE 
+												// TIME OR THE PVS CALCULATIONS WILL NOT WORK.
 
-	int			lastOnGround;	//last time you were on the ground
-
-	qboolean	saberInFlight;
-
-	int			saberMove;
-	int			saberBlocking;
-	int			saberBlocked;
-
-	int			saberLockTime;
-	int			saberLockEnemy;
-	int			saberLockFrame; //since we don't actually have the ability to get the current anim frame
-	int			saberLockHits; //every x number of buttons hits, allow one push forward in a saber lock (server only)
-	int			saberLockHitCheckTime; //so we don't allow more than 1 push per server frame
-	int			saberLockHitIncrementTime; //so we don't add a hit per attack button press more than once per server frame
-	qboolean	saberLockAdvance; //do an advance (sent across net as 1 bit)
-
-	int			saberEntityNum;
-	float		saberEntityDist;
-	int			saberEntityState;
-	int			saberThrowDelay;
-	qboolean	saberCanThrow;
-	int			saberDidThrowTime;
-	int			saberDamageDebounceTime;
-	int			saberHitWallSoundDebounceTime;
-	int			saberEventFlags;
-
-	int			rocketLockIndex;
-	float		rocketLastValidTime;
-	float		rocketLockTime;
-	float		rocketTargetTime;
-
-	int			emplacedIndex;
-	float		emplacedTime;
-
-	qboolean	isJediMaster;
-	qboolean	forceRestricted;
-	qboolean	trueJedi;
-	qboolean	trueNonJedi;
-	int			saberIndex;
-
-	int			genericEnemyIndex;
-	float		droneFireTime;
-	float		droneExistTime;
-
-	int			activeForcePass;
-
-	qboolean	hasDetPackPlanted; //better than taking up an eFlag isn't it?
-
-	float		holocronsCarried[NUM_FORCE_POWERS];
-	int			holocronCantTouch;
-	float		holocronCantTouchTime; //for keeping track of the last holocron that just popped out of me (if any)
-	int			holocronBits;
-
-	int			electrifyTime;
-
-	int			saberAttackSequence;
-	int			saberIdleWound;
-	int			saberAttackWound;
-	int			saberBlockTime;
-
-	int			otherKiller;
-	int			otherKillerTime;
-	int			otherKillerDebounceTime;
-
-	forcedata_t	fd;
-	qboolean	forceJumpFlip;
-	int			forceHandExtend;
-	int			forceHandExtendTime;
-
-	int			forceRageDrainTime;
-
-	int			forceDodgeAnim;
-	qboolean	quickerGetup;
-
-	int			groundTime;		// time when first left ground
-
-	int			footstepTime;
-
-	int			otherSoundTime;
-	float		otherSoundLen;
-
-	int			forceGripMoveInterval;
-	int			forceGripChangeMovetype;
-
-	int			forceKickFlip;
-
-	int			duelIndex;
-	int			duelTime;
-	qboolean	duelInProgress;
-
-	int			saberAttackChainCount;
-
-	int			saberHolstered;
-
-	int			forceAllowDeactivateTime;
-
-	// zoom key
-	int			zoomMode;		// 0 - not zoomed, 1 - disruptor weapon
+	// Zooming
 	int			zoomTime;
-	qboolean	zoomLocked;
-	float		zoomFov;
-	int			zoomLockTime;
+	int			zoomFov;
 
-	int			fallingToDeath;
+	// LAdders
+	int			ladder;
+	int			leanTime;
 
-	int			useDelay;
-
-	qboolean	inAirAnim;
-
-	vec3_t		lastHitLoc;
-
-	int			heldByClient; //can only be a client index - this client should be holding onto my arm using IK stuff.
-
-	int			ragAttach; //attach to ent while ragging
-
-	int			iModelScale;
-
-	int			brokenLimbs;
-
-	//for looking at an entity's origin (NPCs and players)
-	qboolean	hasLookTarget;
-	int			lookTarget;
-
-	int			customRGBA[4];
-
-	int			standheight;
-	int			crouchheight;
-
-	//If non-0, this is the index of the vehicle a player/NPC is riding.
-	int			m_iVehicleNum;
-
-	//lovely hack for keeping vehicle orientation in sync with prediction
-	vec3_t		vehOrientation;
-	qboolean	vehBoarding;
-	int			vehSurfaces;
-
-	//vehicle turnaround stuff (need this in ps so it doesn't jerk too much in prediction)
-	int			vehTurnaroundIndex;
-	int			vehTurnaroundTime;
-
-	//vehicle has weapons linked
-	qboolean	vehWeaponsLinked;
-
-	//when hyperspacing, you just go forward really fast for HYPERSPACE_TIME
-	int			hyperSpaceTime;
-	vec3_t		hyperSpaceAngles;
+	// Timers 
+	int			grenadeTimer;
+	int			respawnTimer;
+} playerState_t;
 
-	//hacking when > time
-	int			hackingTime;
-	//actual hack amount - only for the proper percentage display when
-	//drawing progress bar (is there a less bandwidth-eating way to do
-	//this without a lot of hassle?)
-	int			hackingBaseTime;
 
-	//keeps track of jetpack fuel
-	int			jetpackFuel;
+typedef enum 
+{
+	TEAM_FREE,
+	TEAM_RED,
+	TEAM_BLUE,
+	TEAM_SPECTATOR,
 
-	//keeps track of cloak fuel
-	int			cloakFuel;
+	TEAM_NUM_TEAMS
 
-	//rww - spare values specifically for use by mod authors.
-	//See psf_overrides.txt if you want to increase the send
-	//amount of any of these above 1 bit.
-	int			userInt1;
-	int			userInt2;
-	int			userInt3;
-	float		userFloat1;
-	float		userFloat2;
-	float		userFloat3;
-	vec3_t		userVec1;
-	vec3_t		userVec2;
-
-#ifdef _ONEBIT_COMBO
-	int			deltaOneBits;
-	int			deltaNumBits;
-#endif
-} playerState_t;
-
-typedef struct siegePers_s
-{
-	qboolean	beatingTime;
-	int			lastTeam;
-	int			lastTime;
-} siegePers_t;
+} team_t;
 
 //====================================================================
 
@@ -2381,88 +1749,35 @@ typedef struct siegePers_s
 // usercmd_t->button bits, many of which are generated by the client system,
 // so they aren't game/cgame only definitions
 //
-#define	BUTTON_ATTACK			1
-#define	BUTTON_TALK				2			// displays talk balloon and disables actions
-#define	BUTTON_USE_HOLDABLE		4
-#define	BUTTON_GESTURE			8
-#define	BUTTON_WALKING			16			// walking can't just be infered from MOVE_RUN
-										// because a key pressed late in the frame will
-										// only generate a small move value for that frame
-										// walking will use different animations and
-										// won't generate footsteps
-#define	BUTTON_USE				32			// the ol' use key returns!
-#define BUTTON_FORCEGRIP		64			// 
-#define BUTTON_ALT_ATTACK		128
-
-#define	BUTTON_ANY				256			// any key whatsoever
-
-#define BUTTON_FORCEPOWER		512			// use the "active" force power
-
-#define BUTTON_FORCE_LIGHTNING	1024
-
-#define BUTTON_FORCE_DRAIN		2048
-
-// Here's an interesting bit.  The bots in TA used buttons to do additional gestures.
-// I ripped them out because I didn't want too many buttons given the fact that I was already adding some for JK2.
-// We can always add some back in if we want though.
-/*
-#define BUTTON_AFFIRMATIVE	32
-#define	BUTTON_NEGATIVE		64
-
-#define BUTTON_GETFLAG		128
-#define BUTTON_GUARDBASE	256
-#define BUTTON_PATROL		512
-#define BUTTON_FOLLOWME		1024
-*/
-
-#define	MOVE_RUN			120			// if forwardmove or rightmove are >= MOVE_RUN,
-										// then BUTTON_WALKING should be set
-
-typedef enum
-{
-	GENCMD_SABERSWITCH = 1,
-	GENCMD_ENGAGE_DUEL,
-	GENCMD_FORCE_HEAL,
-	GENCMD_FORCE_SPEED,
-	GENCMD_FORCE_THROW,
-	GENCMD_FORCE_PULL,
-	GENCMD_FORCE_DISTRACT,
-	GENCMD_FORCE_RAGE,
-	GENCMD_FORCE_PROTECT,
-	GENCMD_FORCE_ABSORB,
-	GENCMD_FORCE_HEALOTHER,
-	GENCMD_FORCE_FORCEPOWEROTHER,
-	GENCMD_FORCE_SEEING,
-	GENCMD_USE_SEEKER,
-	GENCMD_USE_FIELD,
-	GENCMD_USE_BACTA,
-	GENCMD_USE_ELECTROBINOCULARS,
-	GENCMD_ZOOM,
-	GENCMD_USE_SENTRY,
-	GENCMD_USE_JETPACK,
-	GENCMD_USE_BACTABIG,
-	GENCMD_USE_HEALTHDISP,
-	GENCMD_USE_AMMODISP,
-	GENCMD_USE_EWEB,
-	GENCMD_USE_CLOAK,
-	GENCMD_SABERATTACKCYCLE,
-	GENCMD_TAUNT,
-	GENCMD_BOW,
-	GENCMD_MEDITATE,
-	GENCMD_FLOURISH,
-	GENCMD_GLOAT
-} genCmds_t;
+#define	BUTTON_ATTACK		(1<<0)
+#define	BUTTON_TALK			(1<<1)			// displays talk balloon and disables actions	
+#define BUTTON_GOGGLES		(1<<2)			// turns nv or therm goggles on/off
+#define BUTTON_LEAN			(1<<3)			// lean modifier, when held strafe left and right will lean
+#define	BUTTON_WALKING		(1<<4)			// walking can't just be infered from MOVE_RUN
+											// because a key pressed late in the frame will
+											// only generate a small move value for that frame
+											// walking will use different animations and
+											// won't generate footsteps
+#define	BUTTON_USE			(1<<5)			// the ol' use key returns!
+#define	BUTTON_RELOAD		(1<<6)			// reloads current weapon
+#define BUTTON_ALT_ATTACK	(1<<7)
+#define	BUTTON_ANY			(1<<8)			// any key whatsoever
+#define BUTTON_ZOOMIN		(1<<9)
+#define BUTTON_ZOOMOUT		(1<<10)
+#define BUTTON_FIREMODE		(1<<11)
+
+#define BUTTON_LEAN_RIGHT	(1<<12)
+#define BUTTON_LEAN_LEFT	(1<<13)
 
 // usercmd_t is sent to the server each client frame
 typedef struct usercmd_s {
 	int				serverTime;
 	int				angles[3];
 	int 			buttons;
-	byte			weapon;           // weapon 
-	byte			forcesel;
-	byte			invensel;
-	byte			generic_cmd;
-	signed char	forwardmove, rightmove, upmove;
+	byte			weapon;
+	signed char		forwardmove;
+	signed char		rightmove;
+	signed char		upmove;
 } usercmd_t;
 
 //===================================================================
@@ -2579,9 +1894,10 @@ typedef enum {
 	TR_INTERPOLATE,				// non-parametric, but interpolate between snapshots
 	TR_LINEAR,
 	TR_LINEAR_STOP,
-	TR_NONLINEAR_STOP,
 	TR_SINE,					// value = base + sin( time / duration ) * delta
-	TR_GRAVITY
+	TR_GRAVITY,
+	TR_HEAVYGRAVITY,
+	TR_LIGHTGRAVITY
 } trType_t;
 
 typedef struct {
@@ -2598,168 +1914,53 @@ typedef struct {
 // Different eTypes may use the information in different ways
 // The messages are delta compressed, so it doesn't really matter if
 // the structure size is fairly large
-typedef struct entityState_s {
-	int		number;			// entity index
-	int		eType;			// entityType_t
-	int		eFlags;
-	int		eFlags2;		// EF2_??? used much less frequently
-
-	trajectory_t	pos;	// for calculating position
-	trajectory_t	apos;	// for calculating angles
-
-	int		time;
-	int		time2;
-
-	vec3_t	origin;
-	vec3_t	origin2;
-
-	vec3_t	angles;
-	vec3_t	angles2;
-
-	//rww - these were originally because we shared g2 info client and server side. Now they
-	//just get used as generic values everywhere.
-	int		bolt1;
-	int		bolt2;
-
-	//rww - this is necessary for determining player visibility during a jedi mindtrick
-	int		trickedentindex; //0-15
-	int		trickedentindex2; //16-32
-	int		trickedentindex3; //33-48
-	int		trickedentindex4; //49-64
-
-	float	speed;
-
-	int		fireflag;
-
-	int		genericenemyindex;
-
-	int		activeForcePass;
-
-	int		emplacedOwner;
-
-	int		otherEntityNum;	// shotgun sources, etc
-	int		otherEntityNum2;
-
-	int		groundEntityNum;	// -1 = in air
-
-	int		constantLight;	// r + (g<<8) + (b<<16) + (intensity<<24)
-	int		loopSound;		// constantly loop this sound
-	qboolean	loopIsSoundset; //qtrue if the loopSound index is actually a soundset index
-
-	int		soundSetIndex;
-
-	int		modelGhoul2;
-	int		g2radius;
-	int		modelindex;
-	int		modelindex2;
-	int		clientNum;		// 0 to (MAX_CLIENTS - 1), for players and corpses
-	int		frame;
 
-	qboolean	saberInFlight;
-	int			saberEntityNum;
-	int			saberMove;
-	int			forcePowersActive;
-	int			saberHolstered;//sent in only only 2 bits - should be 0, 1 or 2
-
-	qboolean	isJediMaster;
-
-	qboolean	isPortalEnt; //this needs to be seperate for all entities I guess, which is why I couldn't reuse another value.
-
-	int		solid;			// for client side prediction, trap_linkentity sets this properly
-
-	int		event;			// impulse events -- muzzle flashes, footsteps, etc
-	int		eventParm;
-
-	// so crosshair knows what it's looking at
-	int			owner;
-	int			teamowner;
-	qboolean	shouldtarget;
+typedef struct entityState_s 
+{
+	int				number;			// entity index
+	int				eType;			// entityType_t
+	int				eFlags;
+
+	trajectory_t	pos;			// for calculating position
+	trajectory_t	apos;			// for calculating angles
+
+	int				time;
+	int				time2;
+					
+	vec3_t			origin;
+	vec3_t			origin2;
+					
+	vec3_t			angles;
+	vec3_t			angles2;
+					
+	int				otherEntityNum;	// shotgun sources, etc
+	int				otherEntityNum2;
+					
+	int				groundEntityNum;	// -1 = in air
+					
+	int				loopSound;		// constantly loop this sound
+	int				mSoundSet;
+										
+	int				modelindex;
+	int				modelindex2;
+	int				clientNum;		// 0 to (MAX_CLIENTS - 1), for players and corpses
+	int				frame;
+					
+	int				solid;			// for client side prediction, trap_linkentity sets this properly
+					
+	int				event;			// impulse events -- muzzle flashes, footsteps, etc
+	int				eventParm;
+
+	int				generic1;
 
 	// for players
-	int		powerups;		// bit flags
-	int		weapon;			// determines weapon and flash model, etc
-	int		legsAnim;
-	int		torsoAnim;
-
-	qboolean	legsFlip; //set to opposite when the same anim needs restarting, sent over in only 1 bit. Cleaner and makes porting easier than having that god forsaken ANIM_TOGGLEBIT.
-	qboolean	torsoFlip;
-
-	int		forceFrame;		//if non-zero, force the anim frame
-
-	int		generic1;
-
-	int		heldByClient; //can only be a client index - this client should be holding onto my arm using IK stuff.
-
-	int		ragAttach; //attach to ent while ragging
-
-	int		iModelScale; //rww - transfer a percentage of the normal scale in a single int instead of 3 x-y-z scale values
-
-	int		brokenLimbs;
-
-	int		boltToPlayer; //set to index of a real client+1 to bolt the ent to that client. Must be a real client, NOT an NPC.
-
-	//for looking at an entity's origin (NPCs and players)
-	qboolean	hasLookTarget;
-	int			lookTarget;
-
-	int			customRGBA[4];
-
-	//I didn't want to do this, but I.. have no choice. However, we aren't setting this for all ents or anything,
-	//only ones we want health knowledge about on cgame (like siege objective breakables) -rww
-	int			health;
-	int			maxhealth; //so I know how to draw the stupid health bar
-
-	//NPC-SPECIFIC FIELDS
-	//------------------------------------------------------------
-	int		npcSaber1;
-	int		npcSaber2;
-
-	//index values for each type of sound, gets the folder the sounds
-	//are in. I wish there were a better way to do this,
-	int		csSounds_Std;
-	int		csSounds_Combat;
-	int		csSounds_Extra;
-	int		csSounds_Jedi;
-
-	int		surfacesOn; //a bitflag of corresponding surfaces from a lookup table. These surfaces will be forced on.
-	int		surfacesOff; //same as above, but forced off instead.
-
-	//Allow up to 4 PCJ lookup values to be stored here.
-	//The resolve to configstrings which contain the name of the
-	//desired bone.
-	int		boneIndex1;
-	int		boneIndex2;
-	int		boneIndex3;
-	int		boneIndex4;
-
-	//packed with x, y, z orientations for bone angles
-	int		boneOrient;
-
-	//I.. feel bad for doing this, but NPCs really just need to
-	//be able to control this sort of thing from the server sometimes.
-	//At least it's at the end so this stuff is never going to get sent
-	//over for anything that isn't an NPC.
-	vec3_t	boneAngles1; //angles of boneIndex1
-	vec3_t	boneAngles2; //angles of boneIndex2
-	vec3_t	boneAngles3; //angles of boneIndex3
-	vec3_t	boneAngles4; //angles of boneIndex4
-
-	int		NPC_class; //we need to see what it is on the client for a few effects.
-
-	//If non-0, this is the index of the vehicle a player/NPC is riding.
-	int		m_iVehicleNum;
-
-	//rww - spare values specifically for use by mod authors.
-	//See netf_overrides.txt if you want to increase the send
-	//amount of any of these above 1 bit.
-	int			userInt1;
-	int			userInt2;
-	int			userInt3;
-	float		userFloat1;
-	float		userFloat2;
-	float		userFloat3;
-	vec3_t		userVec1;
-	vec3_t		userVec2;
+	// these fields are only transmitted for client entities!!!!!
+	int				gametypeitems;	// bit flags indicating which items are carried
+	int				weapon;			// determines weapon and flash model, etc
+	int				legsAnim;		// mask off ANIM_TOGGLEBIT
+	int				torsoAnim;		// mask off ANIM_TOGGLEBIT
+	int				torsoTimer;		// time the animation will play for
+	int				leanOffset;		// Lean direction
 } entityState_t;
 
 typedef enum {
@@ -2800,7 +2001,6 @@ typedef struct qtime_s {
 #define AS_GLOBAL			1
 #define AS_FAVORITES		2
 
-#define AS_MPLAYER			3 // (Obsolete)
 
 // cinematic states
 typedef enum {
@@ -2813,15 +2013,6 @@ typedef enum {
 	FMV_ID_WAIT
 } e_status;
 
-typedef enum _flag_status {
-	FLAG_ATBASE = 0,
-	FLAG_TAKEN,			// CTF
-	FLAG_TAKEN_RED,		// One Flag CTF
-	FLAG_TAKEN_BLUE,	// One Flag CTF
-	FLAG_DROPPED
-} flagStatus_t;
-
-
 #define	MAX_GLOBAL_SERVERS			2048
 #define	MAX_OTHER_SERVERS			128
 #define MAX_PINGREQUESTS			32
@@ -2871,9 +2062,76 @@ typedef enum {
 } memtag;
 typedef char memtag_t;
 
+typedef struct 
+{
+	int		isValid;	
+	void	*ghoul2;
+	int		modelNum;
+	int		boltNum;
+	vec3_t	angles;
+	vec3_t	origin;
+	vec3_t	scale;
+	vec3_t	dir;
+	vec3_t	forward;
+
+} CFxBoltInterface;
+
 //rww - conveniently toggle "gore" code, for model decals and stuff.
 #define _G2_GORE
 
+// these are the actual shaders
+typedef enum {
+	PGORE_NONE,
+	PGORE_ARMOR,
+	PGORE_BULLETBIG,
+	PGORE_KNIFESLASH,
+	PGORE_PUNCTURE,
+	PGORE_SHOTGUN,
+	PGORE_SHOTGUNBIG,
+	PGORE_IMMOLATE,
+	PGORE_BURN,
+	PGORE_SPURT,
+	PGORE_SPLATTER,
+	PGORE_BLOODY_GLASS,
+	PGORE_BLOODY_GLASS_B,
+	PGORE_BLOODY_ICK,
+	PGORE_BLOODY_DROOP,
+	PGORE_BLOODY_MAUL,
+	PGORE_BLOODY_DROPS,
+	PGORE_BULLET_E,
+	PGORE_BULLET_F,
+	PGORE_BULLET_G,
+	PGORE_BULLET_H,
+	PGORE_BULLET_I,
+	PGORE_BULLET_J,
+	PGORE_BULLET_K,
+	PGORE_BLOODY_HAND,
+	PGORE_POWDER_BURN_DENSE,
+	PGORE_POWDER_BURN_CHUNKY,
+	PGORE_KNIFESLASH2,
+	PGORE_KNIFESLASH3,
+	PGORE_CHUNKY_SPLAT,
+	PGORE_BIG_SPLATTER,
+	PGORE_BLOODY_SPLOTCH,
+	PGORE_BLEEDER,
+	PGORE_PELLETS,
+	PGORE_KNIFE_SOAK,
+	PGORE_BLEEDER_DENSE,
+	PGORE_BLOODY_SPLOTCH2,
+	PGORE_BLOODY_DRIPS,
+	PGORE_DRIPPING_DOWN,
+	PGORE_GUTSHOT,
+	PGORE_SHRAPNEL,
+	PGORE_COUNT
+} goreEnum_t;
+
+struct goreEnumShader_t
+{
+	int				maxLODBias;   //if r_lodBias (and the other 3 convars) =x then shaders with this larger than x will not be used
+	goreEnum_t		shaderEnum;  // why is this even in here?
+	char			shaderName[MAX_QPATH];
+};
+
 typedef struct SSkinGoreData_s
 {
 	vec3_t			angles;
@@ -2901,11 +2159,9 @@ typedef struct SSkinGoreData_s
 	vec3_t			tint;					// unimplemented
 	float			impactStrength;			// unimplemented
 
-	int				shader; // shader handle 
+	goreEnum_t		shaderEnum; // enum that'll get switched over to the shader's actual handle 
 
 	int				myIndex; // used internally
-
-	qboolean		fadeRGB; //specify fade method to modify RGB (by default, the alpha is set instead)
 } SSkinGoreData;
 
 /*
@@ -2938,12 +2194,4 @@ typedef enum
 } ForceReload_e;
 
 
-enum {
-	FONT_NONE,
-	FONT_SMALL=1,
-	FONT_MEDIUM,
-	FONT_LARGE,
-	FONT_SMALL2
-};
-
 void NET_AddrToString( char *out, size_t size, void *addr );
diff --git a/codemp/qcommon/qcommon.h b/codemp/qcommon/qcommon.h
index 371c3bc..966155c 100644
--- a/codemp/qcommon/qcommon.h
+++ b/codemp/qcommon/qcommon.h
@@ -198,18 +198,15 @@ PROTOCOL
 ==============================================================
 */
 
-#define	PROTOCOL_VERSION	26
+#define	PROTOCOL_VERSION	2004
 
-#define	UPDATE_SERVER_NAME			"updatejk3.ravensoft.com"
-#define MASTER_SERVER_NAME			"masterjk3.ravensoft.com"
+#define	UPDATE_SERVER_NAME			"master.sof2.ravensoft.com"
+#define MASTER_SERVER_NAME			"master.sof2.ravensoft.com"
 
-#define JKHUB_MASTER_SERVER_NAME	"master.jkhub.org"
-#define JKHUB_UPDATE_SERVER_NAME	"update.jkhub.org"
+#define	PORT_MASTER			20110
+#define	PORT_UPDATE			20112
 
-#define	PORT_MASTER			29060
-#define	PORT_UPDATE			29061
-//#define	PORT_AUTHORIZE		29062
-#define	PORT_SERVER			29070	//...+9 more for multiple servers
+#define	PORT_SERVER			20100	//...+9 more for multiple servers
 #define	NUM_SERVER_PORTS	4		// broadcast scan this many ports after PORT_SERVER so a single machine can run multiple servers
 
 // the svc_strings[] array in cl_parse.c should mirror this
@@ -225,7 +222,6 @@ enum svc_ops_e {
 	svc_serverCommand,			// [string] to be executed by client game module
 	svc_download,				// [short] size [size bytes]
 	svc_snapshot,
-	svc_setgame,
 	svc_mapchange,
 	svc_EOF
 };
@@ -293,9 +289,15 @@ int		QDECL VM_Call( vm_t *vm, int callNum, ... );
 
 void	VM_Debug( int level );
 
+void	*VM_Shift(void * mem);
+void	*VM_Local_Alloc(int size);
+void	*VM_Local_AllocUnaligned(int size);
+void	*VM_Local_TempAlloc(int size);
+void	VM_Local_TempFree(int size);
+char	*VM_Local_StringAlloc(const char *source);
+
 void	VM_Shifted_Alloc(void **ptr, int size);
 void	VM_Shifted_Free(void **ptr);
-
 void	*VM_ArgPtr( int intValue );
 void	*VM_ExplicitArgPtr( vm_t *vm, int intValue );
 
@@ -543,7 +545,7 @@ int		FS_LoadStack();
 int		FS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize );
 int		FS_GetModList(  char *listbuf, int bufsize );
 
-fileHandle_t	FS_FOpenFileWrite( const char *qpath );
+fileHandle_t	FS_FOpenFileWrite( const char *qpath, const bool astext = false );
 // will properly create any needed paths and deal with seperater character issues
 
 int		FS_filelength( fileHandle_t f );
diff --git a/codemp/qcommon/stringed_ingame.cpp b/codemp/qcommon/stringed_ingame.cpp
deleted file mode 100644
index 2fd4cdc..0000000
--- a/codemp/qcommon/stringed_ingame.cpp
+++ /dev/null
@@ -1,1256 +0,0 @@
-// Filename:-	stringed_ingame.cpp
-//
-// This file is designed to be pasted into each game project that uses the StringEd package's files.
-//  You can alter the way it does things by (eg) replacing STL with RATL, BUT LEAVE THE OVERALL
-//	FUNCTIONALITY THE SAME, or if I ever make any funadamental changes to the way the package works
-//	then you're going to be SOOL (shit out of luck ;-)...
-//
-
-//////////////////////////////////////////////////
-//
-// stuff common to all qcommon files...
-#include "server/server.h"
-#include "qcommon/q_shared.h"
-#include "qcommon.h"
-//
-//////////////////////////////////////////////////
-
-
-#pragma warning ( disable : 4511 )			// copy constructor could not be generated
-#pragma warning ( disable : 4512 )			// assignment operator could not be generated
-#pragma warning ( disable : 4663 )			// C++ language change: blah blah template crap blah blah
-#include "stringed_ingame.h"
-#include "stringed_interface.h"
-
-///////////////////////////////////////////////
-//
-// some STL stuff...
-#pragma warning ( disable : 4786 )			// disable the usual stupid and pointless STL warning
-#include <list>
-#include <map>
-#include <set>
-#include <string>
-#include <vector>
-using namespace std;
-
-typedef vector<string>	vStrings_t;
-typedef vector<int>		vInts_t;
-//
-///////////////////////////////////////////////
-
-cvar_t	*se_language = NULL;
-cvar_t	*se_debug = NULL;
-cvar_t  *sp_leet = NULL;	// kept as 'sp_' for JK2 compat.
-
-#define __DEBUGOUT(_string)	OutputDebugString(_string)
-#define __ASSERT(_blah)		assert(_blah)
-
-typedef struct SE_Entry_s
-{
-	string		m_strString;
-	string		m_strDebug;	// english and/or "#same", used for debugging only. Also prefixed by "SE:" to show which strings go through StringEd (ie aren't hardwired)
-	int			m_iFlags;
-
-	SE_Entry_s()
-	{
-		m_iFlags = 0;
-	}
-
-} SE_Entry_t;
-
-
-typedef map <string, SE_Entry_t> mapStringEntries_t;
-
-class CStringEdPackage
-{
-private:
-
-	SE_BOOL				m_bEndMarkerFound_ParseOnly;
-	string				m_strCurrentEntryRef_ParseOnly;
-	string				m_strCurrentEntryEnglish_ParseOnly;
-	string				m_strCurrentFileRef_ParseOnly;
-	string				m_strLoadingLanguage_ParseOnly;	// eg "german"
-	SE_BOOL				m_bLoadingEnglish_ParseOnly;
-
-public:
-
-	CStringEdPackage()
-	{
-		Clear( SE_FALSE );
-	}
-
-	~CStringEdPackage()
-	{
-		Clear( SE_FALSE );
-	}
-
-	mapStringEntries_t	m_StringEntries;	// needs to be in public space now
-	SE_BOOL				m_bLoadDebug;		// ""
-	//
-	// flag stuff...
-	//
-	vector <string>		m_vstrFlagNames;
-	map	<string,int>	m_mapFlagMasks;
-
-	void	Clear( SE_BOOL bChangingLanguages );
-	void	SetupNewFileParse( LPCSTR psFileName, SE_BOOL bLoadDebug );
-	SE_BOOL	ReadLine( LPCSTR &psParsePos, char *psDest );
-	LPCSTR	ParseLine( LPCSTR psLine );
-	int		GetFlagMask( LPCSTR psFlagName );
-	LPCSTR	ExtractLanguageFromPath( LPCSTR psFileName );
-	SE_BOOL	EndMarkerFoundDuringParse( void )
-	{
-		return m_bEndMarkerFound_ParseOnly;
-	}
-
-private:
-
-	void	AddEntry( LPCSTR psLocalReference );
-	int		GetNumStrings(void);
-	void	SetString( LPCSTR psLocalReference, LPCSTR psNewString, SE_BOOL bEnglishDebug );
-	SE_BOOL	SetReference( int iIndex, LPCSTR psNewString );
-	void	AddFlagReference( LPCSTR psLocalReference, LPCSTR psFlagName );
-	LPCSTR	GetCurrentFileName(void);
-	LPCSTR	GetCurrentReference_ParseOnly( void );
-	SE_BOOL	CheckLineForKeyword( LPCSTR psKeyword, LPCSTR &psLine);
-	LPCSTR	InsideQuotes( LPCSTR psLine );
-	LPCSTR	ConvertCRLiterals_Read( LPCSTR psString );
-	void	REMKill( char *psBuffer );
-	char	*Filename_PathOnly( LPCSTR psFilename );
-	char	*Filename_WithoutPath(LPCSTR psFilename);
-	char	*Filename_WithoutExt(LPCSTR psFilename);
-};
-
-CStringEdPackage TheStringPackage;
-
-
-void CStringEdPackage::Clear( SE_BOOL bChangingLanguages )
-{
-	m_StringEntries.clear();
-
-	if ( !bChangingLanguages )
-	{
-		// if we're changing languages, then I'm going to leave these alone. This is to do with any (potentially) cached
-		//	flag bitmasks on the game side. It shouldn't matter since all files are written out at once using the build
-		//	command in StringEd. But if ever someone changed a file by hand, or added one, or whatever, and it had a 
-		//	different set of flags declared, or the strings were in a different order, then the flags might also change
-		//	the order I see them in, and hence their indexes and masks. This should never happen unless people mess with
-		//	the .STR files by hand and delete some, but this way makes sure it'll all work just in case...
-		//
-		// ie. flags stay defined once they're defined, and only the destructor (at app-end) kills them.
-		//
-		m_vstrFlagNames.clear();
-		m_mapFlagMasks.clear();
-	}
-
-	m_bEndMarkerFound_ParseOnly = SE_FALSE;
-	m_strCurrentEntryRef_ParseOnly = "";
-	m_strCurrentEntryEnglish_ParseOnly = "";
-	//
-	// the other vars are cleared in SetupNewFileParse(), and are ok to not do here.
-	//
-}
-
-
-
-// loses anything after the path (if any), (eg) "dir/name.bmp" becomes "dir"
-// (copes with either slash-scheme for names)
-//
-// (normally I'd call another function for this, but this is supposed to be engine-independant,
-//	 so a certain amount of re-invention of the wheel is to be expected...)
-//
-char *CStringEdPackage::Filename_PathOnly(LPCSTR psFilename)
-{
-	static char sString[ iSE_MAX_FILENAME_LENGTH ];
-
-	strcpy(sString,psFilename);	
-		
-	char *p1= strrchr(sString,'\\');
-	char *p2= strrchr(sString,'/');
-	char *p = (p1>p2)?p1:p2;
-	if (p)
-		*p=0;
-
-	return sString;
-}
-
-
-// returns (eg) "dir/name" for "dir/name.bmp"
-// (copes with either slash-scheme for names)
-//
-// (normally I'd call another function for this, but this is supposed to be engine-independant,
-//	 so a certain amount of re-invention of the wheel is to be expected...)
-//
-char *CStringEdPackage::Filename_WithoutExt(LPCSTR psFilename)
-{
-	static char sString[ iSE_MAX_FILENAME_LENGTH ];
-
-	strcpy(sString,psFilename);
-
-	char *p = strrchr(sString,'.');		
-	char *p2= strrchr(sString,'\\');
-	char *p3= strrchr(sString,'/');
-
-	// special check, make sure the first suffix we found from the end wasn't just a directory suffix (eg on a path'd filename with no extension anyway)
-	//
-	if (p && 
-		(p2==0 || (p2 && p>p2)) &&
-		(p3==0 || (p3 && p>p3))
-		)
-		*p=0;	
-
-	return sString;
-}
-
-// returns actual filename only, no path
-// (copes with either slash-scheme for names)
-//
-// (normally I'd call another function for this, but this is supposed to be engine-independant,
-//	 so a certain amount of re-invention of the wheel is to be expected...)
-//
-char *CStringEdPackage::Filename_WithoutPath(LPCSTR psFilename)
-{
-	static char sString[ iSE_MAX_FILENAME_LENGTH ];
-
-	LPCSTR psCopyPos = psFilename;
-	
-	while (*psFilename)
-	{
-		if (*psFilename == '/' || *psFilename == '\\')
-			psCopyPos = psFilename+1;
-		psFilename++;
-	}
-
-	strcpy(sString,psCopyPos);
-
-	return sString;
-}
-
-
-LPCSTR CStringEdPackage::ExtractLanguageFromPath( LPCSTR psFileName )
-{
-	return Filename_WithoutPath( Filename_PathOnly( psFileName ) );
-}
-
-
-void CStringEdPackage::SetupNewFileParse( LPCSTR psFileName, SE_BOOL bLoadDebug )
-{
-	char sString[ iSE_MAX_FILENAME_LENGTH ];
-
-	strcpy(sString, Filename_WithoutPath( Filename_WithoutExt( psFileName ) ));
-	Q_strupr(sString);
-
-	m_strCurrentFileRef_ParseOnly = sString;	// eg "OBJECTIVES"
-	m_strLoadingLanguage_ParseOnly = ExtractLanguageFromPath( psFileName );
-	m_bLoadingEnglish_ParseOnly = (!stricmp( m_strLoadingLanguage_ParseOnly.c_str(), "english" )) ? SE_TRUE : SE_FALSE;
-	m_bLoadDebug = bLoadDebug;
-}
-
-
-// returns SE_TRUE if supplied keyword found at line start (and advances supplied ptr past any whitespace to next arg (or line end if none),
-//
-//	else returns SE_FALSE...
-//
-SE_BOOL CStringEdPackage::CheckLineForKeyword( LPCSTR psKeyword, LPCSTR &psLine)
-{
-	if (!Q_stricmpn(psKeyword, psLine, strlen(psKeyword)) )
-	{
-		psLine += strlen(psKeyword);
-
-		// skip whitespace to arrive at next item...
-		//
-		while ( *psLine == '\t' || *psLine == ' ' )
-		{
-			psLine++;
-		}
-		return SE_TRUE;
-	}
-
-	return SE_FALSE;
-}
-
-// change "\n" to '\n' (i.e. 2-byte char-string to 1-byte ctrl-code)...
-//  (or "\r\n" in editor)
-//
-LPCSTR CStringEdPackage::ConvertCRLiterals_Read( LPCSTR psString )
-{
-	static string str;
-	str = psString;
-	int iLoc;
-	while ( (iLoc = str.find("\\n")) != -1 )
-	{
-		str[iLoc  ] = '\n';
-		str.erase( iLoc+1,1 );
-	}
-
-	return str.c_str();
-}
-
-
-// kill off any "//" onwards part in the line, but NOT if it's inside a quoted string...
-//
-void CStringEdPackage::REMKill( char *psBuffer )
-{
-	char *psScanPos = psBuffer;
-	char *p;
-	int iDoubleQuotesSoFar = 0;
-
-	// scan forwards in case there are more than one (and the first is inside quotes)...
-	//
-	while ( (p=strstr(psScanPos,"//")) != NULL)
-	{
-		// count the number of double quotes before this point, if odd number, then we're inside quotes...
-		//
-		int iDoubleQuoteCount = iDoubleQuotesSoFar;
-
-		for (int i=0; i<p-psScanPos; i++)
-		{
-			if (psScanPos[i] == '"')
-			{
-				iDoubleQuoteCount++;
-			}
-		}
-		if (!(iDoubleQuoteCount&1))
-		{
-			// not inside quotes, so kill line here...
-			//			
-			*p='\0';
-			//
-			// and remove any trailing whitespace...
-			//
-			if (psScanPos[0])	// any strlen? (else access violation with -1 below)
-			{
-				int iWhiteSpaceScanPos = strlen(psScanPos)-1;
-				while (iWhiteSpaceScanPos>=0 && isspace(psScanPos[iWhiteSpaceScanPos]))
-				{
-					psScanPos[iWhiteSpaceScanPos--] = '\0';
-				}
-			}
-
-			return;
-		}
-		else
-		{
-			// inside quotes (blast), oh well, skip past and keep scanning...
-			//
-			psScanPos = p+1;
-			iDoubleQuotesSoFar = iDoubleQuoteCount;
-		}
-	}
-}
-
-// returns true while new lines available to be read...
-//
-SE_BOOL CStringEdPackage::ReadLine( LPCSTR &psParsePos, char *psDest )
-{
-	if (psParsePos[0])
-	{	
-		LPCSTR psLineEnd = strchr(psParsePos, '\n');
-		if (psLineEnd)
-		{
-			int iCharsToCopy = (psLineEnd - psParsePos);
-			strncpy(psDest, psParsePos, iCharsToCopy);
-					psDest[iCharsToCopy] = '\0';
-			psParsePos += iCharsToCopy;
-			while (*psParsePos && strchr("\r\n",*psParsePos))
-			{
-				psParsePos++;	// skip over CR or CR/LF pairs
-			}
-		}
-		else
-		{
-			// last line...
-			//
-			strcpy(psDest, psParsePos);
-			psParsePos += strlen(psParsePos);
-		}
-
-		// clean up the line...
-		//
-		if (psDest[0])
-		{
-			int iWhiteSpaceScanPos = strlen(psDest)-1;
-			while (iWhiteSpaceScanPos>=0 && isspace(psDest[iWhiteSpaceScanPos]))
-			{
-				psDest[iWhiteSpaceScanPos--] = '\0';
-			}
-
-			REMKill( psDest );
-		}
-		return SE_TRUE;
-	}
-
-	return SE_FALSE;
-}
-
-// remove any outside quotes from this supplied line, plus any leading or trailing whitespace...
-//
-LPCSTR CStringEdPackage::InsideQuotes( LPCSTR psLine )
-{
-	// I *could* replace this string object with a declared array, but wasn't sure how big to leave it, and it'd have to
-	//	be static as well, hence permanent. (problem on consoles?)
-	//
-	static	string	str;
-					str = "";	// do NOT join to above line
-
-	// skip any leading whitespace...
-	//
-	while (*psLine == ' ' || *psLine == '\t')
-	{
-		psLine++;
-	}
-
-	// skip any leading quote...
-	//
-	if (*psLine == '"')
-	{
-		psLine++;
-	}
-
-	// assign it...
-	//
-	str = psLine;
-
-	if (psLine[0])
-	{
-		// lose any trailing whitespace...
-		//
-		while (	str.c_str()[ strlen(str.c_str()) -1 ] == ' ' ||
-				str.c_str()[ strlen(str.c_str()) -1 ] == '\t'
-				)
-		{
-			str.erase( strlen(str.c_str()) -1, 1);
-		}
-
-		// lose any trailing quote...
-		//
-		if (str.c_str()[ strlen(str.c_str()) -1 ] == '"')
-		{
-			str.erase( strlen(str.c_str()) -1, 1);
-		}
-	}
-
-	// and return it...
-	//
-	return str.c_str();
-}
-
-
-// returns flag bitmask (eg 00000010b), else 0 for not found
-//
-int CStringEdPackage::GetFlagMask( LPCSTR psFlagName )
-{
-	map <string, int>::iterator itFlag = m_mapFlagMasks.find( psFlagName );
-	if ( itFlag != m_mapFlagMasks.end() )
-	{
-		int &iMask = (*itFlag).second;
-		return iMask;
-	}
-
-	return 0;
-}
-
-
-void CStringEdPackage::AddFlagReference( LPCSTR psLocalReference, LPCSTR psFlagName )
-{
-	// add the flag to the list of known ones...
-	//
-	int iMask = GetFlagMask( psFlagName );
-	if (iMask == 0)
-	{
-		m_vstrFlagNames.push_back( psFlagName );
-		iMask = 1 << (m_vstrFlagNames.size()-1);
-		m_mapFlagMasks[ psFlagName ] = iMask;
-	}
-	//
-	// then add the reference to this flag to the currently-parsed reference...
-	//
-	mapStringEntries_t::iterator itEntry = m_StringEntries.find( va("%s_%s",m_strCurrentFileRef_ParseOnly.c_str(), psLocalReference) );
-	if (itEntry != m_StringEntries.end())
-	{
-		SE_Entry_t &Entry = (*itEntry).second;
-		Entry.m_iFlags |= iMask;
-	}
-}
-
-// this copes with both foreigners using hi-char values (eg the french using 0x92 instead of 0x27
-//  for a "'" char), as well as the fact that our buggy fontgen program writes out zeroed glyph info for
-//	some fonts anyway (though not all, just as a gotcha).
-//
-// New bit, instead of static buffer (since XBox guys are desperately short of mem) I return a malloc'd buffer now,
-//	so remember to free it!
-//
-static char *CopeWithDumbStringData( LPCSTR psSentence, LPCSTR psThisLanguage )
-{
-	const int iBufferSize = strlen(psSentence)*3;	// *3 to allow for expansion of anything even stupid string consisting entirely of elipsis chars
-	char *psNewString = (char *) Z_Malloc(iBufferSize, TAG_TEMP_WORKSPACE, qfalse);	
-	Q_strncpyz(psNewString, psSentence, iBufferSize);
-
-	// this is annoying, I have to just guess at which languages to do it for (ie NOT ASIAN/MBCS!!!) since the 
-	//	string system was deliberately (and correctly) designed to not know or care whether it was doing SBCS 
-	//	or MBCS languages, because it was never envisioned that I'd have to clean up other people's mess.
-	//
-	// Ok, bollocks to it, this will have to do. Any other languages that come later and have bugs in their text can
-	//	get fixed by them typing it in properly in the first place...
-	//
-	if (!stricmp(psThisLanguage,"ENGLISH") ||
-		!stricmp(psThisLanguage,"FRENCH") ||
-		!stricmp(psThisLanguage,"GERMAN") ||
-		!stricmp(psThisLanguage,"ITALIAN") ||
-		!stricmp(psThisLanguage,"SPANISH") ||
-		!stricmp(psThisLanguage,"POLISH") ||
-		!stricmp(psThisLanguage,"RUSSIAN")
-		)
-	{
-		char *p;
-
-	//	strXLS_Speech.Replace(va("%c",0x92),va("%c",0x27));	// "'"
-		while ((p=strchr(psNewString,0x92))!=NULL)  // "rich" (and illegal) apostrophe
-		{
-			*p = 0x27;
-		}
-
-	//	strXLS_Speech.Replace(va("%c",0x93),"\"");			// smart quotes -> '"'
-		while ((p=strchr(psNewString,0x93))!=NULL)
-		{
-			*p = '"';
-		}
-
-	//	strXLS_Speech.Replace(va("%c",0x94),"\"");			// smart quotes -> '"'
-		while ((p=strchr(psNewString,0x94))!=NULL)
-		{
-			*p = '"';
-		}
-
-	//	strXLS_Speech.Replace(va("%c",0x0B),".");			// full stop
-		while ((p=strchr(psNewString,0x0B))!=NULL)
-		{
-			*p = '.';
-		}
-
-	//	strXLS_Speech.Replace(va("%c",0x85),"...");			// "..."-char ->  3-char "..."
-		while ((p=strchr(psNewString,0x85))!=NULL)  // "rich" (and illegal) apostrophe
-		{			
-			memmove(p+2,p,strlen(p));
-			*p++ = '.';
-			*p++ = '.';
-			*p   = '.';
-		}
-
-	//	strXLS_Speech.Replace(va("%c",0x91),va("%c",0x27));	// "'"
-		while ((p=strchr(psNewString,0x91))!=NULL)
-		{
-			*p = 0x27;
-		}
-
-	//	strXLS_Speech.Replace(va("%c",0x96),va("%c",0x2D));	// "-"
-		while ((p=strchr(psNewString,0x96))!=NULL)
-		{
-			*p = 0x2D;
-		}
-
-	//	strXLS_Speech.Replace(va("%c",0x97),va("%c",0x2D));	// "-"
-		while ((p=strchr(psNewString,0x97))!=NULL)
-		{
-			*p = 0x2D;
-		}
-
-		// bug fix for picky grammatical errors, replace "?." with "? "
-		//
-		while ((p=strstr(psNewString,"?."))!=NULL)
-		{
-			p[1] = ' ';
-		}
-
-		// StripEd and our print code don't support tabs...
-		//
-		while ((p=strchr(psNewString,0x09))!=NULL)
-		{
-			*p = ' ';
-		}
-	}
-
-	return psNewString;
-}
-
-// return is either NULL for good else error message to display...
-//
-LPCSTR CStringEdPackage::ParseLine( LPCSTR psLine )
-{
-	LPCSTR psErrorMessage = NULL;
-
-	if (psLine)
-	{
-		if (CheckLineForKeyword( sSE_KEYWORD_VERSION, psLine ))
-		{
-			// VERSION 	"1"
-			//
-			LPCSTR psVersionNumber = InsideQuotes( psLine );
-			int		iVersionNumber = atoi( psVersionNumber );
-			
-			if (iVersionNumber != iSE_VERSION)
-			{
-				psErrorMessage = va("Unexpected version number %d, expecting %d!\n", iVersionNumber, iSE_VERSION);
-			}
-		}
-		else
-		if (	CheckLineForKeyword(sSE_KEYWORD_CONFIG, psLine)
-			||	CheckLineForKeyword(sSE_KEYWORD_FILENOTES, psLine)
-			||	CheckLineForKeyword(sSE_KEYWORD_NOTES, psLine)
-			)
-		{
-			// not used ingame, but need to absorb the token
-		}
-		else
-		if (CheckLineForKeyword(sSE_KEYWORD_REFERENCE, psLine))
-		{
-			// REFERENCE	GUARD_GOOD_TO_SEE_YOU
-			//
-			LPCSTR psLocalReference = InsideQuotes( psLine );
-			AddEntry( psLocalReference );
-		}
-		else
-		if (CheckLineForKeyword(sSE_KEYWORD_FLAGS, psLine))
-		{
-			// FLAGS 	FLAG_CAPTION FLAG_TYPEMATIC
-			//
-			LPCSTR psReference = GetCurrentReference_ParseOnly();
-			if (psReference[0])
-			{
-				static const char sSeperators[] = " \t";
-				char sFlags[1024]={0};	// 1024 chars should be enough to store 8 flag names
-				strncpy(sFlags, psLine, sizeof(sFlags)-1);
-				char *psToken = strtok( sFlags, sSeperators );
-				while( psToken != NULL )
-				{
-					// psToken = flag name (in caps)
-					//
-					Q_strupr(psToken);	// jic
-					AddFlagReference( psReference, psToken );
-
-					// read next flag for this string...
-					//
-					psToken = strtok( NULL, sSeperators );
-				}
-			}
-			else
-			{
-				psErrorMessage = "Error parsing file: Unexpected \"" sSE_KEYWORD_FLAGS "\"\n";
-			}
-		}
-		else
-		if (CheckLineForKeyword(sSE_KEYWORD_ENDMARKER, psLine))
-		{
-			// ENDMARKER
-			//
-			m_bEndMarkerFound_ParseOnly = SE_TRUE;	// the only major error checking I bother to do (for file truncation)
-		}
-		else
-		if (!Q_stricmpn(sSE_KEYWORD_LANG, psLine, strlen(sSE_KEYWORD_LANG)))
-		{
-			// LANG_ENGLISH 	"GUARD:  Good to see you, sir.  Taylor is waiting for you in the clean tent.  We need to get you suited up.  "
-			//
-			LPCSTR psReference = GetCurrentReference_ParseOnly();
-			if ( psReference[0] )
-			{
-				psLine += strlen(sSE_KEYWORD_LANG);
-
-				// what language is this?...
-				//
-				LPCSTR psWordEnd = psLine;
-				while (*psWordEnd && *psWordEnd != ' ' && *psWordEnd != '\t')
-				{
-					psWordEnd++;
-				}
-				char sThisLanguage[1024]={0};
-				int iCharsToCopy = psWordEnd - psLine;
-				if (iCharsToCopy > sizeof(sThisLanguage)-1)
-				{
-					iCharsToCopy = sizeof(sThisLanguage)-1;
-				}
-				strncpy(sThisLanguage, psLine, iCharsToCopy);	// already declared as {0} so no need to zero-cap dest buffer
-
-				psLine += strlen(sThisLanguage);
-				LPCSTR _psSentence = ConvertCRLiterals_Read( InsideQuotes( psLine ) );
-
-				// Dammit, I hate having to do crap like this just because other people mess up and put
-				//	stupid data in their text, so I have to cope with it. 
-				//
-				// note hackery with _psSentence and psSentence because of const-ness. bleurgh. Just don't ask.
-				//
-				char *psSentence = CopeWithDumbStringData( _psSentence, sThisLanguage );
-
-				if ( m_bLoadingEnglish_ParseOnly )
-				{
-					// if loading just "english", then go ahead and store it...
-					//
-					SetString( psReference, psSentence, SE_FALSE );
-				}
-				else
-				{
-					// if loading a foreign language...
-					//
-					SE_BOOL bSentenceIsEnglish = (!stricmp(sThisLanguage,"english")) ? SE_TRUE: SE_FALSE;	// see whether this is the english master or not
-
-					// this check can be omitted, I'm just being extra careful here...
-					//
-					if ( !bSentenceIsEnglish )
-					{
-						// basically this is just checking that an .STE file override is the same language as the .STR...
-						//
-						if (stricmp( m_strLoadingLanguage_ParseOnly.c_str(), sThisLanguage ))
-						{
-							psErrorMessage = va("Language \"%s\" found when expecting \"%s\"!\n", sThisLanguage, m_strLoadingLanguage_ParseOnly.c_str());
-						}
-					}
-
-					if (!psErrorMessage)
-					{
-						SetString( psReference, psSentence, bSentenceIsEnglish );
-					}
-				}
-
-				Z_Free( psSentence );
-			}
-			else
-			{
-				psErrorMessage = "Error parsing file: Unexpected \"" sSE_KEYWORD_LANG "\"\n";
-			}
-		}
-		else
-		{
-			psErrorMessage = va("Unknown keyword at linestart: \"%s\"\n", psLine);
-		}
-	}
-
-	return psErrorMessage;
-}
-	
-// returns reference of string being parsed, else "" for none.
-//
-LPCSTR CStringEdPackage::GetCurrentReference_ParseOnly( void )
-{
-	return m_strCurrentEntryRef_ParseOnly.c_str();
-}
-	
-// add new string entry (during parse)
-//
-void CStringEdPackage::AddEntry( LPCSTR psLocalReference )
-{
-	// the reason I don't just assign it anyway is because the optional .STE override files don't contain flags, 
-	//	and therefore would wipe out the parsed flags of the .STR file...
-	//
-	mapStringEntries_t::iterator itEntry = m_StringEntries.find( va("%s_%s",m_strCurrentFileRef_ParseOnly.c_str(), psLocalReference) );
-	if (itEntry == m_StringEntries.end())
-	{
-		SE_Entry_t SE_Entry;
-		m_StringEntries[ va("%s_%s", m_strCurrentFileRef_ParseOnly.c_str(), psLocalReference) ] = SE_Entry;
-	}
-	m_strCurrentEntryRef_ParseOnly = psLocalReference;
-}
-
-LPCSTR Leetify( LPCSTR psString )
-{
-	static string str;
-	str = psString;
-	if (sp_leet->integer == 42)	// very specific test, so you won't hit it accidentally
-	{
-		static const
-		char cReplace[]={	'o','0','l','1','e','3','a','4','s','5','t','7','i','!','h','#',
-							'O','0','L','1','E','3','A','4','S','5','T','7','I','!','H','#'	// laziness because of strchr()
-						};
-
-		char *p;
-		for (int i=0; i<sizeof(cReplace); i+=2)
-		{
-			while ((p=(char*)strchr(str.c_str(),cReplace[i]))!=NULL)
-				*p = cReplace[i+1];
-		}
-	}
-
-	return str.c_str();
-}
-
-
-void CStringEdPackage::SetString( LPCSTR psLocalReference, LPCSTR psNewString, SE_BOOL bEnglishDebug )
-{
-	mapStringEntries_t::iterator itEntry = m_StringEntries.find( va("%s_%s",m_strCurrentFileRef_ParseOnly.c_str(), psLocalReference) );
-	if (itEntry != m_StringEntries.end())
-	{
-		SE_Entry_t &Entry = (*itEntry).second;
-	
-		if ( bEnglishDebug || m_bLoadingEnglish_ParseOnly)
-		{	
-			// then this is the leading english text of a foreign sentence pair (so it's the debug-key text),
-			//	or it's the only text when it's english being loaded...
-			//
-			Entry.m_strString = Leetify( psNewString );
-			if ( m_bLoadDebug )
-			{
-				Entry.m_strDebug = sSE_DEBUGSTR_PREFIX;
-				Entry.m_strDebug+= /* m_bLoadingEnglish_ParseOnly ? "" : */ psNewString;
-				Entry.m_strDebug+= sSE_DEBUGSTR_SUFFIX;
-			}
-			m_strCurrentEntryEnglish_ParseOnly = psNewString;	// for possible "#same" resolving in foreign later
-		}
-		else
-		{				
-			// then this is foreign text (so check for "#same" resolving)...
-			//
-			if (!stricmp(psNewString, sSE_EXPORT_SAME))
-			{
-				Entry.m_strString = m_strCurrentEntryEnglish_ParseOnly;	// foreign "#same" is now english
-				if (m_bLoadDebug)
-				{
-					Entry.m_strDebug = sSE_DEBUGSTR_PREFIX;
-					Entry.m_strDebug+= sSE_EXPORT_SAME;				// english (debug) is now "#same"
-					Entry.m_strDebug+= sSE_DEBUGSTR_SUFFIX;
-				}
-			}
-			else
-			{
-				Entry.m_strString	= psNewString;							// foreign is just foreign
-			}
-		}
-	}
-	else
-	{
-		__ASSERT(0);	// should never happen
-	}
-}
-
-
-
-// filename is local here, eg:	"strings/german/obj.str"
-//
-// return is either NULL for good else error message to display...
-//
-static LPCSTR SE_Load_Actual( LPCSTR psFileName, SE_BOOL bLoadDebug, SE_BOOL bSpeculativeLoad )
-{
-	LPCSTR psErrorMessage = NULL;
-	
-	unsigned char *psLoadedData = SE_LoadFileData( psFileName );
-	if ( psLoadedData )
-	{
-		// now parse the data...
-		//
-		char *psParsePos = (char *) psLoadedData;
-
-		TheStringPackage.SetupNewFileParse( psFileName, bLoadDebug );
-
-		char sLineBuffer[16384];	// should be enough for one line of text (some of them can be BIG though)
-		while ( !psErrorMessage && TheStringPackage.ReadLine((LPCSTR &) psParsePos, sLineBuffer ) )
-		{
-			if (strlen(sLineBuffer))
-			{
-//				__DEBUGOUT( sLineBuffer );
-//				__DEBUGOUT( "\n" );
-
-				psErrorMessage = TheStringPackage.ParseLine( sLineBuffer );
-			}
-		}
-
-		SE_FreeFileDataAfterLoad( psLoadedData);
-		
-		if (!psErrorMessage && !TheStringPackage.EndMarkerFoundDuringParse())
-		{
-			psErrorMessage = va("Truncated file, failed to find \"%s\" at file end!", sSE_KEYWORD_ENDMARKER);
-		}
-	}
-	else
-	{
-		if ( bSpeculativeLoad )
-		{
-			// then it's ok to not find the file, so do nothing...
-		}
-		else
-		{
-			psErrorMessage = va("Unable to load \"%s\"!", psFileName);
-		}
-	}
-
-	return psErrorMessage;
-}
-
-static LPCSTR SE_GetFoundFile( string &strResult )
-{
-	static char sTemp[1024/*MAX_PATH*/];
-
-	if (!strlen(strResult.c_str()))
-		return NULL;
-	
-	strncpy(sTemp,strResult.c_str(),sizeof(sTemp)-1);
-	sTemp[sizeof(sTemp)-1]='\0';
-
-	char *psSemiColon = strchr(sTemp,';');
-	if (  psSemiColon)
-	{
-		 *psSemiColon = '\0';
-
-		 strResult.erase(0,(psSemiColon-sTemp)+1);
-	}
-	else
-	{
-		// no semicolon found, probably last entry? (though i think even those have them on, oh well)
-		//
-		strResult.erase();
-	}
-
-//	strlwr(sTemp);	// just for consistancy and set<> -> set<> erasure checking etc
-
-	return sTemp;
-}
-
-//////////// API entry points from rest of game.... //////////////////////////////
-
-// filename is local here, eg:	"strings/german/obj.str"
-//
-// return is either NULL for good else error message to display...
-//
-LPCSTR SE_Load( LPCSTR psFileName, SE_BOOL bLoadDebug = SE_TRUE, SE_BOOL bFailIsCritical = SE_TRUE  )
-{
-	////////////////////////////////////////////////////
-	//
-	// ingame here tends to pass in names without paths, but I expect them when doing a language load, so...
-	//
-	char sTemp[1000]={0};
-	if (!strchr(psFileName,'/'))
-	{
-		strcpy(sTemp,sSE_STRINGS_DIR);
-		strcat(sTemp,"/");
-		if (se_language)
-		{
-			strcat(sTemp,se_language->string);
-			strcat(sTemp,"/");
-		}
-	}
-	strcat(sTemp,psFileName);
-	COM_DefaultExtension( sTemp, sizeof(sTemp), sSE_INGAME_FILE_EXTENSION);
-	psFileName = &sTemp[0];
-	//
-	////////////////////////////////////////////////////
-
-
-	LPCSTR psErrorMessage = SE_Load_Actual( psFileName, bLoadDebug, SE_FALSE );
-
-	// check for any corresponding / overriding .STE files and load them afterwards...
-	//
-	if ( !psErrorMessage )
-	{
-		char sFileName[ iSE_MAX_FILENAME_LENGTH ];
-		strncpy( sFileName, psFileName, sizeof(sFileName)-1 );
-				 sFileName[ sizeof(sFileName)-1 ] = '\0';
-		char *p = strrchr( sFileName, '.' );
-		if (p && strlen(p) == strlen(sSE_EXPORT_FILE_EXTENSION))
-		{
-			strcpy( p, sSE_EXPORT_FILE_EXTENSION );
-		
-			psErrorMessage = SE_Load_Actual( sFileName, bLoadDebug, SE_TRUE );
-		}
-	}
-
-	if (psErrorMessage)
-	{
-		if (bFailIsCritical)
-		{
-	//		TheStringPackage.Clear(TRUE);	// Will we want to do this?  Any errors that arise should be fixed immediately
-			Com_Error( ERR_DROP, "SE_Load(): Couldn't load \"%s\"!\n\nError: \"%s\"\n", psFileName, psErrorMessage );
-		}
-		else
-		{
-			Com_DPrintf(S_COLOR_YELLOW "SE_Load(): Couldn't load \"%s\"!\n", psFileName );
-		}
-	}
-
-	return psErrorMessage;
-}
-
-
-// convenience-function for the main GetString call...
-//
-LPCSTR SE_GetString( LPCSTR psPackageReference, LPCSTR psStringReference)
-{
-	char sReference[256];	// will always be enough, I've never seen one more than about 30 chars long
-
-	Com_sprintf(sReference,sizeof(sReference),"%s_%s", psPackageReference, psStringReference);
-
-	return SE_GetString( Q_strupr(sReference) );
-}
-
-
-LPCSTR SE_GetString( LPCSTR psPackageAndStringReference )
-{
-	char sReference[256];	// will always be enough, I've never seen one more than about 30 chars long
-	assert(strlen(psPackageAndStringReference) < sizeof(sReference) );
-	Q_strncpyz(sReference, psPackageAndStringReference, sizeof(sReference) );
-	Q_strupr(sReference);
-
-	mapStringEntries_t::iterator itEntry = TheStringPackage.m_StringEntries.find( sReference );
-	if (itEntry != TheStringPackage.m_StringEntries.end())
-	{
-		SE_Entry_t &Entry = (*itEntry).second;
-
-		if ( se_debug->integer && TheStringPackage.m_bLoadDebug )
-		{
-			return Entry.m_strDebug.c_str();
-		}
-		else
-		{
-			return Entry.m_strString.c_str();
-		}
-	}
-
-	// should never get here, but fall back anyway... (except we DO use this to see if there's a debug-friendly key bind, which may not exist)
-	//
-//	__ASSERT(0);
-	return "";	// you may want to replace this with something based on _DEBUG or not?
-}
-
-
-// convenience-function for the main GetFlags call...
-//
-int	SE_GetFlags ( LPCSTR psPackageReference, LPCSTR psStringReference )
-{
-	char sReference[256];	// will always be enough, I've never seen one more than about 30 chars long
-
-	Com_sprintf(sReference,sizeof(sReference),"%s_%s", psPackageReference, psStringReference);
-
-	return SE_GetFlags( sReference );
-}
-
-int	SE_GetFlags ( LPCSTR psPackageAndStringReference )
-{
-	mapStringEntries_t::iterator itEntry = TheStringPackage.m_StringEntries.find( psPackageAndStringReference );
-	if (itEntry != TheStringPackage.m_StringEntries.end())
-	{
-		SE_Entry_t &Entry = (*itEntry).second;
-
-		return Entry.m_iFlags;
-	}
-
-	// should never get here, but fall back anyway...
-	//
-	__ASSERT(0);
-
-	return 0;
-}
-
-
-int SE_GetNumFlags( void )
-{
-	return TheStringPackage.m_vstrFlagNames.size();
-}
-
-LPCSTR SE_GetFlagName( int iFlagIndex )
-{
-	if ( iFlagIndex < TheStringPackage.m_vstrFlagNames.size())
-	{
-		return TheStringPackage.m_vstrFlagNames[ iFlagIndex ].c_str();
-	}
-
-	__ASSERT(0);
-	return "";
-}
-
-// returns flag bitmask (eg 00000010b), else 0 for not found
-//
-int SE_GetFlagMask( LPCSTR psFlagName )
-{
-	return TheStringPackage.GetFlagMask( psFlagName );
-}
-
-// I could cache the result of this since it won't change during app lifetime unless someone does a build-publish
-//	while you're still ingame. Cacheing would make sense since it can take a while to scan, but I'll leave it and
-//	let whoever calls it cache the results instead. I'll make it known that it's a slow process to call this, but 
-//	whenever anyone calls someone else's code they should assign it to an int anyway, since you've no idea what's
-//	going on. Basically, don't  use this in a FOR loop as the end-condition. Duh.
-//
-// Groan, except for Bob. I mentioned that this was slow and only call it once, but he's calling it from 
-//	every level-load...  Ok, cacheing it is...
-//
-vector <string> gvLanguagesAvailable;
-int SE_GetNumLanguages(void)
-{
-	if ( gvLanguagesAvailable.empty() )
-	{
-		string strResults;
-		/*int iFilesFound = */SE_BuildFileList( 
-												#ifdef _STRINGED
-													va("C:\\Source\\Tools\\StringEd\\test_data\\%s",sSE_STRINGS_DIR)
-												#else
-													sSE_STRINGS_DIR
-												#endif
-												, strResults 
-											);
-
-		set<string> strUniqueStrings;	// laziness <g>
-		LPCSTR p;
-		while ((p=SE_GetFoundFile (strResults)) != NULL)
-		{
-			LPCSTR psLanguage = TheStringPackage.ExtractLanguageFromPath( p );
-
-	//		__DEBUGOUT( p );
-	//		__DEBUGOUT( "\n" );
-	//		__DEBUGOUT( psLanguage );
-	//		__DEBUGOUT( "\n" );
-
-			if (!strUniqueStrings.count( psLanguage ))
-			{
-				strUniqueStrings.insert( psLanguage );
-
-				// if english is available, it should always be first... ( I suppose )
-				//
-				if (!stricmp(psLanguage,"english"))
-				{
-					gvLanguagesAvailable.insert( gvLanguagesAvailable.begin(), psLanguage );
-				}
-				else
-				{
-					gvLanguagesAvailable.push_back( psLanguage );
-				}
-			}
-		}
-	}
-
-	return gvLanguagesAvailable.size();
-}
-
-// SE_GetNumLanguages() must have been called before this...
-//
-LPCSTR SE_GetLanguageName( int iLangIndex )
-{
-	if ( iLangIndex < gvLanguagesAvailable.size() )
-	{
-		return gvLanguagesAvailable[ iLangIndex ].c_str();
-	}
-
-	__ASSERT(0);
-	return "";
-}
-
-// SE_GetNumLanguages() must have been called before this...
-//
-LPCSTR SE_GetLanguageDir( int iLangIndex )
-{
-	if ( iLangIndex < gvLanguagesAvailable.size() )
-	{
-		return va("%s/%s", sSE_STRINGS_DIR, gvLanguagesAvailable[ iLangIndex ].c_str() );
-	}
-
-	__ASSERT(0);
-	return "";
-}
-
-void SE_NewLanguage(void)
-{
-	TheStringPackage.Clear( SE_TRUE );
-}
-
-
-
-// these two functions aren't needed other than to make Quake-type games happy and/or stop memory managers
-//	complaining about leaks if they report them before the global StringEd package object calls it's own dtor.
-//
-// but here they are for completeness's sake I guess...
-//
-void SE_Init(void)
-{
-	TheStringPackage.Clear( SE_FALSE );
-
-#ifdef _DEBUG
-//	int iNumLanguages = SE_GetNumLanguages();
-#endif
-
-	se_language = Cvar_Get("se_language", "english", CVAR_ARCHIVE | CVAR_NORESTART);
-	se_debug = Cvar_Get("se_debug", "0", 0);
-	sp_leet = Cvar_Get("sp_leet", "0", CVAR_ROM );
-
-	// if doing a buildscript, load all languages...
-	//
-	extern cvar_t *com_buildScript;
-	if (com_buildScript->integer == 2)
-	{
-		int iLanguages = SE_GetNumLanguages();
-		for (int iLang = 0; iLang < iLanguages; iLang++)
-		{
-            LPCSTR psLanguage = SE_GetLanguageName( iLang );	// eg "german"			
-			Com_Printf( "com_buildScript(2): Loading language \"%s\"...\n", psLanguage );
-			SE_LoadLanguage( psLanguage );
-		}
-	}
-
-	LPCSTR psErrorMessage = SE_LoadLanguage( se_language->string );
-	if (psErrorMessage)
-	{
-		Com_Error( ERR_DROP, "SE_Init() Unable to load language: \"%s\"!\nError: \"%s\"\n", se_language->string,psErrorMessage );
-	}
-
-}
-
-void SE_ShutDown(void)
-{
-	TheStringPackage.Clear( SE_FALSE );
-}
-
-
-// returns error message else NULL for ok.
-//
-// Any errors that result from this should probably be treated as game-fatal, since an asset file is fuxored.
-//
-LPCSTR SE_LoadLanguage( LPCSTR psLanguage, SE_BOOL bLoadDebug /* = SE_TRUE */ )
-{
-	LPCSTR psErrorMessage = NULL;
-
-	if (psLanguage && psLanguage[0])
-	{
-		SE_NewLanguage();
-
-		string strResults;
-		/*int iFilesFound = */SE_BuildFileList( 
-												#ifdef _STRINGED
-													va("C:\\Source\\Tools\\StringEd\\test_data\\%s",sSE_STRINGS_DIR)
-												#else
-													sSE_STRINGS_DIR
-												#endif
-												, strResults 
-											);
-
-		LPCSTR p;
-		while ( (p=SE_GetFoundFile (strResults)) != NULL && !psErrorMessage )
-		{
-			LPCSTR psThisLang = TheStringPackage.ExtractLanguageFromPath( p );
-
-			if ( !stricmp( psLanguage, psThisLang ) )
-			{
-				psErrorMessage = SE_Load( p, bLoadDebug );
-			}
-		}
-	}
-	else
-	{
-		__ASSERT( 0 && "SE_LoadLanguage(): Bad language name!" );
-	}
-
-	return psErrorMessage;
-}
-
-
-// called in Com_Frame, so don't take up any time! (can also be called during dedicated)
-//
-// instead of re-loading just the files we've already loaded I'm going to load the whole language (simpler)
-//
-void SE_CheckForLanguageUpdates(void)
-{
-	if (se_language && se_language->modified)
-	{
-		LPCSTR psErrorMessage = SE_LoadLanguage( se_language->string, SE_TRUE );
-		if ( psErrorMessage )
-		{
-			Com_Error( ERR_DROP, psErrorMessage );
-		}
-		se_language->modified = SE_FALSE;
-	}
-}
-
-
-///////////////////////// eof //////////////////////////
diff --git a/codemp/qcommon/stringed_ingame.h b/codemp/qcommon/stringed_ingame.h
deleted file mode 100644
index 2cb2cc0..0000000
--- a/codemp/qcommon/stringed_ingame.h
+++ /dev/null
@@ -1,110 +0,0 @@
-// Filename:-	stringed_ingame.h
-//
-
-#ifndef STRINGED_INGAME_H
-#define	STRINGED_INGAME_H
-
-
-// alter these to suit your own game...
-//
-#define SE_BOOL					qboolean
-#define SE_TRUE					qtrue
-#define SE_FALSE				qfalse
-#define	iSE_MAX_FILENAME_LENGTH	MAX_QPATH
-#define sSE_STRINGS_DIR			"strings"
-#define sSE_DEBUGSTR_PREFIX		"["		// any string you want prefixing onto the debug versions of strings (to spot hardwired english etc)
-#define sSE_DEBUGSTR_SUFFIX		"]"		// ""
-
-extern cvar_t	*se_language;
-
-// some needed text-equates, do not alter these under any circumstances !!!! (unless you're me. Which you're not)
-//
-#define iSE_VERSION					1
-#define sSE_KEYWORD_VERSION			"VERSION"
-#define sSE_KEYWORD_CONFIG			"CONFIG"
-#define sSE_KEYWORD_FILENOTES		"FILENOTES"
-#define sSE_KEYWORD_REFERENCE		"REFERENCE"
-#define sSE_KEYWORD_FLAGS 			"FLAGS"
-#define sSE_KEYWORD_NOTES			"NOTES"
-#define sSE_KEYWORD_LANG			"LANG_"
-#define sSE_KEYWORD_ENDMARKER		"ENDMARKER"
-#define sSE_FILE_EXTENSION			".st"	// editor-only NEVER used ingame, but I wanted all extensions together
-#define sSE_EXPORT_FILE_EXTENSION	".ste"
-#define sSE_INGAME_FILE_EXTENSION	".str"
-#define sSE_EXPORT_SAME				"#same"
-
-
-
-// available API calls...
-//
-typedef const char *LPCSTR;
-
-void	SE_Init				( void );
-void	SE_ShutDown			( void );
-void	SE_CheckForLanguageUpdates(void);
-int		SE_GetNumLanguages	( void );
-LPCSTR	SE_GetLanguageName	( int iLangIndex );	// eg "german"
-LPCSTR	SE_GetLanguageDir	( int iLangIndex );	// eg "strings/german"
-LPCSTR	SE_LoadLanguage		( LPCSTR psLanguage, SE_BOOL bLoadDebug = SE_TRUE );
-void	SE_NewLanguage		( void );
-//
-// for convenience, two ways of getting at the same data...
-//
-LPCSTR	SE_GetString		( LPCSTR psPackageReference, LPCSTR psStringReference);
-LPCSTR	SE_GetString		( LPCSTR psPackageAndStringReference);
-//
-// ditto...
-//
-int		SE_GetFlags			( LPCSTR psPackageReference, LPCSTR psStringReference );
-int		SE_GetFlags			( LPCSTR psPackageAndStringReference );
-//
-// general flag functions... (SEP_GetFlagMask() return should be used with SEP_GetFlags() return)
-//
-int		SE_GetNumFlags		( void );
-LPCSTR	SE_GetFlagName		( int iFlagIndex );
-int		SE_GetFlagMask		( LPCSTR psFlagName );
-
-
-// note that so far the only place in the game that needs to know these is the font system so it can know how to
-//	interpret char codes, for this reason I'm only exposing these simple bool queries...
-//
-inline SE_BOOL Language_IsRussian(void)
-{
-	return (se_language && !Q_stricmp(se_language->string, "russian")) ? SE_TRUE : SE_FALSE;	
-}
-
-inline SE_BOOL Language_IsPolish(void)
-{
-	return (se_language && !Q_stricmp(se_language->string, "polish")) ? SE_TRUE : SE_FALSE;	
-}
-
-inline SE_BOOL Language_IsKorean(void)
-{
-	return (se_language && !Q_stricmp(se_language->string, "korean")) ? SE_TRUE : SE_FALSE;
-}
-
-inline SE_BOOL Language_IsTaiwanese(void)
-{
-	return (se_language && !Q_stricmp(se_language->string, "taiwanese")) ? SE_TRUE : SE_FALSE;
-}
-
-inline SE_BOOL Language_IsJapanese(void)
-{
-	return (se_language && !Q_stricmp(se_language->string, "japanese")) ? SE_TRUE : SE_FALSE;
-}
-
-inline SE_BOOL Language_IsChinese(void)
-{
-	return (se_language && !Q_stricmp(se_language->string, "chinese")) ? SE_TRUE : SE_FALSE;
-}
-
-inline SE_BOOL Language_IsThai(void)
-{
-	return (se_language && !Q_stricmp(se_language->string, "thai")) ? SE_TRUE : SE_FALSE;
-}
-
-
-#endif	// #ifndef STRINGED_INGAME_H
-
-/////////////////// eof ////////////////
-
diff --git a/codemp/qcommon/stringed_interface.cpp b/codemp/qcommon/stringed_interface.cpp
deleted file mode 100644
index eaca6a2..0000000
--- a/codemp/qcommon/stringed_interface.cpp
+++ /dev/null
@@ -1,215 +0,0 @@
-// Filename:-	stringed_interface.cpp
-//
-// This file contains functions that StringEd wants to call to do things like load/save, they can be modified
-//	for use ingame, but must remain functionally the same...
-//
-//  Please try and put modifications for whichever games this is used for inside #defines, so I can copy the same file
-//		into each project.
-//
-
-
-//////////////////////////////////////////////////
-//
-// stuff common to all qcommon files...
-#include "server/server.h"
-#include "qcommon/q_shared.h"
-#include "qcommon.h"
-//
-//////////////////////////////////////////////////
-
-
-#pragma warning ( disable : 4511 )			// copy constructor could not be generated
-#pragma warning ( disable : 4512 )			// assignment operator could not be generated
-#pragma warning ( disable : 4663 )			// C++ language change: blah blah template crap blah blah
-#include "stringed_interface.h"
-#include "stringed_ingame.h"
-
-#include <string>
-using namespace std;
-
-#ifdef _STRINGED
-#include <stdlib.h>
-#include <memory.h>
-#include "generic.h"
-#endif
-
-
-// this just gets the binary of the file into memory, so I can parse it. Called by main SGE loader
-//
-//  returns either char * of loaded file, else NULL for failed-to-open...
-//
-unsigned char *SE_LoadFileData( const char *psFileName, int *piLoadedLength /* = 0 */)
-{
-	unsigned char *psReturn = NULL;
-	if ( piLoadedLength )
-	{
-		*piLoadedLength = 0;
-	}
-
-#ifdef _STRINGED
-	if (psFileName[1] == ':')
-	{
-		// full-path filename...
-		//
-		FILE *fh = fopen( psFileName, "rb" );
-		if (fh)
-		{
-			long lLength = filesize(fh);
-
-			if (lLength > 0)
-			{
-				psReturn = (unsigned char *) malloc( lLength + 1);
-				if (psReturn)
-				{
-					int iBytesRead = fread( psReturn, 1, lLength, fh );
-					if (iBytesRead != lLength)
-					{
-						// error reading file!!!...
-						//
-						free(psReturn);
-							 psReturn = NULL;
-					}
-					else
-					{
-						psReturn[ lLength ] = '\0';
-						if ( piLoadedLength )
-						{
-							*piLoadedLength = iBytesRead;
-						}
-					}
-					fclose(fh);
-				}
-			}
-		}
-	}
-	else
-#endif
-	{
-		// local filename, so prepend the base dir etc according to game and load it however (from PAK?)
-		//		
-		unsigned char *pvLoadedData;		
-		int iLen = FS_ReadFile( psFileName, (void **)&pvLoadedData );
-
-		if (iLen>0)
-		{
-			psReturn = pvLoadedData;
-			if ( piLoadedLength )
-			{
-				*piLoadedLength = iLen;
-			}
-		}
-	}
-
-	return psReturn;
-}
-
-
-// called by main SGE code after loaded data has been parsedinto internal structures...
-//
-void SE_FreeFileDataAfterLoad( unsigned char *psLoadedFile )
-{
-#ifdef _STRINGED
-	if ( psLoadedFile )
-	{
-		free( psLoadedFile );
-	}
-#else
-	if ( psLoadedFile )
-	{
-		FS_FreeFile( psLoadedFile );
-	}	
-#endif
-}
-
-
-
-
-
-#ifndef _STRINGED
-// quake-style method of doing things since their file-list code doesn't have a 'recursive' flag...
-//
-int giFilesFound;
-static void SE_R_ListFiles( const char *psExtension, const char *psDir, string &strResults )
-{
-//	Com_Printf(va("Scanning Dir: %s\n",psDir));
-
-	char	**sysFiles, **dirFiles;
-	int		numSysFiles, i, numdirs;
-
-	dirFiles = FS_ListFiles( psDir, "/", &numdirs);
-	for (i=0;i<numdirs;i++)
-	{
-		if (dirFiles[i][0] && dirFiles[i][0] != '.')	// skip blanks, plus ".", ".." etc
-		{
-			char	sDirName[MAX_QPATH];
-			Com_sprintf(sDirName, sizeof(sDirName), "%s/%s", psDir, dirFiles[i]);
-			//
-			// for some reason the quake filesystem in this game now returns an extra slash on the end,
-			//	didn't used to. Sigh...
-			//
-			if (sDirName[strlen(sDirName)-1] == '/')
-			{
-				sDirName[strlen(sDirName)-1] = '\0';
-			}
-			SE_R_ListFiles( psExtension, sDirName, strResults );
-		}
-	}
-
-	sysFiles = FS_ListFiles( psDir, psExtension, &numSysFiles );
-	for(i=0; i<numSysFiles; i++)
-	{
-		char	sFilename[MAX_QPATH];
-		Com_sprintf(sFilename, sizeof(sFilename), "%s/%s", psDir, sysFiles[i]);		
-			
-//		Com_Printf("%sFound file: %s",!i?"\n":"",sFilename);
-
-		strResults += sFilename;
-		strResults += ';';
-		giFilesFound++;
-
-		// read it in...
-		//
-/*		byte *pbData = NULL;
-		int iSize = FS_ReadFile( sFilename, (void **)&pbData);
-
-		if (pbData)
-		{
-
-			FS_FreeFile( pbData );
-		}
-*/
-	}
-	FS_FreeFileList( sysFiles );
-	FS_FreeFileList( dirFiles );
-}
-#endif
-
-
-// replace this with a call to whatever your own code equivalent is.
-//
-// expected result is a ';'-delineated string (including last one) containing file-list search results
-//
-int SE_BuildFileList( const char *psStartDir, string &strResults )
-{
-#ifndef _STRINGED
-	giFilesFound = 0;
-	strResults = "";
-
-	SE_R_ListFiles( sSE_INGAME_FILE_EXTENSION, psStartDir, strResults );
-
-	return giFilesFound;
-#else
-	// .ST files...
-	//
-	int iFilesFound = BuildFileList(	va("%s\\*%s",psStartDir, sSE_INGAME_FILE_EXTENSION),	// LPCSTR psPathAndFilter, 
-										true					// bool bRecurseSubDirs
-										);
-
-	extern string strResult;
-	strResults = strResult;
-	return iFilesFound;
-#endif
-}
-
-/////////////////////// eof ///////////////////////
-
diff --git a/codemp/qcommon/stringed_interface.h b/codemp/qcommon/stringed_interface.h
deleted file mode 100644
index a315d09..0000000
--- a/codemp/qcommon/stringed_interface.h
+++ /dev/null
@@ -1,21 +0,0 @@
-// Filename:-	stringed_interface.h
-//
-// These are the functions that get replaced by game-specific ones (or StringEd code) so SGE can access files etc
-//
-
-#ifndef STRINGED_INTERFACE_H
-#define STRINGED_INTERFACE_H
-
-#pragma warning ( disable : 4786 )			// disable the usual stupid and pointless STL warning
-#include <string>
-using namespace std;
-
-unsigned char *	SE_LoadFileData			( const char *psFileName, int *piLoadedLength = 0);
-void			SE_FreeFileDataAfterLoad( unsigned char *psLoadedFile );
-int				SE_BuildFileList		( const char *psStartDir, string &strResults );
-
-#endif	// #ifndef STRINGED_INTERFACE_H
-
-
-////////////////// eof ///////////////////
-
diff --git a/codemp/qcommon/vm.cpp b/codemp/qcommon/vm.cpp
index d504a99..17e8d7e 100644
--- a/codemp/qcommon/vm.cpp
+++ b/codemp/qcommon/vm.cpp
@@ -467,6 +467,8 @@ it will attempt to load as a system dll
 */
 
 #define	STACK_SIZE	0x20000
+#define LOCAL_POOL_SIZE 2048000
+static byte * dllLocalPool = 0;
 
 vm_t *VM_Create( const char *module, int (*systemCalls)(int *), 
 				vmInterpret_t interpret ) {
@@ -510,6 +512,11 @@ vm_t *VM_Create( const char *module, int (*systemCalls)(int *),
 		Com_Printf( "Loading dll file %s.\n", vm->name );
 		vm->dllHandle = Sys_LoadGameDll( module, &vm->entryPoint, VM_DllSyscall );
 		if ( vm->dllHandle ) {
+			// allocate memory for local allocs
+			vm->localPoolStart = 0;
+			vm->localPoolSize = 0;
+			vm->localPoolTail = LOCAL_POOL_SIZE;
+			dllLocalPool = (unsigned char *)VM_Alloc( LOCAL_POOL_SIZE );
 			return vm;
 		}
 
@@ -544,7 +551,10 @@ vm_t *VM_Create( const char *module, int (*systemCalls)(int *),
 
 	// round up to next power of 2 so all data operations can
 	// be mask protected
-	dataLength = header->dataLength + header->litLength + header->bssLength;
+	vm->localPoolStart = header->dataLength + header->litLength + header->bssLength;
+	vm->localPoolSize = 0;
+	vm->localPoolTail = LOCAL_POOL_SIZE;
+	dataLength = vm->localPoolStart + LOCAL_POOL_SIZE;
 	for ( i = 0 ; dataLength > ( 1 << i ) ; i++ ) {
 	}
 	dataLength = 1 << i;
@@ -597,6 +607,10 @@ VM_Free
 */
 void VM_Free( vm_t *vm ) {
 
+#ifdef _WIN32
+	VirtualFree(vm->codeBase, vm->codeLength, MEM_RELEASE);
+#endif
+
 	if ( vm->dllHandle ) {
 		Sys_UnloadDll( vm->dllHandle );
 		Com_Memset( vm, 0, sizeof( *vm ) );
@@ -669,6 +683,107 @@ void *BotVMShift( int ptr )
 	}
 }
 
+void *VM_Shift ( void * mem )
+{
+	//Alright, subtract the database from the memory pointer to get a memory address relative to the VM.
+	//When the VM modifies it it should be modifying the same chunk of memory we have allocated in the engine.
+	return (void*)((int)mem - (int)currentVM->dataBase);
+}
+
+/// Local pool allocation mirrored from BG_Local_Alloc and such
+void *VM_Local_Alloc ( int size )
+{
+	if (!currentVM)
+	{
+		assert(0);
+		return NULL;
+	}
+
+	currentVM->localPoolSize = ((currentVM->localPoolSize + 0x00000003) & 0xfffffffc);
+
+	if (currentVM->localPoolSize + size > currentVM->localPoolTail)
+	{
+		Com_Error( ERR_DROP, "VM_Local_Alloc: buffer exceeded tail (%d > %d)", currentVM->localPoolSize + size, currentVM->localPoolTail);
+		return 0;
+	}
+
+	currentVM->localPoolSize += size;
+	
+	byte * pool = currentVM->dataBase;
+	if (!currentVM->dataBase) {
+		pool = dllLocalPool;
+	}
+	return VM_Shift(&pool[currentVM->localPoolStart + currentVM->localPoolSize - size]);
+}
+
+void *VM_Local_AllocUnaligned ( int size )
+{
+	if (!currentVM)
+	{
+		assert(0);
+		return NULL;
+	}
+
+	if (currentVM->localPoolSize + size > currentVM->localPoolTail)
+	{
+		Com_Error( ERR_DROP, "VM_Local_AllocUnaligned: buffer exceeded tail (%d > %d)", currentVM->localPoolSize + size, currentVM->localPoolTail);
+		return 0;
+	}
+
+	currentVM->localPoolSize += size;
+
+	byte * pool = currentVM->dataBase;
+	if (!currentVM->dataBase) {
+		pool = dllLocalPool;
+	}
+	return VM_Shift(&pool[currentVM->localPoolStart + currentVM->localPoolSize-size]);
+}
+
+void *VM_Local_TempAlloc( int size )
+{
+	if (!currentVM)
+	{
+		assert(0);
+		return NULL;
+	}
+
+	size = ((size + 0x00000003) & 0xfffffffc);
+
+	if (currentVM->localPoolTail - size < currentVM->localPoolSize)
+	{
+		Com_Error( ERR_DROP, "VM_Local_TempAlloc: buffer exceeded head (%d > %d)", currentVM->localPoolTail - size, currentVM->localPoolSize);
+		return 0;
+	}
+
+	currentVM->localPoolTail -= size;
+
+	byte * pool = currentVM->dataBase;
+	if (!currentVM->dataBase) {
+		pool = dllLocalPool;
+	}
+	return VM_Shift(&pool[currentVM->localPoolStart + currentVM->localPoolTail]);
+}
+
+void VM_Local_TempFree( int size )
+{
+	size = ((size + 0x00000003) & 0xfffffffc);
+
+	if (currentVM->localPoolTail+size > LOCAL_POOL_SIZE)
+	{
+		Com_Error( ERR_DROP, "BG_TempFree: tail greater than size (%d > %d)", currentVM->localPoolTail+size, LOCAL_POOL_SIZE );
+	}
+
+	currentVM->localPoolTail += size;
+}
+
+char *VM_Local_StringAlloc ( const char *source )
+{
+	char *dest = (char*)VM_Local_Alloc( strlen ( source ) + 1 );
+	char *localDest = (char*)VM_ArgPtr((int)dest);
+	strcpy( localDest, source );
+	return dest;
+}
+
 void VM_Shifted_Alloc(void **ptr, int size)
 {
 	void *mem;
diff --git a/codemp/qcommon/vm_local.h b/codemp/qcommon/vm_local.h
index c8c9271..7c6eb67 100644
--- a/codemp/qcommon/vm_local.h
+++ b/codemp/qcommon/vm_local.h
@@ -132,6 +132,9 @@ struct vm_s {
 
 	byte		*dataBase;
 	int			dataMask;
+	int			localPoolStart;
+	int			localPoolSize;
+	int			localPoolTail;
 
 	int			stackBottom;		// if programStack < stackBottom, error
 
diff --git a/codemp/qcommon/vm_x86.cpp b/codemp/qcommon/vm_x86.cpp
index 7acb3f0..a9a22be 100644
--- a/codemp/qcommon/vm_x86.cpp
+++ b/codemp/qcommon/vm_x86.cpp
@@ -1025,8 +1025,21 @@ void VM_Compile( vm_t *vm, vmHeader_t *header ) {
 
 	// copy to an exact size buffer on the hunk
 	vm->codeLength = compiledOfs;
+#ifdef _WIN32
+	vm->codeBase = (byte *) VirtualAlloc(NULL, compiledOfs, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
+#else
 	vm->codeBase = (unsigned char *)Hunk_Alloc( compiledOfs, h_low );
+#endif
 	Com_Memcpy( vm->codeBase, buf, compiledOfs );
+#ifdef _WIN32
+    {
+            DWORD oldProtect = 0;
+                
+            // remove write permissions.
+            if(!VirtualProtect(vm->codeBase, compiledOfs, PAGE_EXECUTE_READ, &oldProtect))
+                    Com_Error(ERR_DROP, "VM_CompileX86: VirtualProtect failed");
+    }
+#endif
 	Z_Free( buf );
 	Z_Free( jused );
 	Com_Printf( "VM file %s compiled to %i bytes of code\n", vm->name, compiledOfs);
diff --git a/codemp/rd-dedicated/tr_image.cpp b/codemp/rd-dedicated/tr_image.cpp
index 533183d..1908862 100644
--- a/codemp/rd-dedicated/tr_image.cpp
+++ b/codemp/rd-dedicated/tr_image.cpp
@@ -924,11 +924,13 @@ qhandle_t RE_RegisterServerSkin( const char *name ) {
 		ri.Com_TheHunkMarkHasBeenMade() &&
 		ShaderHashTableExists())
 	{ //If the client is running then we can go straight into the normal registerskin func
-		return RE_RegisterSkin(name);
+		//KLAAS TODO
+		return RE_RegisterSkin(name, NULL);
 	}
 
 	gServerSkinHack = true;
-	r = RE_RegisterSkin(name);
+	//KLAAS TODO
+	r = RE_RegisterSkin(name, NULL);
 	gServerSkinHack = false;
 
 	return r;
diff --git a/codemp/rd-dedicated/tr_local.h b/codemp/rd-dedicated/tr_local.h
index dbd0268..e101f50 100644
--- a/codemp/rd-dedicated/tr_local.h
+++ b/codemp/rd-dedicated/tr_local.h
@@ -1360,7 +1360,7 @@ void		RE_SetWorldVisData( const byte *vis );
 
 qhandle_t	RE_RegisterServerModel( const char *name );
 qhandle_t	RE_RegisterModel( const char *name );
-qhandle_t	RE_RegisterSkin( const char *name );
+qhandle_t	RE_RegisterSkin( const char *name, const char *skins );
 void		RE_Shutdown( qboolean destroyWindow );
 
 void		RE_RegisterMedia_LevelLoadBegin(const char *psMapName, ForceReload_e eForceReload);
@@ -1730,8 +1730,8 @@ void	RB_CalcColorFromOneMinusEntity( unsigned char *dstColors );
 void	RB_CalcSpecularAlpha( unsigned char *alphas );
 void	RB_CalcDisintegrateColors( unsigned char *colors );
 void	RB_CalcDiffuseColor( unsigned char *colors );
-void	RB_CalcDiffuseEntityColor( unsigned char *colors );
-void	RB_CalcDisintegrateVertDeform( void );
+//void	RB_CalcDiffuseEntityColor( unsigned char *colors );
+//void	RB_CalcDisintegrateVertDeform( void );
 
 /*
 =============================================================
diff --git a/codemp/rd-vanilla/G2_API.cpp b/codemp/rd-vanilla/G2_API.cpp
index ea2c736..73dfc2a 100644
--- a/codemp/rd-vanilla/G2_API.cpp
+++ b/codemp/rd-vanilla/G2_API.cpp
@@ -145,39 +145,6 @@ qboolean G2_SetupModelPointers(CGhoul2Info *ghlInfo);
 qboolean G2_SetupModelPointers(CGhoul2Info_v &ghoul2);
 qboolean G2_TestModelPointers(CGhoul2Info *ghlInfo);
 
-//rww - RAGDOLL_BEGIN
-#define NUM_G2T_TIME (2)
-static int G2TimeBases[NUM_G2T_TIME];
-
-void G2API_SetTime(int currentTime,int clock)
-{
-	assert(clock>=0&&clock<NUM_G2T_TIME);
-#if G2_DEBUG_TIME
-	Com_Printf("Set Time: before c%6d  s%6d",G2TimeBases[1],G2TimeBases[0]);
-#endif
-	G2TimeBases[clock]=currentTime;
-	if (G2TimeBases[1]>G2TimeBases[0]+200)
-	{
-		G2TimeBases[1]=0; // use server time instead
-		return;
-	}
-#if G2_DEBUG_TIME
-	Com_Printf(" after c%6d  s%6d\n",G2TimeBases[1],G2TimeBases[0]);
-#endif
-}
-
-int	G2API_GetTime(int argTime) // this may or may not return arg depending on ghoul2_time cvar
-{
-	int ret=G2TimeBases[1];
-	if ( !ret )
-	{
-		ret = G2TimeBases[0];
-	}
-
-	return ret;
-}
-//rww - RAGDOLL_END
-
 //rww - Stuff to allow association of ghoul2 instances to entity numbers.
 //This way, on listen servers when both the client and server are doing
 //ghoul2 operations, we can copy relevant data off the client instance
@@ -245,7 +212,7 @@ qboolean G2API_OverrideServerWithClientData(CGhoul2Info *serverInstance)
 	CGhoul2Info_v &g2Ref = *g2ClientAttachments[serverInstance->entityNum];
 	clientInstance = &g2Ref[0];
 
-	int frameNum = G2API_GetTime(0);
+	int frameNum = 0;
 
 	if (clientInstance->mSkelFrameNum != frameNum)
 	{ //it has to be constructed already
@@ -628,7 +595,7 @@ int G2API_InitGhoul2Model(CGhoul2Info_v **ghoul2Ptr, const char *fileName, int m
 	}
 	if (model==ghoul2.size())
 	{	//init should not be used to create additional models, only the first one
-		assert(ghoul2.size() < 4); //use G2API_CopySpecificG2Model to add models
+		assert(ghoul2.size() < 7); //use G2API_CopySpecificG2Model to add models
 		ghoul2.push_back(CGhoul2Info()); 
 	}
 
@@ -690,13 +657,13 @@ qboolean G2API_SetShader(CGhoul2Info *ghlInfo, qhandle_t customShader)
 	return qfalse;
 }
 
-qboolean G2API_SetSurfaceOnOff(CGhoul2Info_v &ghoul2, const char *surfaceName, const int flags)
+qboolean G2API_SetSurfaceOnOff(CGhoul2Info_v &ghoul2, int modelIndex, const char *surfaceName, const int flags)
 {
 	CGhoul2Info *ghlInfo = NULL;
 
 	if ((int)&ghoul2 && ghoul2.size()>0)
 	{
-		ghlInfo = &ghoul2[0];
+		ghlInfo = &ghoul2[modelIndex];
 	}
 
 	if (G2_SetupModelPointers(ghlInfo))
@@ -1133,8 +1100,7 @@ qboolean G2API_GetBoneAnim(CGhoul2Info *ghlInfo, const char *boneName, const int
 	assert(currentFrame!=animSpeed); //this is bad
 	if (G2_SetupModelPointers(ghlInfo))
 	{
-		int aCurrentTime=G2API_GetTime(currentTime);
- 		qboolean ret=G2_Get_Bone_Anim(ghlInfo, ghlInfo->mBlist, boneName, aCurrentTime, currentFrame,
+ 		qboolean ret=G2_Get_Bone_Anim(ghlInfo, ghlInfo->mBlist, boneName, currentTime, currentFrame,
 			startFrame, endFrame, flags, animSpeed, modelList, ghlInfo->mModelindex);
 #ifdef _DEBUG
 		/*
@@ -1421,7 +1387,6 @@ extern int ragTraceCount;
 void G2API_AnimateG2ModelsRag(CGhoul2Info_v &ghoul2, int AcurrentTime,CRagDollUpdateParams *params)
 {
 	int model;
-	int currentTime=G2API_GetTime(AcurrentTime);
 
 #ifdef _DEBUG
 	ragTraceTime = 0;
@@ -1434,7 +1399,7 @@ void G2API_AnimateG2ModelsRag(CGhoul2Info_v &ghoul2, int AcurrentTime,CRagDollUp
 	{
 		if (ghoul2[model].mModel)
 		{
-			G2_Animate_Bone_List(ghoul2,currentTime,model,params);	
+			G2_Animate_Bone_List(ghoul2,AcurrentTime,model,params);	
 		}
 	}
 #ifdef _DEBUG
@@ -1796,7 +1761,6 @@ qboolean G2API_GetBoltMatrix(CGhoul2Info_v &ghoul2, const int modelIndex, const
 	{
 		if (matrix&&modelIndex>=0&&modelIndex<ghoul2.size())
 		{
-			int tframeNum=G2API_GetTime(frameNum);
 			CGhoul2Info *ghlInfo = &ghoul2[modelIndex];
 			G2ERROR(boltIndex >= 0 && (boltIndex < ghlInfo->mBltlist.size()),va("Invalid Bolt Index (%d:%s)",boltIndex,ghlInfo->mFileName));
 
@@ -1817,9 +1781,9 @@ qboolean G2API_GetBoltMatrix(CGhoul2Info_v &ghoul2, const int modelIndex, const
 					gG2_GBMNoReconstruct = qfalse;
 				}
 #else
-				if (G2_NeedsRecalc(ghlInfo,tframeNum))
+				if (G2_NeedsRecalc(ghlInfo,frameNum))
 				{
-					G2_ConstructGhoulSkeleton(ghoul2,tframeNum,true,scale);
+					G2_ConstructGhoulSkeleton(ghoul2,frameNum,true,scale);
 				}
 #endif
 
@@ -2007,10 +1971,8 @@ static inline bool G2_NeedRetransform(CGhoul2Info *g2, int frameNum)
 		int newFrame = bone.startFrame + (time * bone.animSpeed);
 
 		if (newFrame < bone.endFrame ||
-			(bone.flags & BONE_ANIM_OVERRIDE_LOOP) ||
-			(bone.flags & BONE_NEED_TRANSFORM))
+			(bone.flags & BONE_ANIM_OVERRIDE_LOOP))
 		{ //ok, we're gonna have to do it. bone is apparently animating.
-			bone.flags &= ~BONE_NEED_TRANSFORM;
 			needTrans = true;
 		}
 		i++;
@@ -2030,9 +1992,8 @@ void G2API_CollisionDetectCache(CollisionRecord_t *collRecMap, CGhoul2Info_v &gh
 	{
 		vec3_t	transRayStart, transRayEnd;
 
-		int tframeNum=G2API_GetTime(frameNumber);
 		// make sure we have transformed the whole skeletons for each model
-		if (G2_NeedRetransform(&ghoul2[0], tframeNum) || !ghoul2[0].mTransformedVertsArray)
+		if (G2_NeedRetransform(&ghoul2[0], frameNumber) || !ghoul2[0].mTransformedVertsArray)
 		{ //optimization, only create new transform space if we need to, otherwise
 			//store it off!
 			int i = 0;
@@ -2268,7 +2229,7 @@ int G2API_CopyGhoul2Instance(CGhoul2Info_v &g2From, CGhoul2Info_v &g2To, int mod
 	return -1;
 }
 
-void G2API_CopySpecificG2Model(CGhoul2Info_v &ghoul2From, int modelFrom, CGhoul2Info_v &ghoul2To, int modelTo)
+int G2API_CopySpecificG2Model(CGhoul2Info_v &ghoul2From, int modelFrom, CGhoul2Info_v &ghoul2To, int modelTo)
 {
 #if 0
 	qboolean forceReconstruct = qtrue;
@@ -2282,10 +2243,17 @@ void G2API_CopySpecificG2Model(CGhoul2Info_v &ghoul2From, int modelFrom, CGhoul2
 		// assume we actually have a model to copy from
 		if (ghoul2From.size() > modelFrom)
 		{
+			// if it's -1 append it to the end
+			if (modelTo == -1)
+			{
+				modelTo = ghoul2To.size();
+			}
+
 			// if we don't have enough models on the to side, resize us so we do
 			if (ghoul2To.size() <= modelTo)
 			{
-				assert (modelTo < 5);
+				//SOF2 TODO
+				//assert (modelTo < 5);
 				ghoul2To.resize(modelTo + 1);
 #if 0
 				forceReconstruct = qtrue;
@@ -2313,6 +2281,7 @@ void G2API_CopySpecificG2Model(CGhoul2Info_v &ghoul2From, int modelFrom, CGhoul2
 #endif
 		}
 	}
+	return modelTo;
 }
 
 // This version will automatically copy everything about this model, and make a new one if necessary.
@@ -2414,13 +2383,13 @@ char *G2API_GetGLAName(CGhoul2Info_v &ghoul2, int modelIndex)
 	return NULL;
 }
 
-qboolean G2API_SetNewOrigin(CGhoul2Info_v &ghoul2, const int boltIndex)
+qboolean G2API_SetNewOrigin(CGhoul2Info_v &ghoul2, const int modelIndex, const int boltIndex)
 {
 	CGhoul2Info *ghlInfo = NULL;
 
 	if ((int)&ghoul2 && ghoul2.size()>0)
 	{
-		ghlInfo = &ghoul2[0];
+		ghlInfo = &ghoul2[modelIndex];
 	}
 
 	if (G2_SetupModelPointers(ghlInfo))
@@ -2458,6 +2427,15 @@ int G2API_GetBoneIndex(CGhoul2Info *ghlInfo, const char *boneName)
 	return -1;
 }
 
+int G2API_GetBoltIndex(CGhoul2Info *ghlInfo, const int modelIndex)
+{
+	if (G2_SetupModelPointers(ghlInfo))
+	{
+		return G2_Find_Bolt_Bone_Num(ghlInfo->mBltlist, modelIndex);
+	}
+	return -1;
+}
+
 qboolean G2API_SaveGhoul2Models(CGhoul2Info_v &ghoul2, char **buffer, int *size)
 {
 	return G2_SaveGhoul2Models(ghoul2, buffer, size);
@@ -2519,6 +2497,145 @@ qboolean G2API_SkinlessModel(CGhoul2Info *g2)
 #ifdef _G2_GORE
 void ResetGoreTag(); // put here to reduce coupling
 
+qhandle_t goreShaders[PGORE_COUNT];
+
+void G2API_InitGore(void)
+{
+	for (int gore = 0; gore < PGORE_COUNT; ++gore) {
+		char * shaderPath = 0;
+		switch (gore) {
+			case PGORE_ARMOR:
+				shaderPath = "skingore/armor";
+				break;
+			case PGORE_BULLETBIG:
+				shaderPath = "models/characters/gore/new_bullet_1";
+				break;
+			case PGORE_KNIFESLASH:
+				shaderPath = "models/characters/gore/knife_slash";
+				break;
+			case PGORE_PUNCTURE:
+				shaderPath = "models/characters/gore/knife_puncture";
+				break;
+			case PGORE_SHOTGUN:
+				shaderPath = "models/characters/gore/bullet_hole_shotgun";
+				break;
+			case PGORE_SHOTGUNBIG:
+				shaderPath = "models/characters/gore/bullet_hole_shotgun2";
+				break;
+			case PGORE_IMMOLATE:
+				shaderPath = "models/characters/gore/immolation_sensation";
+				break;
+			case PGORE_BURN:
+				shaderPath = "models/characters/gore/damage_scorch";
+				break;
+			case PGORE_SPURT:
+				shaderPath = "models/characters/gore/spurter";
+				break;
+			case PGORE_SPLATTER:
+				shaderPath = "models/characters/gore/splatter";
+				break;
+			case PGORE_BLOODY_GLASS:
+				shaderPath = "models/characters/gore/bloody_glass";
+				break;
+			case PGORE_BLOODY_GLASS_B:
+				shaderPath = "models/characters/gore/bloody_glass_b";
+				break;
+			case PGORE_BLOODY_ICK:
+				shaderPath = "models/characters/gore/bloody_ick";
+				break;
+			case PGORE_BLOODY_DROOP:
+				shaderPath = "models/characters/gore/bloody_droop";
+				break;
+			case PGORE_BLOODY_MAUL:
+				shaderPath = "models/characters/gore/bloody_maul";
+				break;
+			case PGORE_BLOODY_DROPS:
+				shaderPath = "models/characters/gore/bloody_drops";
+				break;
+			case PGORE_BULLET_E:
+				shaderPath = "models/characters/gore/bullet_e";
+				break;
+			case PGORE_BULLET_F:
+				shaderPath = "models/characters/gore/bullet_f";
+				break;
+			case PGORE_BULLET_G:
+				shaderPath = "models/characters/gore/bullet_g";
+				break;
+			case PGORE_BULLET_H:
+				shaderPath = "models/characters/gore/bullet_h";
+				break;
+			case PGORE_BULLET_I:
+				shaderPath = "models/characters/gore/bullet_i";
+				break;
+			case PGORE_BULLET_J:
+				shaderPath = "models/characters/gore/bullet_j";
+				break;
+			case PGORE_BULLET_K:
+				shaderPath = "models/characters/gore/bullet_k";
+				break;
+			case PGORE_BLOODY_HAND:
+				shaderPath = "models/characters/gore/bloody_hand";
+				break;
+			case PGORE_POWDER_BURN_DENSE:
+				shaderPath = "models/characters/gore/powder_burn_dense";
+				break;
+			case PGORE_POWDER_BURN_CHUNKY:
+				shaderPath = "models/characters/gore/powder_burn_chunky";
+				break;
+			case PGORE_KNIFESLASH2:
+				shaderPath = "models/characters/gore/knife_slash2";
+				break;
+			case PGORE_KNIFESLASH3:
+				shaderPath = "models/characters/gore/knife_slash3";
+				break;
+			case PGORE_CHUNKY_SPLAT:
+				shaderPath = "models/characters/gore/chunky_splat";
+				break;
+			case PGORE_BIG_SPLATTER:
+				shaderPath = "models/characters/gore/big_splatter";
+				break;
+			case PGORE_BLOODY_SPLOTCH:
+				shaderPath = "models/characters/gore/bloody_splotch";
+				break;
+			case PGORE_BLEEDER:
+				shaderPath = "models/characters/gore/bleeder";
+				break;
+			case PGORE_PELLETS:
+				shaderPath = "models/characters/gore/pellets";
+				break;
+			case PGORE_KNIFE_SOAK:
+				shaderPath = "models/characters/gore/knife_soak";
+				break;
+			case PGORE_BLEEDER_DENSE:
+				shaderPath = "models/characters/gore/bleeder_dense";
+				break;
+			case PGORE_BLOODY_SPLOTCH2:
+				shaderPath = "models/characters/gore/bloody_splotch2";
+				break;
+			case PGORE_BLOODY_DRIPS:
+				shaderPath = "models/characters/gore/bloody_drips";
+				break;
+			case PGORE_DRIPPING_DOWN:
+				shaderPath = "models/characters/gore/dripping_down";
+				break;
+			case PGORE_GUTSHOT:
+				shaderPath = "models/characters/gore/gutshot";
+				break;
+			case PGORE_SHRAPNEL:
+				shaderPath = "models/characters/gore/gore_shrapnel";
+				break;
+			case PGORE_NONE:
+			default:
+				break;
+		}
+		qhandle_t shader = 0;
+		if (shaderPath) {
+			shader = RE_RegisterShader(shaderPath);
+		}
+		goreShaders[gore] = shader;
+	}
+}
+
 //way of seeing how many marks are on a model currently -rww
 int G2API_GetNumGoreMarks(CGhoul2Info *g2)
 {
@@ -2586,10 +2703,14 @@ void G2API_AddSkinGore(CGhoul2Info_v &ghoul2,SSkinGoreData &gore)
 
 		G2_TransformModel(ghoul2, gore.currentTime, gore.scale,ri.GetG2VertSpaceServer(),lod,true);
 
+		// Get the gore2 shader
+		int goreShader = goreShaders[gore.shaderEnum];
+
 		// now walk each model and compute new texture coordinates
-		G2_TraceModels(ghoul2, transHitLocation, transRayDirection, 0, gore.entNum, 0,lod,0.0f,gore.SSize,gore.TSize,gore.theta,gore.shader,&gore,qtrue);
+		G2_TraceModels(ghoul2, transHitLocation, transRayDirection, 0, gore.entNum, 0,lod,0.0f,gore.SSize,gore.TSize,gore.theta,goreShader,&gore,qtrue);
 	}
 }
+
 #endif
 
 qboolean G2_TestModelPointers(CGhoul2Info *ghlInfo) // returns true if the model is properly set up
@@ -2769,4 +2890,4 @@ qboolean G2_SetupModelPointers(CGhoul2Info_v &ghoul2) // returns true if any mod
 		ret=ret||r;
 	}
 	return (qboolean)ret;
-}
+}
\ No newline at end of file
diff --git a/codemp/rd-vanilla/G2_bolts.cpp b/codemp/rd-vanilla/G2_bolts.cpp
index bea01ea..42c2d5d 100644
--- a/codemp/rd-vanilla/G2_bolts.cpp
+++ b/codemp/rd-vanilla/G2_bolts.cpp
@@ -324,4 +324,4 @@ void G2_RemoveRedundantBolts(boltInfo_v &bltlist, surfaceInfo_v &slist, int *act
 			}
 		}
 	}
-}
+}
\ No newline at end of file
diff --git a/codemp/rd-vanilla/G2_bones.cpp b/codemp/rd-vanilla/G2_bones.cpp
index 5bbe3b0..85f4cce 100644
--- a/codemp/rd-vanilla/G2_bones.cpp
+++ b/codemp/rd-vanilla/G2_bones.cpp
@@ -645,9 +645,6 @@ qboolean G2_Set_Bone_Anim_Index(
 		{
 			return qtrue; // don't accept any calls on ragdoll bones
 		}
-
-		//mark it for needing a transform for the cached trace transform stuff
-		blist[index].flags |= BONE_NEED_TRANSFORM;
 	}
 
 	if (setFrame != -1)
@@ -1380,7 +1377,7 @@ static int G2_Set_Bone_Angles_Rag(
 				assert(!"Invalid RAG PCJ\n");
 			}
 		}
-		bone.ragStartTime=G2API_GetTime(0);
+		bone.ragStartTime=0;
 		bone.boneBlendStart = bone.ragStartTime;
 		bone.boneBlendTime = blendTime;
 		bone.radius=radius;
@@ -1643,7 +1640,7 @@ void G2_SetRagDoll(CGhoul2Info_v &ghoul2V,CRagDollParams *parms)
 	{
 		return;
 	}
-	int curTime=G2API_GetTime(0);
+	int curTime=0;
 	boneInfo_v &blist = ghoul2.mBlist;
 	int	index = G2_Find_Bone_Rag(&ghoul2, blist, "model_root");
 	switch (parms->RagPhase)
@@ -2133,7 +2130,7 @@ void G2_SetRagDollBullet(CGhoul2Info &ghoul2,const vec3_t rayStart,const vec3_t
 	//				bone.lastAngles[2]+=flrand(-10.0f*lenr,10.0f*lenr);
 
 					// go dynamic
-					bone.firstCollisionTime=G2API_GetTime(0);
+					bone.firstCollisionTime=0;
 //					bone.firstCollisionTime=0;
 					bone.restTime=0;
 				}
@@ -2265,7 +2262,7 @@ static bool G2_RagDollSetup(CGhoul2Info &ghoul2,int frameNum,bool resetOrigin,co
 		if (bone.boneNumber>=0)
 		{
 			assert(bone.boneNumber<MAX_BONES_RAG);
-			if ((bone.flags & BONE_ANGLES_RAGDOLL) || (bone.flags & BONE_ANGLES_IK))
+			if (bone.flags & BONE_ANGLES_RAGDOLL)
 			{
 				//rww - this was (!anyRendered) before. Isn't that wrong? (if anyRendered, then wasRendered should be true)
 				bool wasRendered=
@@ -2415,7 +2412,7 @@ static void G2_RagDoll(CGhoul2Info_v &ghoul2V,int g2Index,CRagDollUpdateParams *
 #endif
 
 //	params->DebugLine(handPos,handPos2,false);
-	int frameNum=G2API_GetTime(0);
+	int frameNum=0;
 	CGhoul2Info &ghoul2=ghoul2V[g2Index];
 	assert(ghoul2.mFileName[0]);
 	boneInfo_v &blist = ghoul2.mBlist;
@@ -2692,7 +2689,7 @@ void Rag_Trace( trace_t *results, const vec3_t start, const vec3_t mins, const v
 		callData->ignore = passEntityNum;
 		callData->mask = contentmask;
 
-		ri.VM_Call(cgame_vm, CG_RAG_CALLBACK, RAG_CALLBACK_TRACELINE);
+		//ri.VM_Call(cgame_vm, CG_RAG_CALLBACK, RAG_CALLBACK_TRACELINE);
 
 		*results = callData->tr;
 	}
@@ -2888,7 +2885,7 @@ static inline void G2_RagDebugBox(vec3_t mins, vec3_t maxs, int duration)
 	VectorCopy(mins, callData->mins);
 	VectorCopy(maxs, callData->maxs);
 
-	ri.VM_Call(cgame_vm, CG_RAG_CALLBACK, RAG_CALLBACK_DEBUGBOX);
+	//ri.VM_Call(cgame_vm, CG_RAG_CALLBACK, RAG_CALLBACK_DEBUGBOX);
 }
 
 static inline void G2_RagDebugLine(vec3_t start, vec3_t end, int time, int color, int radius)
@@ -2907,7 +2904,7 @@ static inline void G2_RagDebugLine(vec3_t start, vec3_t end, int time, int color
 	callData->color = color;
 	callData->radius = radius;
 
-	ri.VM_Call(cgame_vm, CG_RAG_CALLBACK, RAG_CALLBACK_DEBUGLINE);
+	//ri.VM_Call(cgame_vm, CG_RAG_CALLBACK, RAG_CALLBACK_DEBUGLINE);
 }
 #endif
 
@@ -3518,6 +3515,8 @@ static bool G2_RagDollSettlePositionNumeroTrois(CGhoul2Info_v &ghoul2V, const ve
 
 		if (bone.RagFlags & RAG_PCJ_PELVIS)
 		{
+//SOF2 TODO
+#define DEFAULT_MINS_2 -24
 			VectorSet(goalSpot, params->position[0], params->position[1], (params->position[2]+DEFAULT_MINS_2)+((bone.radius*entScale[2])+2));
 
 			VectorSubtract(goalSpot, e.currentOrigin, desiredPelvisOffset);
@@ -3943,7 +3942,7 @@ static inline void G2_BoneSnap(CGhoul2Info_v &ghoul2V, boneInfo_t &bone, CRagDol
 	callData->entNum = params->me;
 	strcpy(callData->boneName, G2_Get_Bone_Name(&ghoul2V[0], ghoul2V[0].mBlist, bone.boneNumber));
 
-	ri.VM_Call(cgame_vm, CG_RAG_CALLBACK, RAG_CALLBACK_BONESNAP);
+	//ri.VM_Call(cgame_vm, CG_RAG_CALLBACK, RAG_CALLBACK_BONESNAP);
 }
 
 static void G2_RagDollSolve(CGhoul2Info_v &ghoul2V,int g2Index,float decay,int frameNum,const vec3_t currentOrg,bool limitAngles,CRagDollUpdateParams *params)
@@ -4439,7 +4438,7 @@ static void G2_DoIK(CGhoul2Info_v &ghoul2V,int g2Index,CRagDollUpdateParams *par
 		return;
 	}
 
-	int frameNum=G2API_GetTime(0);
+	int frameNum=0;
 	CGhoul2Info &ghoul2=ghoul2V[g2Index];
 	assert(ghoul2.mFileName[0]);
 
@@ -4532,10 +4531,9 @@ static int G2_Set_Bone_Angles_IK(
 	if (index != -1)
 	{
 		boneInfo_t &bone=blist[index];
-		bone.flags |= BONE_ANGLES_IK;
 		bone.flags &= ~BONE_ANGLES_RAGDOLL;
 
-		bone.ragStartTime=G2API_GetTime(0);
+		bone.ragStartTime=0;
 		bone.radius=radius;
 		bone.weight=1.0f;
 
@@ -4664,7 +4662,6 @@ qboolean G2_SetBoneIKState(CGhoul2Info_v &ghoul2, int time, const char *boneName
 				if (bone.boneNumber != -1)
 				{
 					bone.flags &= ~BONE_ANGLES_RAGDOLL;
-					bone.flags &= ~BONE_ANGLES_IK;
 					bone.RagFlags = 0;
 					bone.lastTimeUpdated = 0;
 				}
@@ -4718,7 +4715,6 @@ qboolean G2_SetBoneIKState(CGhoul2Info_v &ghoul2, int time, const char *boneName
 		//G2_Remove_Bone_Index(blist, index);
 		//actually, I want to keep it on the rag list, and remove it as an IK bone instead.
 		bone.flags &= ~BONE_ANGLES_RAGDOLL;
-		bone.flags |= BONE_ANGLES_IK;
 		bone.RagFlags &= ~RAG_PCJ_IK_CONTROLLED;
 		return qtrue;
 	}
diff --git a/codemp/rd-vanilla/G2_local.h b/codemp/rd-vanilla/G2_local.h
index ca9ac9e..6cff1a2 100644
--- a/codemp/rd-vanilla/G2_local.h
+++ b/codemp/rd-vanilla/G2_local.h
@@ -86,9 +86,6 @@ void		G2_RemoveRedundantBolts(boltInfo_v &bltlist, surfaceInfo_v &slist, int *ac
 
 
 // API calls - G2_API.cpp
-void		G2API_SetTime(int currentTime, int clock);
-int			G2API_GetTime(int argTime);
-
 qhandle_t	G2API_PrecacheGhoul2Model(const char *fileName);
 
 int			G2API_InitGhoul2Model(CGhoul2Info_v **ghoul2Ptr, const char *fileName, int modelIndex, qhandle_t customSkin = NULL, qhandle_t customShader = NULL, int modelFlags = 0, int lodBias = 0);
@@ -98,7 +95,7 @@ qboolean	G2API_SetShader(CGhoul2Info *ghlInfo, qhandle_t customShader);
 qboolean	G2API_HasGhoul2ModelOnIndex(CGhoul2Info_v **ghlRemove, const int modelIndex);
 qboolean	G2API_RemoveGhoul2Model(CGhoul2Info_v **ghlRemove, const int modelIndex);
 qboolean	G2API_RemoveGhoul2Models(CGhoul2Info_v **ghlRemove);
-qboolean	G2API_SetSurfaceOnOff(CGhoul2Info_v &ghoul2, const char *surfaceName, const int flags);
+qboolean	G2API_SetSurfaceOnOff(CGhoul2Info_v &ghoul2, int modelIndex, const char *surfaceName, const int flags);
 int			G2API_GetSurfaceOnOff(CGhoul2Info *ghlInfo, const char *surfaceName);
 qboolean	G2API_SetRootSurface(CGhoul2Info_v &ghoul2, const int modelIndex, const char *surfaceName);
 qboolean	G2API_RemoveSurface(CGhoul2Info *ghlInfo, const int index);
@@ -146,8 +143,9 @@ int			G2API_GetSurfaceIndex(CGhoul2Info *ghlInfo, const char *surfaceName);
 char		*G2API_GetSurfaceName(CGhoul2Info *ghlInfo, int surfNumber);
 char		*G2API_GetGLAName(CGhoul2Info_v &ghoul2, int modelIndex);
 qboolean	G2API_SetBoneAnglesMatrix(CGhoul2Info *ghlInfo, const char *boneName, const mdxaBone_t &matrix, const int flags, qhandle_t *modelList, int blendTime = 0, int currentTime = 0);
-qboolean	G2API_SetNewOrigin(CGhoul2Info_v &ghoul2, const int boltIndex);
+qboolean	G2API_SetNewOrigin(CGhoul2Info_v &ghoul2, const int modelIndex, const int boltIndex);
 int			G2API_GetBoneIndex(CGhoul2Info *ghlInfo, const char *boneName);
+int			G2API_GetBoltIndex(CGhoul2Info *ghlInfo, const int modelIndex);
 qboolean	G2API_StopBoneAnglesIndex(CGhoul2Info *ghlInfo, const int index);
 qboolean	G2API_StopBoneAnimIndex(CGhoul2Info *ghlInfo, const int index);
 qboolean	G2API_SetBoneAnglesIndex( CGhoul2Info *ghlInfo, const int index, const vec3_t angles, const int flags, const Eorientations yaw, const Eorientations pitch, const Eorientations roll, qhandle_t *modelList, int blendTime, int currentTime );
@@ -160,7 +158,7 @@ void		G2API_LoadSaveCodeDestructGhoul2Info(CGhoul2Info_v &ghoul2);
 void		G2API_FreeSaveBuffer(char *buffer);
 char		*G2API_GetAnimFileNameIndex(qhandle_t modelIndex);
 int			G2API_GetSurfaceRenderStatus(CGhoul2Info *ghlInfo, const char *surfaceName);
-void		G2API_CopySpecificG2Model(CGhoul2Info_v &ghoul2From, int modelFrom, CGhoul2Info_v &ghoul2To, int modelTo);
+int			G2API_CopySpecificG2Model(CGhoul2Info_v &ghoul2From, int modelFrom, CGhoul2Info_v &ghoul2To, int modelTo);
 void		G2API_DuplicateGhoul2Instance(CGhoul2Info_v &g2From, CGhoul2Info_v **g2To);
 void		G2API_SetBoltInfo(CGhoul2Info_v &ghoul2, int modelIndex, int boltInfo);
 
@@ -196,10 +194,11 @@ void		G2_ConstructGhoulSkeleton( CGhoul2Info_v &ghoul2,const int frameNum,bool c
 qboolean	G2API_SkinlessModel(CGhoul2Info *g2);
 
 #ifdef _G2_GORE
+void		G2API_InitGore(void);
 int			G2API_GetNumGoreMarks(CGhoul2Info *g2);
 void		G2API_AddSkinGore(CGhoul2Info_v &ghoul2,SSkinGoreData &gore);
 void		G2API_ClearSkinGore ( CGhoul2Info_v &ghoul2 );
-#endif // _SOF2
+#endif // _G2_GORE
 
 int			G2API_Ghoul2Size ( CGhoul2Info_v &ghoul2 );
 void		RemoveBoneCache( CBoneCache *boneCache );
diff --git a/codemp/rd-vanilla/G2_misc.cpp b/codemp/rd-vanilla/G2_misc.cpp
index b28a72d..4d126ff 100644
--- a/codemp/rd-vanilla/G2_misc.cpp
+++ b/codemp/rd-vanilla/G2_misc.cpp
@@ -175,7 +175,7 @@ CGoreSet::~CGoreSet()
 		DeleteGoreRecord((*i).second.mGoreTag);
 	}
 };
-#endif // _SOF2
+#endif // _G2_GORE
 
 const mdxaBone_t &EvalBoneCache(int index,CBoneCache *boneCache);
 
@@ -785,7 +785,6 @@ static int GoreTouch=1;
 static int GoreIndecies[MAX_GORE_INDECIES];
 
 #define GORE_MARGIN (0.0f)
-int	G2API_GetTime(int argTime);
 
 // now we at poly level, check each model space transformed poly against the model world transfomed ray
 void G2_GorePolys( const mdxmSurface_t *surface, CTraceSurface &TS, const mdxmSurfHierarchy_t *surfInfo)
@@ -963,20 +962,19 @@ void G2_GorePolys( const mdxmSurface_t *surface, CTraceSurface &TS, const mdxmSu
 		add.mDeleteTime=0;
 		if (TS.gore->lifeTime)
 		{
-			add.mDeleteTime=G2API_GetTime(0) + TS.gore->lifeTime;
+			add.mDeleteTime= TS.gore->lifeTime;
 		}
 		add.mFadeTime = TS.gore->fadeOutTime;
-		add.mFadeRGB = !!(TS.gore->fadeRGB);
 		add.mGoreTag = newTag;
 
-		add.mGoreGrowStartTime=G2API_GetTime(0);
+		add.mGoreGrowStartTime=0;
 		if( TS.gore->growDuration == -1)
 		{
 			add.mGoreGrowEndTime = -1;    // set this to -1 to disable growing
 		}
 		else
 		{
-			add.mGoreGrowEndTime = G2API_GetTime(0) + TS.gore->growDuration;
+			add.mGoreGrowEndTime = TS.gore->growDuration;
 		}
 
 		assert(TS.gore->growDuration != 0);
diff --git a/codemp/rd-vanilla/rd-vanilla.vcxproj b/codemp/rd-vanilla/rd-vanilla.vcxproj
index e63e30d..4dd502f 100644
--- a/codemp/rd-vanilla/rd-vanilla.vcxproj
+++ b/codemp/rd-vanilla/rd-vanilla.vcxproj
@@ -1,5 +1,5 @@
 ï»¿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug|Win32">
       <Configuration>Debug</Configuration>
@@ -13,18 +13,21 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{518BD884-C233-4B86-ACEA-79534A3CEC01}</ProjectGuid>
     <RootNamespace>rd-vanilla</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>NotSet</CharacterSet>
+    <PlatformToolset>v141</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v141</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
@@ -37,7 +40,7 @@
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <OutDir>../../build/</OutDir>
+    <OutDir>../../build/$(Configuration)/</OutDir>
     <IntDir>..\.build\$(Configuration)\$(Platform)\$(ProjectName)\</IntDir>
     <LibraryPath>$(ProjectDir)\..\libs\win32;$(DXSDK_DIR)\Lib\x86;$(LibraryPath)</LibraryPath>
     <TargetName>$(ProjectName)_$(PlatformShortName)</TargetName>
diff --git a/codemp/rd-vanilla/tr_WorldEffects.cpp b/codemp/rd-vanilla/tr_WorldEffects.cpp
index dc13240..d9a5fb0 100644
--- a/codemp/rd-vanilla/tr_WorldEffects.cpp
+++ b/codemp/rd-vanilla/tr_WorldEffects.cpp
@@ -1383,7 +1383,7 @@ void RB_RenderWorldEffects(void)
 {
 	if (!tr.world || 
 		(tr.refdef.rdflags & RDF_NOWORLDMODEL) || 
-		(backEnd.refdef.rdflags & RDF_SKYBOXPORTAL) || 
+		//(backEnd.refdef.rdflags & RDF_SKYBOXPORTAL) || 
 		!mParticleClouds.size()) 
 	{	//  no world rendering or no world or no particle clouds
 		return;
@@ -1849,25 +1849,6 @@ void RE_WorldEffectCommand(const char *command)
 
 
 
-float R_GetChanceOfSaberFizz()
-{
- 	float	chance = 0.0f;
-	int		numWater = 0;
-	for (int i=0; i<mParticleClouds.size(); i++)
-	{
-		if (mParticleClouds[i].mWaterParticles)
-		{
-			chance += (mParticleClouds[i].mGravity/20000.0f);
-			numWater ++;
-		}
-	}
-	if (numWater)
-	{
-		return (chance / numWater);
-	}
-	return 0.0f;
-}
-
 bool R_IsRaining()
 {
 	return !mParticleClouds.empty();
diff --git a/codemp/rd-vanilla/tr_backend.cpp b/codemp/rd-vanilla/tr_backend.cpp
index 3639a50..ee50f81 100644
--- a/codemp/rd-vanilla/tr_backend.cpp
+++ b/codemp/rd-vanilla/tr_backend.cpp
@@ -408,28 +408,6 @@ void GL_State( unsigned long stateBits )
 
 
 
-/*
-================
-RB_Hyperspace
-
-A player has predicted a teleport, but hasn't arrived yet
-================
-*/
-static void RB_Hyperspace( void ) {
-	float		c;
-
-	if ( !backEnd.isHyperspace ) {
-		// do initialization shit
-	}
-
-	c = ( backEnd.refdef.time & 255 ) / 255.0f;
-	qglClearColor( c, c, c, 1 );
-	qglClear( GL_COLOR_BUFFER_BIT );
-
-	backEnd.isHyperspace = qtrue;
-}
-
-
 void SetViewportAndScissor( void ) {
 	qglMatrixMode(GL_PROJECTION);
 	qglLoadMatrixf( backEnd.viewParms.projectionMatrix );
@@ -481,7 +459,7 @@ void RB_BeginDrawingView (void) {
 		tr_stencilled = false;
 	}
 
-	if (skyboxportal)
+	/*if (skyboxportal)
 	{
 		if ( backEnd.refdef.rdflags & RDF_SKYBOXPORTAL )
 		{	// portal scene, clear whatever is necessary
@@ -495,7 +473,7 @@ void RB_BeginDrawingView (void) {
 		}
 	}
 	else
-	{
+	{*/
 		if ( r_fastsky->integer && !( backEnd.refdef.rdflags & RDF_NOWORLDMODEL ) && !g_bRenderGlowingObjects )
 		{
 			clearBits |= GL_COLOR_BUFFER_BIT;	// FIXME: only if sky shaders have been used
@@ -505,9 +483,9 @@ void RB_BeginDrawingView (void) {
 			qglClearColor( 0.0f, 0.0f, 0.0f, 1.0f );	// FIXME: get color of sky
 #endif
 		}
-	}
+	//}
 
-	if ( tr.refdef.rdflags & RDF_AUTOMAP || (!( backEnd.refdef.rdflags & RDF_NOWORLDMODEL ) && r_DynamicGlow->integer && !g_bRenderGlowingObjects ) )
+	if (/* tr.refdef.rdflags & RDF_AUTOMAP ||*/ (!( backEnd.refdef.rdflags & RDF_NOWORLDMODEL ) && r_DynamicGlow->integer && !g_bRenderGlowingObjects ) )
 	{
 		if (tr.world && tr.world->globalFog != -1)
 		{ //this is because of a bug in multiple scenes I think, it needs to clear for the second scene but it doesn't normally.
@@ -530,16 +508,6 @@ void RB_BeginDrawingView (void) {
 		qglClear( clearBits );
 	}
 
-	if ( ( backEnd.refdef.rdflags & RDF_HYPERSPACE ) )
-	{
-		RB_Hyperspace();
-		return;
-	}
-	else
-	{
-		backEnd.isHyperspace = qfalse;
-	}
-
 	glState.faceCulling = -1;		// force face culling to set next time
 
 	// we will only draw a sun if there was sky rendered in this view
@@ -688,7 +656,6 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 	drawSurf_t		*drawSurf;
 	unsigned int	oldSort;
 	float			originalTime;
-	trRefEntity_t	*curEnt;
 	postRender_t	*pRender;
 	bool			didShadowPass = false;
 #ifdef __MACOS__
@@ -750,7 +717,7 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 		// change the tess parameters if needed
 		// a "entityMergable" shader is a shader that can have surfaces from seperate
 		// entities merged into a single batch, like smoke and blood puff sprites
-		if (entityNum != TR_WORLDENT &&
+		/*if (entityNum != TR_WORLDENT &&
 			g_numPostRenders < MAX_POST_RENDERS)
 		{
 			if ( (backEnd.refdef.entities[entityNum].e.renderfx & RF_DISTORTION) ||
@@ -785,7 +752,7 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 				pRender->drawSurf = drawSurf;
 				pRender->dlighted = dlighted;
 				pRender->fogNum = fogNum;
-				pRender->shader = shader;
+				pRender->shader = shader;*/
 
 				/*
 				if (shader == tr.distortionShader)
@@ -794,7 +761,7 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 				}
 				else
 				*/
-				{
+				/*{
 					pRender->eValid = qtrue;
 				}
 
@@ -809,7 +776,7 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 				//continue without bothering to begin a draw surf
 				continue;
 			}
-		}
+		}*/
 		/*
 		else if (shader == tr.distortionShader &&
 			g_numPostRenders < MAX_POST_RENDERS)
@@ -902,11 +869,11 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 #endif
 				}
 
-				if ( backEnd.currentEntity->e.renderfx & RF_NODEPTH ) {
+				/*if ( backEnd.currentEntity->e.renderfx & RF_NODEPTH ) {
 					// No depth at all, very rare but some things for seeing through walls
 					depthRange = 2;
 				}
-				else if ( backEnd.currentEntity->e.renderfx & RF_DEPTHHACK ) {
+				else */if ( backEnd.currentEntity->e.renderfx & RF_DEPTHHACK ) {
 					// hack the depth range to prevent view model from poking into walls
 					depthRange = 1;
 				}
@@ -1004,8 +971,7 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 #endif
 			}
 			else
-			*/
-			{ //ent
+			{*/ //ent
 				backEnd.currentEntity = &backEnd.refdef.entities[pRender->entNum];
 
 				backEnd.refdef.floatTime = originalTime - backEnd.currentEntity->e.shaderTime;
@@ -1024,7 +990,7 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 					R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.ori );
 #endif
 				}
-			}
+			//}
 
 			qglLoadMatrixf( backEnd.ori.modelMatrix );
 
@@ -1112,7 +1078,7 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 				}
 				lastPostEnt = ENTITYNUM_NONE;
 			}
-			*/
+
 			if (!pRender->eValid)
 			{
 			}
@@ -1177,7 +1143,7 @@ void RB_RenderDrawSurfList( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 
 					lastPostEnt = pRender->entNum;
 				}
-			}
+			}*/
 
 			rb_surfaceTable[ *pRender->drawSurf->surface ]( pRender->drawSurf->surface );
 			RB_EndSurface();
@@ -1239,7 +1205,8 @@ void	RB_SetGL2D (void) {
 	qglScissor( 0, 0, glConfig.vidWidth, glConfig.vidHeight );
 	qglMatrixMode(GL_PROJECTION);
     qglLoadIdentity ();
-	qglOrtho (0, 640, 480, 0, 0, 1);
+	//qglOrtho (0, 640, 480, 0, 0, 1);
+	qglOrtho (0, glConfig.vidWidth, glConfig.vidHeight, 0, 0, 1 );
 	qglMatrixMode(GL_MODELVIEW);
     qglLoadIdentity ();
 
@@ -1382,10 +1349,6 @@ const void *RB_StretchPic ( const void *data ) {
 
 	cmd = (const stretchPicCommand_t *)data;
 
-	if ( !backEnd.projection2D ) {
-		RB_SetGL2D();
-	}
-
 	shader = cmd->shader;
 	if ( shader != tess.shader ) {
 		if ( tess.numIndexes ) {
@@ -1395,6 +1358,10 @@ const void *RB_StretchPic ( const void *data ) {
 		RB_BeginSurface( shader, 0 );
 	}
 
+	if ( !backEnd.projection2D ) {
+		RB_SetGL2D();
+	}
+
 	RB_CHECKOVERFLOW( 4, 6 );
 	numVerts = tess.numVertexes;
 	numIndexes = tess.numIndexes;
@@ -1592,7 +1559,7 @@ const void	*RB_DrawSurfs( const void *data ) {
 		qglDisable( GL_TEXTURE_2D );
 		qglEnable( GL_TEXTURE_RECTANGLE_EXT ); 
 		qglBindTexture( GL_TEXTURE_RECTANGLE_EXT, tr.sceneImage ); 
-		qglCopyTexSubImage2D( GL_TEXTURE_RECTANGLE_EXT, 0, 0, 0, 0, 0, glConfig.vidWidth, glConfig.vidHeight ); 
+		qglCopyTexSubImage2D( GL_TEXTURE_RECTANGLE_EXT, 0, 0, 0, backEnd.viewParms.viewportX, backEnd.viewParms.viewportY, backEnd.viewParms.viewportWidth, backEnd.viewParms.viewportHeight );
 		qglDisable( GL_TEXTURE_RECTANGLE_EXT );
 		qglEnable( GL_TEXTURE_2D );    
 
@@ -1611,7 +1578,7 @@ const void	*RB_DrawSurfs( const void *data ) {
 		qglDisable( GL_TEXTURE_2D );
 		qglEnable( GL_TEXTURE_RECTANGLE_EXT ); 
 		qglBindTexture( GL_TEXTURE_RECTANGLE_EXT, tr.screenGlow ); 
-		qglCopyTexSubImage2D( GL_TEXTURE_RECTANGLE_EXT, 0, 0, 0, 0, 0, glConfig.vidWidth, glConfig.vidHeight ); 
+		qglCopyTexSubImage2D( GL_TEXTURE_RECTANGLE_EXT, 0, 0, 0, backEnd.viewParms.viewportX, backEnd.viewParms.viewportY, backEnd.viewParms.viewportWidth, backEnd.viewParms.viewportHeight );
 		qglDisable( GL_TEXTURE_RECTANGLE_EXT );
 		qglEnable( GL_TEXTURE_2D );
 		
diff --git a/codemp/rd-vanilla/tr_bsp.cpp b/codemp/rd-vanilla/tr_bsp.cpp
index b1dc28a..7906eff 100644
--- a/codemp/rd-vanilla/tr_bsp.cpp
+++ b/codemp/rd-vanilla/tr_bsp.cpp
@@ -2012,7 +2012,7 @@ void RE_LoadWorldMap_Actual( const char *name, world_t &worldData, int index )
 
 	if (!index)
 	{
-		skyboxportal = 0;
+		//skyboxportal = 0;
 
 		// set default sun direction to be used if it isn't
 		// overridden by a shader
diff --git a/codemp/rd-vanilla/tr_font.cpp b/codemp/rd-vanilla/tr_font.cpp
index 96dbb5f..ff9e699 100644
--- a/codemp/rd-vanilla/tr_font.cpp
+++ b/codemp/rd-vanilla/tr_font.cpp
@@ -6,194 +6,29 @@
 #include "tr_local.h"
 #include "tr_font.h"
 
-#include "qcommon/stringed_ingame.h"
-
 /////////////////////////////////////////////////////////////////////////////////////////////////////////
 //
 // This file is shared in the single and multiplayer codebases, so be CAREFUL WHAT YOU ADD/CHANGE!!!!!
 //
 /////////////////////////////////////////////////////////////////////////////////////////////////////////
 
-typedef enum
-{
-	eWestern,	// ( I only care about asian languages in here at the moment )
-	eRussian,	//  .. but now I need to care about this, since it uses a different TP
-	ePolish,	// ditto
-	eKorean,
-	eTaiwanese,	// 15x15 glyphs tucked against BR of 16x16 space
-	eJapanese,	// 15x15 glyphs tucked against TL of 16x16 space
-	eChinese,	// 15x15 glyphs tucked against TL of 16x16 space
-	eThai,		// 16x16 cells with glyphs against left edge, special file (tha_widths.dat) for variable widths
-} Language_e;
-
-// this is to cut down on all the stupid string compares I've been doing, and convert asian stuff to switch-case
-//
-Language_e GetLanguageEnum()
-{
-	static int			iSE_Language_ModificationCount = -1234;	// any old silly value that won't match the cvar mod count
-	static Language_e	eLanguage = eWestern;
-
-	// only re-strcmp() when language string has changed from what we knew it as...
-	//
-	if (iSE_Language_ModificationCount != se_language->modificationCount )
-	{
-		iSE_Language_ModificationCount  = se_language->modificationCount;
-
-				if ( Language_IsRussian()	)	eLanguage = eRussian;
-		else	if ( Language_IsPolish()	)	eLanguage = ePolish;
-		else	if ( Language_IsKorean()	)	eLanguage = eKorean;
-		else	if ( Language_IsTaiwanese()	)	eLanguage = eTaiwanese;
-		else	if ( Language_IsJapanese()	)	eLanguage = eJapanese;
-		else	if ( Language_IsChinese()	)	eLanguage = eChinese;
-		else	if ( Language_IsThai()		)	eLanguage = eThai;
-		else	eLanguage = eWestern;
-	}
-
-	return eLanguage;
-}
-
-struct SBCSOverrideLanguages_t
-{
-	LPCSTR		m_psName;
-	Language_e	m_eLanguage;
-};
-
-// so I can do some stuff with for-next loops when I add polish etc...
-//
-SBCSOverrideLanguages_t g_SBCSOverrideLanguages[]=
-{
-	{"russian",	eRussian},
-	{"polish",	ePolish},
-	{NULL,		eWestern}
-};
-
 
 
 //================================================
 //
 
-#define sFILENAME_THAI_WIDTHS	"fonts/tha_widths.dat"
-#define sFILENAME_THAI_CODES	"fonts/tha_codes.dat"
-
-struct ThaiCodes_t
-{
-	map <int, int>	m_mapValidCodes;
-	vector<int>		m_viGlyphWidths;	
-	string			m_strInitFailureReason;	// so we don't have to keep retrying to work this out
-
-	void Clear( void )
-	{
-		m_mapValidCodes.clear();
-		m_viGlyphWidths.clear();		
-		m_strInitFailureReason = "";	// if blank, never failed, else says don't bother re-trying
-	}
-
-	ThaiCodes_t()
-	{
-		Clear();
-	}
-
-	// convert a supplied 1,2 or 3-byte multiplied-up integer into a valid 0..n index, else -1...
-	//
-	int GetValidIndex( int iCode )
-	{
-		map <int,int>::iterator it = m_mapValidCodes.find( iCode );
-		if (it != m_mapValidCodes.end())
-		{
-            return (*it).second;
-		}
-
-		return -1;
-	}
-
-	int GetWidth( int iGlyphIndex )
-	{
-		if (iGlyphIndex < m_viGlyphWidths.size())
-		{
-			return m_viGlyphWidths[ iGlyphIndex ];
-		}
-
-		assert(0);
-		return 0;
-	}
-
-	// return is error message to display, or NULL for success
-	const char *Init(void)
-	{
-		if (m_mapValidCodes.empty() && m_viGlyphWidths.empty())
-		{
-			if (m_strInitFailureReason.empty())	// never tried and failed already?
-			{
-				int *piData = NULL;	// note <int>, not <byte>, for []-access
-				//
-				// read the valid-codes table in...
-				//
-				int iBytesRead = ri.FS_ReadFile( sFILENAME_THAI_CODES, (void **) &piData );
-				if (iBytesRead > 0 && !(iBytesRead&3))	// valid length and multiple of 4 bytes long
-				{
-					int iTableEntries = iBytesRead / sizeof(int);
-					
-					for (int i=0; i < iTableEntries; i++)
-					{
-						m_mapValidCodes[ piData[i] ] = i;	// convert MBCS code to sequential index...
-					}
-					ri.FS_FreeFile( piData );	// dispose of original
-
-					// now read in the widths... (I'll keep these in a simple STL vector, so they'all disappear when the <map> entries do...
-					//		
-					iBytesRead = ri.FS_ReadFile( sFILENAME_THAI_WIDTHS, (void **) &piData );
-					if (iBytesRead > 0 && !(iBytesRead&3) && iBytesRead>>2/*sizeof(int)*/ == iTableEntries)
-					{
-						for (int i=0; i<iTableEntries; i++)
-						{
-							m_viGlyphWidths.push_back( piData[i] );
-						}
-						ri.FS_FreeFile( piData );	// dispose of original
-					}
-					else
-					{
-						m_strInitFailureReason = va("Error with file \"%s\", size = %d!\n", sFILENAME_THAI_WIDTHS, iBytesRead);
-					}
-				}
-				else
-				{
-					m_strInitFailureReason = va("Error with file \"%s\", size = %d!\n", sFILENAME_THAI_CODES, iBytesRead);
-				}
-			}
-		}
-
-		return m_strInitFailureReason.c_str();
-	}
-};
-
-
-#define GLYPH_MAX_KOREAN_SHADERS	3
-#define GLYPH_MAX_TAIWANESE_SHADERS 4
-#define GLYPH_MAX_JAPANESE_SHADERS	3
-#define GLYPH_MAX_CHINESE_SHADERS	3
-#define GLYPH_MAX_THAI_SHADERS		3
-#define GLYPH_MAX_ASIAN_SHADERS		4	// this MUST equal the larger of the above defines
-
 class CFontInfo
 {
 private:
 	// From the fontdat file
 	glyphInfo_t		mGlyphs[GLYPH_COUNT];
 
-//	int				mAsianHack;				// unused junk from John's fontdat file format.
 	// end of fontdat data
 
 	int				mShader;   				// handle to the shader with the glyph
 	
-	int				m_hAsianShaders[GLYPH_MAX_ASIAN_SHADERS];	// shaders for Korean glyphs where applicable		
-	glyphInfo_t		m_AsianGlyph;			// special glyph containing asian->western scaling info for all glyphs
-	int				m_iAsianGlyphsAcross;	// needed to dynamically calculate S,T coords
-	int				m_iAsianPagesLoaded;
-	bool			m_bAsianLastPageHalfHeight;
 	int				m_iLanguageModificationCount;	// doesn't matter what this is, so long as it's comparable as being changed
 
-	ThaiCodes_t		*m_pThaiData;
-
 public:
 	char			m_sFontName[MAX_QPATH];	// eg "fonts/lcd"	// needed for korean font-hint if we need >1 hangul set
 	int				mPointSize;
@@ -201,12 +36,7 @@ public:
 	int				mAscender;
 	int				mDescender;
 
-	bool			mbRoundCalcs;	// trying to make this !@#$%^ thing work with scaling
 	int				m_iThisFont;	// handle to itself
-	int				m_iAltSBCSFont;	// -1 == NULL // alternative single-byte font for languages like russian/polish etc that need to override high characters ?
-	int				m_iOriginalFontWhenSBCSOverriden;
-	float			m_fAltSBCSFontScaleFactor;	// -1, else amount to adjust returned values by to make them fit the master western font they're substituting for
-	bool			m_bIsFakeAlienLanguage;	// ... if true, don't process as MBCS or override as SBCS etc
 
 	CFontInfo(const char *fontName);
 //	CFontInfo(int fill) { memset(this, fill, sizeof(*this)); }	// wtf?
@@ -218,16 +48,10 @@ public:
 	const int GetDescender(void) const { return(mDescender); }
 
 	const glyphInfo_t *GetLetter(const unsigned int uiLetter, int *piShader = NULL);
-	const int GetCollapsedAsianCode(ulong uiLetter) const;
 
 	const int GetLetterWidth(const unsigned int uiLetter);
 	const int GetLetterHorizAdvance(const unsigned int uiLetter);
 	const int GetShader(void) const { return(mShader); }
-
-	void FlagNoAsianGlyphs(void) { m_hAsianShaders[0] = 0; m_iLanguageModificationCount = -1; }	// used during constructor
-	bool AsianGlyphsAvailable(void) const { return !!(m_hAsianShaders[0]); }
-
-	void UpdateAsianIfNeeded( bool bForceReEval = false);	
 };
 
 //================================================
@@ -235,419 +59,12 @@ public:
 
 
 
-// round float to one decimal place...
-//
-float RoundTenth( float fValue )
-{
-	return ( floorf( (fValue*10.0f) + 0.5f) ) / 10.0f;
-}
-
-
 int							g_iCurrentFontIndex;	// entry 0 is reserved index for missing/invalid, else ++ with each new font registered
 vector<CFontInfo *>			g_vFontArray;
 typedef map<sstring_t, int>	FontIndexMap_t;
 							FontIndexMap_t g_mapFontIndexes;
-int g_iNonScaledCharRange;	// this is used with auto-scaling of asian fonts, anything below this number is preserved in scale, anything above is scaled down by 0.75f
-
 //paletteRGBA_c				lastcolour;
 
-// =============================== some korean stuff =======================================
-
-#define KSC5601_HANGUL_HIBYTE_START		0xB0	// range is...
-#define KSC5601_HANGUL_HIBYTE_STOP		0xC8	// ... inclusive
-#define KSC5601_HANGUL_LOBYTE_LOBOUND	0xA0	// range is...
-#define KSC5601_HANGUL_LOBYTE_HIBOUND	0xFF	// ...bounding (ie only valid in between these points, but NULLs in charsets for these codes)
-#define KSC5601_HANGUL_CODES_PER_ROW	96		// 2 more than the number of glyphs
-
-extern qboolean Language_IsKorean( void );
-
-static inline bool Korean_ValidKSC5601Hangul( byte _iHi, byte _iLo )
-{
-	return (_iHi >=KSC5601_HANGUL_HIBYTE_START		&&
-			_iHi <=KSC5601_HANGUL_HIBYTE_STOP		&&
-			_iLo > KSC5601_HANGUL_LOBYTE_LOBOUND	&&
-			_iLo < KSC5601_HANGUL_LOBYTE_HIBOUND
-			);
-}
-
-static inline bool Korean_ValidKSC5601Hangul( unsigned int uiCode )
-{
-	return Korean_ValidKSC5601Hangul( uiCode >> 8, uiCode & 0xFF );
-}
-
-
-// takes a KSC5601 double-byte hangul code and collapses down to a 0..n glyph index...
-// Assumes rows are 96 wide (glyph slots), not 94 wide (actual glyphs), so I can ignore boundary markers
-//
-// (invalid hangul codes will return 0)
-//
-static int Korean_CollapseKSC5601HangulCode(unsigned int uiCode)
-{
-	if (Korean_ValidKSC5601Hangul( uiCode ))
-	{
-		uiCode -= (KSC5601_HANGUL_HIBYTE_START * 256) + KSC5601_HANGUL_LOBYTE_LOBOUND;	// sneaky maths on both bytes, reduce to 0x0000 onwards
-		uiCode  = ((uiCode >> 8) * KSC5601_HANGUL_CODES_PER_ROW) + (uiCode & 0xFF);
-		return uiCode;
-	}
-	return 0;
-}
-
-static int Korean_InitFields(int &iGlyphTPs, LPCSTR &psLang)
-{
-	psLang		= "kor";
-	iGlyphTPs	= GLYPH_MAX_KOREAN_SHADERS;
-	g_iNonScaledCharRange = 255;
-	return 32;	// m_iAsianGlyphsAcross
-}
-
-// ======================== some taiwanese stuff ==============================
-
-// (all ranges inclusive for Big5)...
-//
-#define BIG5_HIBYTE_START0		0xA1	// (misc chars + level 1 hanzi)
-#define BIG5_HIBYTE_STOP0		0xC6	// 
-#define BIG5_HIBYTE_START1		0xC9	// (level 2 hanzi)
-#define BIG5_HIBYTE_STOP1		0xF9	// 
-#define BIG5_LOBYTE_LOBOUND0	0x40	// 
-#define BIG5_LOBYTE_HIBOUND0	0x7E	// 
-#define BIG5_LOBYTE_LOBOUND1	0xA1	// 
-#define BIG5_LOBYTE_HIBOUND1	0xFE	// 
-#define BIG5_CODES_PER_ROW		160		// 3 more than the number of glyphs
-
-extern qboolean Language_IsTaiwanese( void );
-
-static bool Taiwanese_ValidBig5Code( unsigned int uiCode )
-{
-	const byte _iHi = (uiCode >> 8)&0xFF;
-	if (	(_iHi >= BIG5_HIBYTE_START0 && _iHi <= BIG5_HIBYTE_STOP0)
-		||	(_iHi >= BIG5_HIBYTE_START1 && _iHi <= BIG5_HIBYTE_STOP1)
-		)
-	{
-		const byte _iLo = uiCode & 0xFF;
-
-		if ( (_iLo >= BIG5_LOBYTE_LOBOUND0 && _iLo <= BIG5_LOBYTE_HIBOUND0) ||
-			 (_iLo >= BIG5_LOBYTE_LOBOUND1 && _iLo <= BIG5_LOBYTE_HIBOUND1)
-			)
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-
-// only call this when Taiwanese_ValidBig5Code() has already returned true...
-//
-static bool Taiwanese_IsTrailingPunctuation( unsigned int uiCode )
-{
-	// so far I'm just counting the first 21 chars, those seem to be all the basic punctuation...
-	//
-	if (	uiCode >= ((BIG5_HIBYTE_START0<<8)|BIG5_LOBYTE_LOBOUND0) && 
-			uiCode <  ((BIG5_HIBYTE_START0<<8)|BIG5_LOBYTE_LOBOUND0+20)
-		)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-
-// takes a BIG5 double-byte code (including level 2 hanzi) and collapses down to a 0..n glyph index...
-// Assumes rows are 160 wide (glyph slots), not 157 wide (actual glyphs), so I can ignore boundary markers
-//
-// (invalid big5 codes will return 0)
-//
-static int Taiwanese_CollapseBig5Code( unsigned int uiCode )
-{
-	if (Taiwanese_ValidBig5Code( uiCode ))
-	{			
-		uiCode -= (BIG5_HIBYTE_START0 * 256) + BIG5_LOBYTE_LOBOUND0;	// sneaky maths on both bytes, reduce to 0x0000 onwards
-		if ( (uiCode & 0xFF) >= (BIG5_LOBYTE_LOBOUND1-1)-BIG5_LOBYTE_LOBOUND0)
-		{
-			uiCode -= ((BIG5_LOBYTE_LOBOUND1-1) - (BIG5_LOBYTE_HIBOUND0+1)) -1;
-		}
-		uiCode = ((uiCode >> 8) * BIG5_CODES_PER_ROW) + (uiCode & 0xFF);
-		return uiCode;
-	}
-	return 0;
-}
-
-static int Taiwanese_InitFields(int &iGlyphTPs, LPCSTR &psLang)
-{
-	psLang		= "tai";
-	iGlyphTPs	= GLYPH_MAX_TAIWANESE_SHADERS;
-	g_iNonScaledCharRange = 255;
-	return 64;	// m_iAsianGlyphsAcross
-}
-
-// ======================== some Japanese stuff ==============================
-
-
-// ( all ranges inclusive for Shift-JIS )
-//
-#define SHIFTJIS_HIBYTE_START0	0x81
-#define SHIFTJIS_HIBYTE_STOP0	0x9F
-#define SHIFTJIS_HIBYTE_START1	0xE0
-#define SHIFTJIS_HIBYTE_STOP1	0xEF
-//
-#define SHIFTJIS_LOBYTE_START0	0x40
-#define SHIFTJIS_LOBYTE_STOP0	0x7E
-#define SHIFTJIS_LOBYTE_START1	0x80
-#define SHIFTJIS_LOBYTE_STOP1	0xFC
-#define SHIFTJIS_CODES_PER_ROW	(((SHIFTJIS_LOBYTE_STOP0-SHIFTJIS_LOBYTE_START0)+1)+((SHIFTJIS_LOBYTE_STOP1-SHIFTJIS_LOBYTE_START1)+1))
-
-
-extern qboolean Language_IsJapanese( void );
-
-static bool Japanese_ValidShiftJISCode( byte _iHi, byte _iLo )
-{
-	if (	(_iHi >= SHIFTJIS_HIBYTE_START0 && _iHi <= SHIFTJIS_HIBYTE_STOP0)
-		||	(_iHi >= SHIFTJIS_HIBYTE_START1 && _iHi <= SHIFTJIS_HIBYTE_STOP1)
-		)
-	{
-		if ( (_iLo >= SHIFTJIS_LOBYTE_START0 && _iLo <= SHIFTJIS_LOBYTE_STOP0) ||
-			 (_iLo >= SHIFTJIS_LOBYTE_START1 && _iLo <= SHIFTJIS_LOBYTE_STOP1)
-			)
-		{
-			return true;
-		}
-	}
-	
-	return false;
-}
-
-static inline bool Japanese_ValidShiftJISCode( unsigned int uiCode )
-{
-	return Japanese_ValidShiftJISCode( uiCode >> 8, uiCode & 0xFF );
-}
-
-
-// only call this when Japanese_ValidShiftJISCode() has already returned true...
-//
-static bool Japanese_IsTrailingPunctuation( unsigned int uiCode )
-{
-	// so far I'm just counting the first 18 chars, those seem to be all the basic punctuation...
-	//
-	if (	uiCode >= ((SHIFTJIS_HIBYTE_START0<<8)|SHIFTJIS_LOBYTE_START0) && 
-			uiCode <  ((SHIFTJIS_HIBYTE_START0<<8)|SHIFTJIS_LOBYTE_START0+18)
-		)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-
-// takes a ShiftJIS double-byte code and collapse down to a 0..n glyph index...
-//
-// (invalid codes will return 0)
-//
-static int Japanese_CollapseShiftJISCode( unsigned int uiCode )
-{
-	if (Japanese_ValidShiftJISCode( uiCode ))
-	{	
-		uiCode -= ((SHIFTJIS_HIBYTE_START0<<8)|SHIFTJIS_LOBYTE_START0);	// sneaky maths on both bytes, reduce to 0x0000 onwards
-		
-		if ( (uiCode & 0xFF) >= (SHIFTJIS_LOBYTE_START1)-SHIFTJIS_LOBYTE_START0)
-		{
-			uiCode -= ((SHIFTJIS_LOBYTE_START1)-SHIFTJIS_LOBYTE_STOP0)-1;
-		}
-
-		if ( ((uiCode>>8)&0xFF) >= (SHIFTJIS_HIBYTE_START1)-SHIFTJIS_HIBYTE_START0)
-		{
-			uiCode -= (((SHIFTJIS_HIBYTE_START1)-SHIFTJIS_HIBYTE_STOP0)-1) << 8;
-		}
-
-		uiCode = ((uiCode >> 8) * SHIFTJIS_CODES_PER_ROW) + (uiCode & 0xFF);
-
-		return uiCode;
-	}
-	return 0;
-}
-
-
-static int Japanese_InitFields(int &iGlyphTPs, LPCSTR &psLang)
-{
-	psLang		= "jap";
-	iGlyphTPs	= GLYPH_MAX_JAPANESE_SHADERS;
-	g_iNonScaledCharRange = 255;
-	return 64;	// m_iAsianGlyphsAcross
-}
-
-// ======================== some Chinese stuff ==============================
-
-#define GB_HIBYTE_START		0xA1	// range is...       
-#define GB_HIBYTE_STOP		0xF7	// ... inclusive     
-#define GB_LOBYTE_LOBOUND	0xA0	// range is...                                                                                
-#define GB_LOBYTE_HIBOUND	0xFF	// ...bounding (ie only valid in between these points, but NULLs in charsets for these codes) 
-#define GB_CODES_PER_ROW	95		// 1 more than the number of glyphs
-
-extern qboolean Language_IsChinese( void );
-
-static inline bool Chinese_ValidGBCode( byte _iHi, byte _iLo )
-{
-	return (_iHi >=GB_HIBYTE_START		&&
-			_iHi <=GB_HIBYTE_STOP		&&
-			_iLo > GB_LOBYTE_LOBOUND	&&
-			_iLo < GB_LOBYTE_HIBOUND
-			);
-}
-
-static inline bool Chinese_ValidGBCode( unsigned int uiCode)
-{
-	return Chinese_ValidGBCode( uiCode >> 8, uiCode & 0xFF );
-}
-
-
-// only call this when Chinese_ValidGBCode() has already returned true...
-//
-static bool Chinese_IsTrailingPunctuation( unsigned int uiCode )
-{
-	// so far I'm just counting the first 13 chars, those seem to be all the basic punctuation...
-	//
-	if (	uiCode >  ((GB_HIBYTE_START<<8)|GB_LOBYTE_LOBOUND) && 
-			uiCode <  ((GB_HIBYTE_START<<8)|GB_LOBYTE_LOBOUND+14)
-		)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-
-// takes a GB double-byte code and collapses down to a 0..n glyph index...
-// Assumes rows are 96 wide (glyph slots), not 94 wide (actual glyphs), so I can ignore boundary markers
-//
-// (invalid GB codes will return 0)
-//
-static int Chinese_CollapseGBCode( unsigned int uiCode )
-{
-	if (Chinese_ValidGBCode( uiCode ))
-	{			
-		uiCode -= (GB_HIBYTE_START * 256) + GB_LOBYTE_LOBOUND;	// sneaky maths on both bytes, reduce to 0x0000 onwards
-		uiCode  = ((uiCode >> 8) * GB_CODES_PER_ROW) + (uiCode & 0xFF);		
-		return uiCode;
-	}
-
-	return 0;
-}
-
-static int Chinese_InitFields(int &iGlyphTPs, LPCSTR &psLang)
-{
-	psLang		= "chi";
-	iGlyphTPs	= GLYPH_MAX_CHINESE_SHADERS;
-	g_iNonScaledCharRange = 255;
-	return 64;	// m_iAsianGlyphsAcross
-}
-
-// ======================== some Thai stuff ==============================
-
-//TIS 620-2533
-
-#define TIS_GLYPHS_START	160
-#define TIS_SARA_AM			0xD3		// special case letter, both a new letter and a trailing accent for the prev one
-ThaiCodes_t g_ThaiCodes;	// the one and only instance of this object
-
-extern qboolean Language_IsThai( void );
-
-/*
-static int Thai_IsAccentChar( unsigned int uiCode )
-{
-	switch (uiCode)
-	{
-		case 209:		
-		case 212:	case 213:	case 214:	case 215:	case 216:	case 217:	case 218:
-		case 231:	case 232:	case 233:	case 234:	case 235:	case 236:	case 237:	case 238:
-		return true;
-	}
-	
-	return false;
-}
-*/
-
-// returns a valid Thai code (or 0), based on taking 1,2 or 3 bytes from the supplied byte stream
-//	Fills in <iThaiBytes> with 1,2 or 3
-static int Thai_ValidTISCode( const byte *psString, int &iThaiBytes )
-{	
-	// try a 1-byte code first...
-	//
-	if (psString[0] >= 160)	// so western letters drop through and use normal font
-	{
-		// this code is heavily little-endian, so someone else will need to port for Mac etc... (not my problem ;-)
-		//		
-		union CodeToTry_t
-		{
-            char sChars[4];
-			unsigned int uiCode;
-		};
-		
-		CodeToTry_t CodeToTry;
-		CodeToTry.uiCode = 0;	// important that we clear all 4 bytes in sChars here
-
-		// thai codes can be up to 3 bytes long, so see how high we can get...
-		//
-		int i;
-		for (i=0; i<3; i++)
-		{			
-			CodeToTry.sChars[i] = psString[i];
-
-            int iIndex = g_ThaiCodes.GetValidIndex( CodeToTry.uiCode );
-			if (iIndex == -1)
-			{
-				// failed, so return previous-longest code...
-				//
-				CodeToTry.sChars[i] = 0;
-				break;
-			}
-		}
-		iThaiBytes = i;
-		assert(i);	// if 'i' was 0, then this may be an error, trying to get a thai accent as standalone char?
-		return CodeToTry.uiCode;
-	}
-
-	return 0;
-}
-
-// special case, thai can only break on certain letters, and since the rules are complicated then
-//	we tell the translators to put an underscore ('_') between each word even though in Thai they're
-//	all jammed together at final output onscreen...
-//
-static inline bool Thai_IsTrailingPunctuation( unsigned int uiCode )
-{
-	return uiCode == '_';
-}
-
-// takes a TIS 1,2 or 3 byte code and collapse down to a 0..n glyph index...
-//
-// (invalid codes will return 0)
-//
-static int Thai_CollapseTISCode( unsigned int uiCode )
-{
-	if (uiCode >= TIS_GLYPHS_START)	// so western letters drop through as invalid
-	{
-		int iCollapsedIndex = g_ThaiCodes.GetValidIndex( uiCode );
-		if (iCollapsedIndex != -1)
-		{
-			return iCollapsedIndex;
-		}        
-	}
-
-	return 0;
-}
-
-static int Thai_InitFields(int &iGlyphTPs, LPCSTR &psLang)
-{
-	psLang		= "tha";
-	iGlyphTPs	= GLYPH_MAX_THAI_SHADERS;
-	g_iNonScaledCharRange = INT_MAX;	// in other words, don't scale any thai chars down
-	return 32;	// m_iAsianGlyphsAcross
-}
-
-
 // ============================================================================
 
 // takes char *, returns integer char at that point, and advances char * on by enough bytes to move
@@ -662,104 +79,6 @@ unsigned int AnyLanguage_ReadCharFromString( const char *psText, int *piAdvanceC
 	const byte *psString = (const byte *) psText;	// avoid sign-promote bug
 	unsigned int uiLetter;
 
-	switch ( GetLanguageEnum() )
-	{
-		case eKorean:
-		{
-			if ( Korean_ValidKSC5601Hangul( psString[0], psString[1] ))
-			{
-				uiLetter = (psString[0] * 256) + psString[1];
-				*piAdvanceCount = 2;
-
-				// not going to bother testing for korean punctuation here, since korean already 
-				//	uses spaces, and I don't have the punctuation glyphs defined, only the basic 2350 hanguls
-				//
-				if ( pbIsTrailingPunctuation)
-				{
-					*pbIsTrailingPunctuation = qfalse;
-				}
-
-				return uiLetter;
-			}
-		}
-		break;
-
-		case eTaiwanese:
-		{
-			if ( Taiwanese_ValidBig5Code( (psString[0] * 256) + psString[1] ))
-			{
-				uiLetter = (psString[0] * 256) + psString[1];
-				*piAdvanceCount = 2;
-
-				// need to ask if this is a trailing (ie like a comma or full-stop) punctuation?...
-				//
-				if ( pbIsTrailingPunctuation)
-				{
-					*pbIsTrailingPunctuation = Taiwanese_IsTrailingPunctuation( uiLetter ) ? qtrue : qfalse;
-				}
-	
-				return uiLetter;
-			}
-		}
-		break;
-
-		case eJapanese:
-		{
-			if ( Japanese_ValidShiftJISCode( psString[0], psString[1] ))
-			{
-				uiLetter = (psString[0] * 256) + psString[1];
-				*piAdvanceCount = 2;
-	
-				// need to ask if this is a trailing (ie like a comma or full-stop) punctuation?...
-				//
-				if ( pbIsTrailingPunctuation)
-				{
-					*pbIsTrailingPunctuation = Japanese_IsTrailingPunctuation( uiLetter ) ? qtrue : qfalse;
-				}
-
-				return uiLetter;
-			}
-		}
-		break;
-
-		case eChinese:
-		{
-			if ( Chinese_ValidGBCode( (psString[0] * 256) + psString[1] ))
-			{
-				uiLetter = (psString[0] * 256) + psString[1];
-				*piAdvanceCount = 2;
-
-				// need to ask if this is a trailing (ie like a comma or full-stop) punctuation?...
-				//
-				if ( pbIsTrailingPunctuation)
-				{
-					*pbIsTrailingPunctuation = Chinese_IsTrailingPunctuation( uiLetter ) ? qtrue : qfalse;
-				}
-
-				return uiLetter;
-			}
-		}
-		break;
-
-		case eThai:
-		{
-			int iThaiBytes;
-			uiLetter = Thai_ValidTISCode( psString, iThaiBytes );
-			if ( uiLetter )
-			{
-				*piAdvanceCount = iThaiBytes;
-
-				if ( pbIsTrailingPunctuation )
-				{
-					*pbIsTrailingPunctuation = Thai_IsTrailingPunctuation( uiLetter ) ? qtrue : qfalse;
-				}
-
-				return uiLetter;
-			}
-		}
-		break;
-	}
-
 	// ... must not have been an MBCS code...
 	//
 	uiLetter = psString[0];
@@ -780,39 +99,6 @@ unsigned int AnyLanguage_ReadCharFromString( const char *psText, int *piAdvanceC
 }
 
 
-// needed for subtitle printing since original code no longer worked once camera bar height was changed to 480/10
-//	rather than refdef height / 10. I now need to bodge the coords to come out right.
-//
-qboolean Language_IsAsian(void)
-{
-	switch ( GetLanguageEnum() )
-	{
-		case eKorean:
-		case eTaiwanese:
-		case eJapanese:
-		case eChinese:
-		case eThai:	// this is asian, but the query is normally used for scaling
-			return qtrue;
-	}
-
-	return qfalse;
-}
-
-qboolean Language_UsesSpaces(void)
-{
-	// ( korean uses spaces )
-	switch ( GetLanguageEnum() )
-	{
-		case eTaiwanese:	
-		case eJapanese:		
-		case eChinese:		
-		case eThai:			
-			return qfalse;
-	}
-
-	return qtrue;
-}
-
 // ======================================================================
 // name is (eg) "ergo" or "lcd", no extension.
 //
@@ -832,12 +118,7 @@ CFontInfo::CFontInfo(const char *_fontName)
 	
 	// clear some general things...
 	//
-	m_pThaiData = NULL;
-	m_iAltSBCSFont = -1;
 	m_iThisFont = -1;
-	m_iOriginalFontWhenSBCSOverriden = -1;
-	m_fAltSBCSFontScaleFactor = -1;
-	m_bIsFakeAlienLanguage = !strcmp(_fontName,"aurabesh");	// dont try and make SBCS or asian overrides for this
 
 	len = ri.FS_ReadFile(fontName, NULL);
 	if (len == sizeof(dfontdat_t))
@@ -853,8 +134,6 @@ CFontInfo::CFontInfo(const char *_fontName)
 		mHeight = fontdat->mHeight;
 		mAscender = fontdat->mAscender;
 		mDescender = fontdat->mDescender;
-//		mAsianHack = fontdat->mKoreanHack;	// ignore this crap, it's some junk in the fontdat file that no-one uses
-		mbRoundCalcs = !!strstr(fontName,"ergo");
 
 		// cope with bad fontdat headers...
 		//
@@ -877,209 +156,17 @@ CFontInfo::CFontInfo(const char *_fontName)
 	COM_StripExtension( m_sFontName, m_sFontName, sizeof( m_sFontName ) );	// so we get better error printing if failed to load shader (ie lose ".fontdat")
 	mShader = RE_RegisterShaderNoMip(m_sFontName);
 
-	FlagNoAsianGlyphs();
-	UpdateAsianIfNeeded(true);
-
 	// finished...
 	g_vFontArray.resize(g_iCurrentFontIndex + 1);
 	g_vFontArray[g_iCurrentFontIndex++] = this;
-
-
-	if ( ri.Cvar_VariableIntegerValue( "com_buildScript" ) == 2)
-	{
-		Com_Printf( "com_buildScript(2): Registering foreign fonts...\n" );
-		static qboolean bDone = qfalse;	// Do this once only (for speed)...
-		if (!bDone)
-		{
-			bDone = qtrue;
-
-			char sTemp[MAX_QPATH];
-			int iGlyphTPs = 0;
-			const char *psLang = NULL;
-
-			// SBCS override languages...
-			//
-			fileHandle_t f;	
-			for (int i=0; g_SBCSOverrideLanguages[i].m_psName ;i++)
-			{
-				char sTemp[MAX_QPATH];
-
-				sprintf(sTemp,"fonts/%s.tga", g_SBCSOverrideLanguages[i].m_psName );
-				ri.FS_FOpenFileRead( sTemp, &f, qfalse );
-				if (f) ri.FS_FCloseFile( f );
-
-				sprintf(sTemp,"fonts/%s.fontdat", g_SBCSOverrideLanguages[i].m_psName );
-				ri.FS_FOpenFileRead( sTemp, &f, qfalse );
-				if (f) ri.FS_FCloseFile( f );
-			}
-
-			// asian MBCS override languages...
-			//
-			for (int iLang=0; iLang<5; iLang++)
-			{
-				switch (iLang)
-				{
-					case 0:	m_iAsianGlyphsAcross = Korean_InitFields	(iGlyphTPs, psLang);	break;
-					case 1: m_iAsianGlyphsAcross = Taiwanese_InitFields	(iGlyphTPs, psLang);	break;
-					case 2: m_iAsianGlyphsAcross = Japanese_InitFields	(iGlyphTPs, psLang);	break;
-					case 3: m_iAsianGlyphsAcross = Chinese_InitFields	(iGlyphTPs, psLang);	break;
-					case 4: m_iAsianGlyphsAcross = Thai_InitFields		(iGlyphTPs, psLang);	
-					{
-						// additional files needed for Thai language...
-						//						
-						ri.FS_FOpenFileRead( sFILENAME_THAI_WIDTHS , &f, qfalse );
-						if (f) {
-							ri.FS_FCloseFile( f );
-						}
-
-						ri.FS_FOpenFileRead( sFILENAME_THAI_CODES, &f, qfalse );
-						if (f) {
-							ri.FS_FCloseFile( f );
-						}					
-					}
-                    break;
-				}
-
-				for (int i=0; i<iGlyphTPs; i++)
-				{
-					Com_sprintf(sTemp,sizeof(sTemp), "fonts/%s_%d_1024_%d.tga", psLang, 1024/m_iAsianGlyphsAcross, i);
-
-					// RE_RegisterShaderNoMip( sTemp );	// don't actually need to load it, so...					
-					ri.FS_FOpenFileRead( sTemp, &f, qfalse );
-					if (f) {
-						ri.FS_FCloseFile( f );
-					}
-				}
-			}
-		}
-	}
-}
-
-void CFontInfo::UpdateAsianIfNeeded( bool bForceReEval /* = false */ )
-{
-	// if asian language, then provide an alternative glyph set and fill in relevant fields...
-	//
-	if (mHeight && !m_bIsFakeAlienLanguage)	// western charset exists in first place, and isn't alien rubbish?
-	{
-		Language_e eLanguage = GetLanguageEnum();
-
-		if (eLanguage == eKorean || eLanguage == eTaiwanese || eLanguage == eJapanese || eLanguage == eChinese || eLanguage == eThai)
-		{
-			int iCappedHeight = mHeight < 16 ? 16: mHeight;	// arbitrary limit on small char sizes because Asian chars don't squash well
-
-			if (m_iLanguageModificationCount != se_language->modificationCount || !AsianGlyphsAvailable() || bForceReEval)
-			{
-				m_iLanguageModificationCount  = se_language->modificationCount;
-
-				int iGlyphTPs = 0;
-				const char *psLang = NULL;
-
-				switch ( eLanguage )
-				{
-					case eKorean:		m_iAsianGlyphsAcross = Korean_InitFields(iGlyphTPs, psLang);	break;
-					case eTaiwanese:	m_iAsianGlyphsAcross = Taiwanese_InitFields(iGlyphTPs, psLang);	break;
-					case eJapanese:		m_iAsianGlyphsAcross = Japanese_InitFields(iGlyphTPs, psLang);	break;
-					case eChinese:		m_iAsianGlyphsAcross = Chinese_InitFields(iGlyphTPs, psLang);	break;
-					case eThai:
-					{
-						m_iAsianGlyphsAcross = Thai_InitFields(iGlyphTPs, psLang);
-
-						if (!m_pThaiData)
-						{
-							LPCSTR psFailureReason = g_ThaiCodes.Init();
-							if (!psFailureReason[0])
-							{
-								m_pThaiData = &g_ThaiCodes;
-							}
-							else
-							{
-								// failed to load a needed file, reset to English...
-								//
-								ri.Cvar_Set("se_language", "english");
-								Com_Error( ERR_DROP, psFailureReason );
-							}
-						}
-					}
-					break;
-				}
-
-				// textures need loading...
-				//
-				if (m_sFontName[0])
-				{
-					// Use this sometime if we need to do logic to load alternate-height glyphs to better fit other fonts.
-					// (but for now, we just use the one glyph set)
-					//
-				}
-				
-				for (int i = 0; i < iGlyphTPs; i++)
-				{
-					// (Note!!  assumption for S,T calculations: all Asian glyph textures pages are square except for last one)
-					//
-					char sTemp[MAX_QPATH];
-					Com_sprintf(sTemp,sizeof(sTemp), "fonts/%s_%d_1024_%d", psLang, 1024/m_iAsianGlyphsAcross, i);
-					//
-					// returning 0 here will automatically inhibit Asian glyph calculations at runtime...
-					//
-					m_hAsianShaders[i] = RE_RegisterShaderNoMip( sTemp );
-				}
-			
-				// for now I'm hardwiring these, but if we ever have more than one glyph set per language then they'll be changed...
-				//
-				m_iAsianPagesLoaded = iGlyphTPs;	// not necessarily true, but will be safe, and show up obvious if something missing
-				m_bAsianLastPageHalfHeight = true;
-
-				bForceReEval = true;
-			}
-
-			if (bForceReEval)
-			{			
-				// now init the Asian member glyph fields to make them come out the same size as the western ones
-				//	that they serve as an alternative for...
-				//
-				m_AsianGlyph.width			= iCappedHeight;	// square Asian chars same size as height of western set
-				m_AsianGlyph.height			= iCappedHeight;	// ""
-				switch (eLanguage)
-				{
-					default:		m_AsianGlyph.horizAdvance	= iCappedHeight;	break;
-					case eKorean:	m_AsianGlyph.horizAdvance	= iCappedHeight - 1;break;	// korean has a small amount of space at the edge of the glyph
-
-					case eTaiwanese:
-					case eJapanese:
-					case eChinese:	m_AsianGlyph.horizAdvance	= iCappedHeight + 3;	// need to force some spacing for these
-//					case eThai:	// this is done dynamically elsewhere, since Thai glyphs are variable width
-				}
-				m_AsianGlyph.horizOffset	= 0;				// ""
-				m_AsianGlyph.baseline		= mAscender + ((iCappedHeight - mHeight) >> 1);
-			}
-		}
-		else
-		{
-			// not using Asian...
-			//
-			FlagNoAsianGlyphs();
-		}
-	}
-	else
-	{			
-		// no western glyphs available, so don't attempt to match asian...
-		//
-		FlagNoAsianGlyphs();
-	}
 }
 
 static CFontInfo *GetFont_Actual(int index)
 {
 	index &= SET_MASK;
-	if((index >= 1) && (index < g_iCurrentFontIndex))
+	if((index >= 0) && (index < g_iCurrentFontIndex))
 	{
 		CFontInfo *pFont = g_vFontArray[index];
-
-		if (pFont)
-		{
-			pFont->UpdateAsianIfNeeded();
-		}
-
 		return pFont;
 	}
 	return(NULL);
@@ -1091,149 +178,15 @@ static CFontInfo *GetFont_Actual(int index)
 //
 const glyphInfo_t *CFontInfo::GetLetter(const unsigned int uiLetter, int *piShader /* = NULL */)
 { 	
-	if ( AsianGlyphsAvailable() )
-	{
-		int iCollapsedAsianCode = GetCollapsedAsianCode( uiLetter );
-		if (iCollapsedAsianCode)
-		{
-			if (piShader)
-			{
-				// (Note!!  assumption for S,T calculations: all asian glyph textures pages are square except for last one
-				//			which may or may not be half height) - but not for Thai
-				//				
-				int iTexturePageIndex = iCollapsedAsianCode / (m_iAsianGlyphsAcross * m_iAsianGlyphsAcross);
-
-				if (iTexturePageIndex > m_iAsianPagesLoaded)
-				{
-					assert(0);				// should never happen
-					iTexturePageIndex = 0;
-				}
-
-				int iOriginalCollapsedAsianCode = iCollapsedAsianCode;	// need to back this up (if Thai) for later
-				iCollapsedAsianCode -= iTexturePageIndex *  (m_iAsianGlyphsAcross * m_iAsianGlyphsAcross);
-
-				const int iColumn	= iCollapsedAsianCode % m_iAsianGlyphsAcross;
-				const int iRow		= iCollapsedAsianCode / m_iAsianGlyphsAcross;				
-				const bool bHalfT	= (iTexturePageIndex == (m_iAsianPagesLoaded - 1) && m_bAsianLastPageHalfHeight);
-				const int iAsianGlyphsDown = (bHalfT) ? m_iAsianGlyphsAcross / 2 : m_iAsianGlyphsAcross;
-
-				switch ( GetLanguageEnum() )
-				{
-					case eKorean:
-					default:					
-					{
-						m_AsianGlyph.s  = (float)( iColumn    ) / (float)m_iAsianGlyphsAcross;
-						m_AsianGlyph.t  = (float)( iRow       ) / (float)  iAsianGlyphsDown;
-						m_AsianGlyph.s2 = (float)( iColumn + 1) / (float)m_iAsianGlyphsAcross;				
-						m_AsianGlyph.t2 = (float)( iRow + 1   ) / (float)  iAsianGlyphsDown;
-					}
-					break;
-
-					case eTaiwanese:
-					{
-						m_AsianGlyph.s  = (float)(((1024 / m_iAsianGlyphsAcross) * ( iColumn    ))+1) / 1024.0f;
-						m_AsianGlyph.t  = (float)(((1024 / iAsianGlyphsDown    ) * ( iRow       ))+1) / 1024.0f;
-						m_AsianGlyph.s2 = (float)(((1024 / m_iAsianGlyphsAcross) * ( iColumn+1  ))  ) / 1024.0f;
-						m_AsianGlyph.t2 = (float)(((1024 / iAsianGlyphsDown    ) * ( iRow+1     ))  ) / 1024.0f;
-					}
-					break;
-
-					case eJapanese:
-					case eChinese:
-					{
-						m_AsianGlyph.s  = (float)(((1024 / m_iAsianGlyphsAcross) * ( iColumn    ))  ) / 1024.0f;
-						m_AsianGlyph.t  = (float)(((1024 / iAsianGlyphsDown    ) * ( iRow       ))  ) / 1024.0f;
-						m_AsianGlyph.s2 = (float)(((1024 / m_iAsianGlyphsAcross) * ( iColumn+1  ))-1) / 1024.0f;
-						m_AsianGlyph.t2 = (float)(((1024 / iAsianGlyphsDown    ) * ( iRow+1     ))-1) / 1024.0f;
-					}
-					break;
-
-					case eThai:
-					{
-						int iGlyphXpos = (1024 / m_iAsianGlyphsAcross) * ( iColumn );
-						int iGlyphWidth = g_ThaiCodes.GetWidth( iOriginalCollapsedAsianCode );
-
-						// very thai-specific language-code...
-						//
-						if (uiLetter == TIS_SARA_AM)
-						{
-							iGlyphXpos += 9;	// these are pixel coords on the source TP, so don't affect scaled output
-							iGlyphWidth= 20;	//
-						}
-						m_AsianGlyph.s  = (float)(iGlyphXpos) / 1024.0f;
-						m_AsianGlyph.t  = (float)(((1024 / iAsianGlyphsDown    ) * ( iRow       ))  ) / 1024.0f;						
-						// technically this .s2 line should be modified to blit only the correct width, but since
-						//	all Thai glyphs are up against the left edge of their cells and have blank to the cell
-						//	boundary then it's better to keep these calculations simpler...
-						
-						m_AsianGlyph.s2 = (float)(iGlyphXpos+iGlyphWidth) / 1024.0f;
-						m_AsianGlyph.t2 = (float)(((1024 / iAsianGlyphsDown    ) * ( iRow+1     ))-1) / 1024.0f;
-
-						// special addition for Thai, need to bodge up the width and advance fields...
-						//
-                        m_AsianGlyph.width = iGlyphWidth;
-						m_AsianGlyph.horizAdvance = iGlyphWidth + 1;
-					}
-					break;
-				}
-				*piShader = m_hAsianShaders[ iTexturePageIndex ];
-			}
-			return &m_AsianGlyph;
-		}
-	}
-
 	if (piShader)
 	{
 		*piShader = GetShader();
 	}
 
 	const glyphInfo_t *pGlyph = &mGlyphs[ uiLetter & 0xff ];
-	//
-	// SBCS language substitution?...
-	//
-	if ( m_fAltSBCSFontScaleFactor != -1 )
-	{
-		// sod it, use the asian glyph, that's fine...
-		//
-		memcpy(&m_AsianGlyph,pGlyph,sizeof(m_AsianGlyph));	// *before* changin pGlyph!
-
-//		CFontInfo *pOriginalFont = GetFont_Actual( this->m_iOriginalFontWhenSBCSOverriden );
-//		pGlyph = &pOriginalFont->mGlyphs[ uiLetter & 0xff ];		
-
-		#define ASSIGN_WITH_ROUNDING(_dst,_src) _dst = mbRoundCalcs ? Round( m_fAltSBCSFontScaleFactor * _src ) : m_fAltSBCSFontScaleFactor * (float)_src;
-
-		ASSIGN_WITH_ROUNDING( m_AsianGlyph.baseline,	pGlyph->baseline );
-		ASSIGN_WITH_ROUNDING( m_AsianGlyph.height,		pGlyph->height );
-		ASSIGN_WITH_ROUNDING( m_AsianGlyph.horizAdvance,pGlyph->horizAdvance );
-//		m_AsianGlyph.horizOffset	= /*Round*/( m_fAltSBCSFontScaleFactor * pGlyph->horizOffset );
-		ASSIGN_WITH_ROUNDING( m_AsianGlyph.width,		pGlyph->width );
-
-		pGlyph = &m_AsianGlyph;
-	}
-
 	return pGlyph;
 }
 
-const int CFontInfo::GetCollapsedAsianCode(ulong uiLetter) const
-{
-	int iCollapsedAsianCode = 0;
-
-	if (AsianGlyphsAvailable())
-	{
-		switch ( GetLanguageEnum() )
-		{
-			case eKorean:		iCollapsedAsianCode = Korean_CollapseKSC5601HangulCode( uiLetter );	break;
-			case eTaiwanese:	iCollapsedAsianCode = Taiwanese_CollapseBig5Code( uiLetter );		break;
-			case eJapanese:		iCollapsedAsianCode = Japanese_CollapseShiftJISCode( uiLetter );	break;
-			case eChinese:		iCollapsedAsianCode = Chinese_CollapseGBCode( uiLetter );			break;
-			case eThai:			iCollapsedAsianCode = Thai_CollapseTISCode( uiLetter );				break;
-			default:			assert(0);	/* unhandled asian language */							break;
-		}
-	}
-
-	return iCollapsedAsianCode;
-}
-
 const int CFontInfo::GetLetterWidth(unsigned int uiLetter)
 {
 	const glyphInfo_t *pGlyph = GetLetter( uiLetter );
@@ -1246,82 +199,17 @@ const int CFontInfo::GetLetterHorizAdvance(unsigned int uiLetter)
 	return pGlyph->horizAdvance ? pGlyph->horizAdvance : mGlyphs['.'].horizAdvance;
 }
 
-// ensure any GetFont calls that need SBCS overriding (such as when playing in Russian) have the appropriate stuff done...
-//
-static CFontInfo *GetFont_SBCSOverride(CFontInfo *pFont, Language_e eLanguageSBCS, LPCSTR psLanguageNameSBCS )
-{
-	if ( !pFont->m_bIsFakeAlienLanguage )
-	{
-		if ( GetLanguageEnum() == eLanguageSBCS )
-		{
-			if ( pFont->m_iAltSBCSFont == -1 ) 	// no reg attempted yet?
-			{
-				// need to register this alternative SBCS font...
-				//
-				int iAltFontIndex = RE_RegisterFont( va("%s/%s",COM_SkipPath(pFont->m_sFontName),psLanguageNameSBCS) );	// ensure unique name (eg: "lcd/russian")
-				CFontInfo *pAltFont = GetFont_Actual( iAltFontIndex );
-				if ( pAltFont )
-				{
-					// work out the scaling factor for this font's glyphs...( round it to 1 decimal place to cut down on silly scale factors like 0.53125 )
-					//
-					pAltFont->m_fAltSBCSFontScaleFactor = RoundTenth((float)pFont->GetPointSize() / (float)pAltFont->GetPointSize());
-					//
-					// then override with the main properties of the original font...
-					//
-					pAltFont->mPointSize = pFont->GetPointSize();//(float) pAltFont->GetPointSize() * pAltFont->m_fAltSBCSFontScaleFactor;
-					pAltFont->mHeight	 = pFont->GetHeight();//(float) pAltFont->GetHeight()	* pAltFont->m_fAltSBCSFontScaleFactor;
-					pAltFont->mAscender	 = pFont->GetAscender();//(float) pAltFont->GetAscender()	* pAltFont->m_fAltSBCSFontScaleFactor;
-					pAltFont->mDescender = pFont->GetDescender();//(float) pAltFont->GetDescender()	* pAltFont->m_fAltSBCSFontScaleFactor;
-
-//					pAltFont->mPointSize = (float) pAltFont->GetPointSize() * pAltFont->m_fAltSBCSFontScaleFactor;
-//					pAltFont->mHeight	 = (float) pAltFont->GetHeight()	* pAltFont->m_fAltSBCSFontScaleFactor;
-//					pAltFont->mAscender	 = (float) pAltFont->GetAscender()	* pAltFont->m_fAltSBCSFontScaleFactor;
-//					pAltFont->mDescender = (float) pAltFont->GetDescender()	* pAltFont->m_fAltSBCSFontScaleFactor;
-
-					pAltFont->mbRoundCalcs = true;
-					pAltFont->m_iOriginalFontWhenSBCSOverriden = pFont->m_iThisFont;
-				}
-				pFont->m_iAltSBCSFont = iAltFontIndex;
-			}
-
-			if ( pFont->m_iAltSBCSFont > 0)
-			{
-				return GetFont_Actual( pFont->m_iAltSBCSFont );
-			}
-		}
-	}
-
-	return NULL;
-}
-
-
-
 CFontInfo *GetFont(int index)
 {
 	CFontInfo *pFont = GetFont_Actual( index );
-
-	if (pFont)
-	{
-		// any SBCS overrides? (this has to be pretty quick, and is (sort of))...
-		//
-		for (int i=0; g_SBCSOverrideLanguages[i].m_psName; i++)
-		{
-			CFontInfo *pAltFont = GetFont_SBCSOverride( pFont, g_SBCSOverrideLanguages[i].m_eLanguage, g_SBCSOverrideLanguages[i].m_psName );
-			if (pAltFont) 
-			{
-				return pAltFont;
-			}
-		}
-	}
-
 	return pFont;
 }
 
 
 int RE_Font_StrLenPixels(const char *psText, const int iFontHandle, const float fScale)
 {			
-	int			iMaxWidth = 0;
-	int			iThisWidth= 0;
+	float		maxWidth = 0.f;
+	float		thisWidth= 0.f;
 	CFontInfo	*curfont;
 
 	curfont = GetFont(iFontHandle);
@@ -1330,12 +218,6 @@ int RE_Font_StrLenPixels(const char *psText, const int iFontHandle, const float
 		return(0);
 	}
 
-	float fScaleA = fScale;
-	if (Language_IsAsian() && fScale > 0.7f )
-	{
-		fScaleA = fScale * 0.75f;
-	}
-
 	while(*psText)
 	{
 		int iAdvanceCount;
@@ -1355,61 +237,22 @@ int RE_Font_StrLenPixels(const char *psText, const int iFontHandle, const float
 
 		if (uiLetter == 0x0A)
 		{
-			iThisWidth = 0;
+			thisWidth = 0.f;
 		}
 		else
 		{
 			int iPixelAdvance = curfont->GetLetterHorizAdvance( uiLetter );
 	
-			float fValue = iPixelAdvance * ((uiLetter > g_iNonScaledCharRange) ? fScaleA : fScale);
-			iThisWidth += curfont->mbRoundCalcs ? Round( fValue ) : fValue;
-			if (iThisWidth > iMaxWidth)
+			float fValue = iPixelAdvance * fScale;
+			thisWidth += fValue;
+			if (thisWidth > maxWidth)
 			{
-				iMaxWidth = iThisWidth;
+				maxWidth = thisWidth;
 			}
 		}
 	}
 
-	return iMaxWidth;
-}
-
-// not really a font function, but keeps naming consistant...
-//
-int RE_Font_StrLenChars(const char *psText)
-{			
-	// logic for this function's letter counting must be kept same in this function and RE_Font_DrawString()
-	//
-	int iCharCount = 0;
-
-	while ( *psText )
-	{
-		// in other words, colour codes and CR/LF don't count as chars, all else does...
-		//
-		int iAdvanceCount;
-		unsigned int uiLetter = AnyLanguage_ReadCharFromString( psText, &iAdvanceCount, NULL );
-		psText += iAdvanceCount;
-
-		switch (uiLetter)
-		{
-			case '^':
-				if (*psText >= '0' &&
-					*psText <= '9')
-				{
-					psText++;
-				}
-				else
-				{
-					iCharCount++;
-				}
-				break;	// colour code (note next-char skip)
-			case 10:								break;	// linefeed
-			case 13:								break;	// return 
-			case '_':	iCharCount += (GetLanguageEnum() == eThai && (((unsigned char *)psText)[0] >= TIS_GLYPHS_START))?0:1; break;	// special word-break hack
-			default:	iCharCount++;				break;
-		}
-	}
-	
-	return iCharCount;
+	return Round(maxWidth);
 }
 
 int RE_Font_HeightPixels(const int iFontHandle, const float fScale)
@@ -1420,23 +263,23 @@ int RE_Font_HeightPixels(const int iFontHandle, const float fScale)
 	if(curfont)
 	{
 		float fValue = curfont->GetPointSize() * fScale;
-		return curfont->mbRoundCalcs ? Round(fValue) : fValue;
+		return Round(fValue);
 	}
 	return(0);
 }
 
-// iMaxPixelWidth is -1 for "all of string", else pixel display count...
+// limit is 0 for "all of string", else display count...
 //
-void RE_Font_DrawString(int ox, int oy, const char *psText, const float *rgba, const int iFontHandle, int iMaxPixelWidth, const float fScale)
+void RE_Font_DrawString(int x, int y, qhandle_t font, float scale, vec4_t color, const char* text, int limit, int flags, int cursorPos, char cursor)
 {
-	static qboolean gbInShadow = qfalse;	// MUST default to this
-	int					x, y, colour, offset;
-	const glyphInfo_t	*pLetter;
-	qhandle_t			hShader;
+	float				curX, curY;
+	int					colour;
+	const glyphInfo_t	*letter;
+	qhandle_t			shader;
 
-	assert (psText);
+	assert (text);
 
-	if(iFontHandle & STYLE_BLINK)
+	if(font & STYLE_BLINK)
 	{
 		if((ri.Milliseconds() >> 7) & 1)
 		{
@@ -1444,173 +287,105 @@ void RE_Font_DrawString(int ox, int oy, const char *psText, const float *rgba, c
 		}
 	}
 
-//	// test code only
-//	if (GetLanguageEnum() == eTaiwanese)
-//	{
-//		psText = "Wp:¶}·F§a ¿p·G´µ¡A§Æ±æ§A¹³¥L­Ì»¡ªº¤@¼Ë¦æ¡C";
-//	}
-//	else 
-//	if (GetLanguageEnum() == eChinese)
-//	{
-//		//psText = "Ó¶±øÕ½³¡II  Ô¼º²?ÄªÁÖË¹  ÈÎÎñÊ§°Ü  ÄãÒªÌ×ÓÃ»­ÃæÉè¶¨µÄ±ä¸üÂð£¿  Ô¤Éè,S3 Ñ¹Ëõ,DXT1 Ñ¹Ëõ,DXT5 Ñ¹Ëõ,16 Bit,32 Bit";
-//		psText = "Ó¶±øÕ½³¡II";
-//	}
-//	else 
-//	if (GetLanguageEnum() == eThai)
-//	{
-//		//psText = "ÁÒµÃ°Ò¹¼ÅÔµÀÑ³±ìÍØµÊÒË¡ÃÃÁÃËÑÊÊÓËÃÑºÍÑ¡¢ÃÐä·Â·Õèãªé¡Ñº¤ÍÁ¾ÔÇàµÍÃì";
-//		psText = "ÁÒµÃ°Ò¹¼ÅÔµ";
-//		psText = "ÃËÑÊÊÓËÃÑº";
-//		psText = "ÃËÑÊÊÓËÃÑº   ÍÒ_¡Ô¹_¤ÍÃì·_1415";
-//	}
-//	else
-//	if (GetLanguageEnum() == eKorean)
-//	{
-//		psText = "Wp:¼îÅ¸ÀÓÀÌ´Ù ¸Ö¸°. ±×µéÀÌ ¸»ÇÑ´ë·Î ³×°¡ ÀßÇÒÁö ±â´ëÇÏ°Ú´Ù.";
-//	}
-//	else
-//	if (GetLanguageEnum() == eJapanese)
-//	{
-//		static char sBlah[200];
-//		sprintf(sBlah,va("%c%c%c%c%c%c%c%c",0x82,0xA9,0x82,0xC8,0x8A,0xBF,0x8E,0x9A));
-//		psText = &sBlah[0];
-//	}
-//	else
-//	if (GetLanguageEnum() == eRussian)
-//	{
-////		//psText = "Íà âåðøèíå õîëìà ñòîèò ñòàðûé äîì ñ ïðèâèäåíèÿìè è áàøíÿ ñ âîëøåáíûìè ÷àñàìè."
-//		psText = "Íà âåðøèíå õîëìà ñòîèò";
-//	}
-//	else
-//	if (GetLanguageEnum() == ePolish)
-//	{
-//		psText = "za³o¿ony w 1364 roku, jest najstarsz¹ polsk¹ uczelni¹ i nale¿y...";
-//		psText = "za³o¿ony nale¿y";
-//	}
-
-
-	CFontInfo *curfont = GetFont(iFontHandle);
-	if(!curfont || !psText)
+	CFontInfo *curfont = GetFont(font);
+	if(!curfont || !text)
 	{
 		return;
 	}
 
-	float fScaleA = fScale;
-	int iAsianYAdjust = 0;
-	if (Language_IsAsian() && fScale > 0.7f)
-	{
-		fScaleA = fScale * 0.75f;
-		iAsianYAdjust = /*Round*/((((float)curfont->GetPointSize() * fScale) - ((float)curfont->GetPointSize() * fScaleA))/2);
-	}
-
-	// Draw a dropshadow if required
-	if(iFontHandle & STYLE_DROPSHADOW)
-	{
-		offset = Round(curfont->GetPointSize() * fScale * 0.075f);
-
-		static const vec4_t v4DKGREY2 = {0.15f, 0.15f, 0.15f, 1};
+	RE_SetColor( color );
 
-		gbInShadow = qtrue;
-		RE_Font_DrawString(ox + offset, oy + offset, psText, v4DKGREY2, iFontHandle & SET_MASK, iMaxPixelWidth, fScale);
-		gbInShadow = qfalse;
-	}
-		
-	RE_SetColor( rgba );
+	curX = x;
+	y += (curfont->GetHeight() - curfont->GetDescender()) * scale;
 
-	x = ox;
-	oy += Round((curfont->GetHeight() - (curfont->GetDescender() >> 1)) * fScale);
-
-	qboolean bNextTextWouldOverflow = qfalse;
-	while (*psText && !bNextTextWouldOverflow)
+	qboolean nextTextWouldOverflow = qfalse;
+	const char *textStart = text;
+	while (*text && !nextTextWouldOverflow)
 	{
-		int iAdvanceCount;
-		unsigned int uiLetter = AnyLanguage_ReadCharFromString( psText, &iAdvanceCount, NULL );
-		psText += iAdvanceCount;
+		int advanceCount;
+		unsigned int uiLetter = AnyLanguage_ReadCharFromString( text, &advanceCount, NULL );
+		text += advanceCount;
 
 		switch( uiLetter )
 		{
 		case 10:						//linefeed
-			x = ox;
-			oy += Round(curfont->GetPointSize() * fScale);
-			if (Language_IsAsian())
-			{
-				oy += 4;	// this only comes into effect when playing in asian for "A long time ago in a galaxy" etc, all other text is line-broken in feeder functions
-			}
+			curX = x;
+			y += curfont->GetPointSize() * scale;
 			break;
 		case 13:						// Return
 			break;
 		case 32:						// Space
-			pLetter = curfont->GetLetter(' ');			
-			x += Round(pLetter->horizAdvance * fScale);
-			bNextTextWouldOverflow = ( iMaxPixelWidth != -1 && ((x-ox)>iMaxPixelWidth) ) ? qtrue : qfalse;	// yeuch
+			letter = curfont->GetLetter(' ');			
+			curX += letter->horizAdvance * scale;
+			nextTextWouldOverflow = (limit && (text - textStart) > limit) ? qtrue : qfalse;	// yeuch
 			break;
-		case '_':	// has a special word-break usage if in Thai (and followed by a thai char), and should not be displayed, else treat as normal
-			if (GetLanguageEnum()== eThai && ((unsigned char *)psText)[0] >= TIS_GLYPHS_START)
-			{
-				break;
-			}
-			// else drop through and display as normal...
 		case '^':
-			if (uiLetter != '_')	// necessary because of fallthrough above
+			if (*text >= '0' &&
+				*text <= '9')
 			{
-				if (*psText >= '0' &&
-					*psText <= '9')
-				{
-					colour = ColorIndex(*psText++);
-					if (!gbInShadow)
-					{
-						RE_SetColor( g_color_table[colour] );
-					}
-					break;
-				}
+				colour = ColorIndex(*text++);
+				RE_SetColor( g_color_table[colour] );
+				break;
 			}
 			//purposely falls thrugh
 		default:
-			pLetter = curfont->GetLetter( uiLetter, &hShader );			// Description of pLetter
-			if(!pLetter->width)
+			letter = curfont->GetLetter( uiLetter, &shader );			// Description of letter
+			if(!letter->width)
 			{
-				pLetter = curfont->GetLetter('.');
+				letter = curfont->GetLetter('.');
 			}
 
-			float fThisScale = uiLetter > g_iNonScaledCharRange ? fScaleA : fScale;
-
-			// sigh, super-language-specific hack...
-			//
-			if (uiLetter == TIS_SARA_AM && GetLanguageEnum() == eThai)
+			float advancePixels = letter->horizAdvance * scale;
+			nextTextWouldOverflow = (limit && (text - textStart) > limit) ? qtrue : qfalse;	// yeuch
+			if (!nextTextWouldOverflow)
 			{
-				x -= Round(7 * fThisScale);
-			}
-
-			int iAdvancePixels = Round(pLetter->horizAdvance * fThisScale);
-			bNextTextWouldOverflow = ( iMaxPixelWidth != -1 && (((x+iAdvancePixels)-ox)>iMaxPixelWidth) ) ? qtrue : qfalse;	// yeuch
-			if (!bNextTextWouldOverflow)
-			{
-				// this 'mbRoundCalcs' stuff is crap, but the only way to make the font code work. Sigh...
-				//				
-				y = oy - (curfont->mbRoundCalcs ? Round(pLetter->baseline * fThisScale) : pLetter->baseline * fThisScale);
-				if (curfont->m_fAltSBCSFontScaleFactor != -1)
-				{
-					y+=3;	// I'm sick and tired of going round in circles trying to do this legally, so bollocks to it
-				}
-
-				RE_StretchPic ( x + Round(pLetter->horizOffset * fScale), // float x
-								(uiLetter > g_iNonScaledCharRange) ? y - iAsianYAdjust : y,	// float y
-								curfont->mbRoundCalcs ? Round(pLetter->width * fThisScale) : pLetter->width * fThisScale,	// float w
-								curfont->mbRoundCalcs ? Round(pLetter->height * fThisScale) : pLetter->height * fThisScale, // float h
-								pLetter->s,						// float s1
-								pLetter->t,						// float t1
-								pLetter->s2,					// float s2
-								pLetter->t2,					// float t2
+				curY = y - letter->baseline * scale;
+
+				RE_StretchPic ( curX + letter->horizOffset * scale, // float x
+								curY,	// float y
+								letter->width * scale,	// float w
+								letter->height * scale, // float h
+								letter->s,						// float s1
+								letter->t,						// float t1
+								letter->s2,					// float s2
+								letter->t2,					// float t2
 								//lastcolour.c, 
-								hShader							// qhandle_t hShader
+								shader							// qhandle_t hShader
 								);
 
-				x += iAdvancePixels;
+				curX += advancePixels;
 			}
+
 			break;
-		}		
+		}
 	}
-	//let it remember the old color //RE_SetColor(NULL);;
+
+	if (cursor && (ri.Milliseconds() >> 7) & 1) {
+		// draw blinking cursor
+		curX = x;
+		for ( int i = 0 ; i < cursorPos ; ++i ) {
+			letter = curfont->GetLetter( textStart[i] );			// Description of letter
+			curX += letter->horizAdvance * scale;
+		}
+		letter = curfont->GetLetter( cursor, &shader );			// Description of letter
+		if(!letter->width)
+		{
+			letter = curfont->GetLetter('.');
+		}
+		curY = y - letter->baseline * scale;
+		RE_StretchPic ( curX + letter->horizOffset * scale, // float x
+						curY,	// float y
+						letter->width * scale,	// float w
+						letter->height * scale, // float h
+						letter->s,						// float s1
+						letter->t,						// float t1
+						letter->s2,					// float s2
+						letter->t2,					// float t2
+						//lastcolour.c, 
+						shader							// qhandle_t hShader
+						);
+	}
+	RE_SetColor(NULL);;
 }
 
 int RE_RegisterFont(const char *psName) 
@@ -1644,8 +419,7 @@ int RE_RegisterFont(const char *psName)
 
 void R_InitFonts(void)
 {
-	g_iCurrentFontIndex = 1;			// entry 0 is reserved for "missing/invalid"
-	g_iNonScaledCharRange = INT_MAX;	// default all chars to have no special scaling (other than user supplied)
+	g_iCurrentFontIndex = 0;
 }
 
 /*
@@ -1671,15 +445,13 @@ void R_FontList_f( void ) {
 
 void R_ShutdownFonts(void)
 {
-	for(int i = 1; i < g_iCurrentFontIndex; i++)	// entry 0 is reserved for "missing/invalid"
+	for(int i = 0; i < g_iCurrentFontIndex; i++)
 	{
 		delete g_vFontArray[i];
 	}
 	g_mapFontIndexes.clear();
 	g_vFontArray.clear();
-	g_iCurrentFontIndex = 1;	// entry 0 is reserved for "missing/invalid"
-
-	g_ThaiCodes.Clear();
+	g_iCurrentFontIndex = 0;
 }
 
 // this is only really for debugging while tinkering with fonts, but harmless to leave in...
@@ -1691,7 +463,7 @@ void R_ReloadFonts_f(void)
 	vector <sstring_t> vstrFonts;
 
 	int iFontToFind;
-	for (iFontToFind = 1; iFontToFind < g_iCurrentFontIndex; iFontToFind++)
+	for (iFontToFind = 0; iFontToFind < g_iCurrentFontIndex; iFontToFind++)
 	{	
 		FontIndexMap_t::iterator it;
 		for (it = g_mapFontIndexes.begin(); it != g_mapFontIndexes.end(); ++it)
diff --git a/codemp/rd-vanilla/tr_font.h b/codemp/rd-vanilla/tr_font.h
index e078783..ba3f110 100644
--- a/codemp/rd-vanilla/tr_font.h
+++ b/codemp/rd-vanilla/tr_font.h
@@ -12,9 +12,8 @@ void R_ShutdownFonts(void);
 void R_InitFonts(void);
 int RE_RegisterFont(const char *psName);
 int RE_Font_StrLenPixels(const char *psText, const int iFontHandle, const float fScale = 1.0f);
-int RE_Font_StrLenChars(const char *psText);
 int RE_Font_HeightPixels(const int iFontHandle, const float fScale = 1.0f);
-void RE_Font_DrawString(int ox, int oy, const char *psText, const float *rgba, const int iFontHandle, int iMaxPixelWidth, const float fScale = 1.0f);
+void RE_Font_DrawString(int x, int y, qhandle_t font, float scale, vec4_t color, const char* text, int limit, int flags, int cursorPos, char cursor);
 
 // Dammit, I can't use this more elegant form because of !@#@!$%% VM code... (can't alter passed in ptrs, only contents of)
 //
@@ -24,10 +23,6 @@ void RE_Font_DrawString(int ox, int oy, const char *psText, const float *rgba, c
 //
 unsigned int AnyLanguage_ReadCharFromString( const char *psText, int *piAdvanceCount, qboolean *pbIsTrailingPunctuation = NULL);
 
-qboolean Language_IsAsian(void);
-qboolean Language_UsesSpaces(void);
-
-
 #endif	// #ifndef TR_FONT_H
 
 // end
diff --git a/codemp/rd-vanilla/tr_ghoul2.cpp b/codemp/rd-vanilla/tr_ghoul2.cpp
index 3a0b40a..afa4fd9 100644
--- a/codemp/rd-vanilla/tr_ghoul2.cpp
+++ b/codemp/rd-vanilla/tr_ghoul2.cpp
@@ -1200,7 +1200,7 @@ void G2_TimingModel(boneInfo_t &bone,int currentTime,int numFramesInFile,int &cu
 			}
 			else
 			{
-				if (((bone.flags & (BONE_ANIM_OVERRIDE_FREEZE)) == (BONE_ANIM_OVERRIDE_FREEZE)))
+				if (bone.flags & BONE_ANIM_OVERRIDE_DEFAULT || ((bone.flags & (BONE_ANIM_OVERRIDE_FREEZE)) == (BONE_ANIM_OVERRIDE_FREEZE)))
 				{
 					// if we are supposed to reset the default anim, then do so
 					if (animSpeed > 0.0f)
@@ -1694,10 +1694,6 @@ void G2_TransformBone (int child,CBoneCache &BC)
 	if (angleOverride & BONE_ANGLES_REPLACE)
 	{
 		bool isRag=!!(angleOverride & BONE_ANGLES_RAGDOLL);
-		if (!isRag)
-		{ //do the same for ik.. I suppose.
-			isRag = !!(angleOverride & BONE_ANGLES_IK);
-		}
 
 		mdxaBone_t &bone = BC.mFinalBones[child].boneMatrix;
 		boneInfo_t &boneOverride = boneList[boneListIndex];
@@ -1866,7 +1862,7 @@ void G2_TransformBone (int child,CBoneCache &BC)
 	}
 	else if (angleOverride & BONE_ANGLES_PREMULT)
 	{
-		if ((angleOverride&BONE_ANGLES_RAGDOLL) || (angleOverride&BONE_ANGLES_IK))
+		if (angleOverride&BONE_ANGLES_RAGDOLL)
 		{
 			mdxaBone_t	tmp;
 			if (!child)
@@ -2433,7 +2429,7 @@ void RenderSurfaces(CRenderSurface &RS) //also ended up just ripping right from
 			for ( j = 0 ; j < RS.skin->numSurfaces ; j++ )
 			{
 				// the names have both been lowercased
-				if ( !strcmp( RS.skin->surfaces[j]->name, surfInfo->name ) ) 
+				if ( !strcmp( RS.skin->surfaces[j]->name, surfInfo->shader ) ) 
 				{
 					shader = (shader_t*)RS.skin->surfaces[j]->shader;
 					break;
@@ -2495,7 +2491,7 @@ void RenderSurfaces(CRenderSurface &RS) //also ended up just ripping right from
 #ifdef _G2_GORE
 			if (RS.gore_set && drawGore)
 			{
-				int curTime = G2API_GetTime(tr.refdef.time);
+				int curTime = tr.refdef.time;
 				pair<multimap<int,SGoreSurface>::iterator,multimap<int,SGoreSurface>::iterator> range=
 					RS.gore_set->mGoreRecords.equal_range(RS.surfaceNum);
 				multimap<int,SGoreSurface>::iterator k,kcur;
@@ -2556,15 +2552,6 @@ void RenderSurfaces(CRenderSurface &RS) //also ended up just ripping right from
 							if ((*kcur).second.mDeleteTime - curTime < (*kcur).second.mFadeTime)
 							{
 								newSurf2->fade=(float)((*kcur).second.mDeleteTime - curTime)/(*kcur).second.mFadeTime;
-								if ((*kcur).second.mFadeRGB)
-								{ //RGB fades are scaled from 2.0f to 3.0f (simply to differentiate)
-									newSurf2->fade += 2.0f;
-
-									if (newSurf2->fade < 2.01f)
-									{
-										newSurf2->fade = 2.01f;
-									}
-								}
 							}
 						}
 
@@ -3235,8 +3222,7 @@ void R_AddGhoulSurfaces( trRefEntity_t *ent ) {
 		return;
 	}
 
-	int currentTime=G2API_GetTime(tr.refdef.time);
-
+	int currentTime=tr.refdef.time;
 
 	// cull the entire model if merged bounding box of both frames
 	// is outside the view frustum.
@@ -3287,7 +3273,7 @@ void R_AddGhoulSurfaces( trRefEntity_t *ent ) {
 	for (j=0; j<modelCount; j++)
 	{
 		i = modelList[j];
-		if (ghoul2[i].mValid&&!(ghoul2[i].mFlags & GHOUL2_NOMODEL)&&!(ghoul2[i].mFlags & GHOUL2_NORENDER))
+		if (ghoul2[i].mValid&&!(ghoul2[i].mFlags & GHOUL2_NOMODEL))
 		{
 			//
 			// figure out whether we should be using a custom shader for this model
@@ -3341,15 +3327,18 @@ void R_AddGhoulSurfaces( trRefEntity_t *ent ) {
 				}
 			}
 
-			CRenderSurface RS(ghoul2[i].mSurfaceRoot, ghoul2[i].mSlist, cust_shader, fogNum, personalModel, ghoul2[i].mBoneCache, ent->e.renderfx, skin, (model_t *)ghoul2[i].currentModel, whichLod, ghoul2[i].mBltlist, gore_shader, gore);
+			if (!(ghoul2[i].mFlags & GHOUL2_NORENDER)) {
+				CRenderSurface RS(ghoul2[i].mSurfaceRoot, ghoul2[i].mSlist, cust_shader, fogNum, personalModel, ghoul2[i].mBoneCache, ent->e.renderfx, skin, (model_t *)ghoul2[i].currentModel, whichLod, ghoul2[i].mBltlist, gore_shader, gore);
 #else
-			CRenderSurface RS(ghoul2[i].mSurfaceRoot, ghoul2[i].mSlist, cust_shader, fogNum, personalModel, ghoul2[i].mBoneCache, ent->e.renderfx, skin, (model_t *)ghoul2[i].currentModel, whichLod, ghoul2[i].mBltlist);
+			if (!(ghoul2[i].mFlags & GHOUL2_NORENDER)) {
+				CRenderSurface RS(ghoul2[i].mSurfaceRoot, ghoul2[i].mSlist, cust_shader, fogNum, personalModel, ghoul2[i].mBoneCache, ent->e.renderfx, skin, (model_t *)ghoul2[i].currentModel, whichLod, ghoul2[i].mBltlist);
 #endif
-			if (!personalModel && (RS.renderfx & RF_SHADOW_PLANE) && !bInShadowRange(ent->e.origin))
-			{
-				RS.renderfx |= RF_NOSHADOW;
+				if (!personalModel && (RS.renderfx & RF_SHADOW_PLANE) && !bInShadowRange(ent->e.origin))
+				{
+					RS.renderfx |= RF_NOSHADOW;
+				}
+				RenderSurfaces(RS);
 			}
-			RenderSurfaces(RS);
 		}
 	}
 	HackadelicOnClient=false;
@@ -4196,6 +4185,7 @@ qboolean R_LoadMDXM( model_t *mod, void *buffer, const char *mod_name, qboolean
 	mdxmSurface_t		*surf;
 	int					version;
 	int					size;
+	shader_t			*sh;
 	mdxmSurfHierarchy_t	*surfInfo;
 
 #ifndef _M_IX86
@@ -4258,7 +4248,11 @@ qboolean R_LoadMDXM( model_t *mod, void *buffer, const char *mod_name, qboolean
 	}
 		
 	// first up, go load in the animation file we need that has the skeletal animation info for this model
-	mdxm->animIndex = RE_RegisterModel(va ("%s.gla",mdxm->animName));
+	if (strstr(mdxm->animName, "/weapons/") != 0) {
+		mdxm->animIndex = RE_RegisterModel(va ("%s.gla",mdxm->animName));
+	} else {
+		mdxm->animIndex = RE_RegisterModel(va ("%s_mp.gla",mdxm->animName));
+	}
 
 	if (!mdxm->animIndex) 
 	{
@@ -4286,32 +4280,38 @@ qboolean R_LoadMDXM( model_t *mod, void *buffer, const char *mod_name, qboolean
 		LL(surfInfo->parentIndex);
 
 		Q_strlwr(surfInfo->name);	//just in case
-		if ( !strcmp( &surfInfo->name[strlen(surfInfo->name)-4],"_off") )
+		if ( surfInfo->shader[0] == '[' )
 		{
-			surfInfo->name[strlen(surfInfo->name)-4]=0;	//remove "_off" from name
+			surfInfo->shader[0] = 0;	//kill the stupid [nomaterial] since carcass doesn't
 		}
-
+		
 		// do all the children indexs
 		for (j=0; j<surfInfo->numChildren; j++)
 		{
 			LL(surfInfo->childIndexes[j]);
 		}
 
-		shader_t	*sh;
-		// get the shader name
-		sh = R_FindShader( surfInfo->shader, lightmapsNone, stylesDefault, qtrue );
-		// insert it in the surface list
-		if ( sh->defaultShader ) 
-		{
-			surfInfo->shaderIndex = 0;
-		}
-		else
+		// No need to search for the shader if it doesn't resemble a path
+		if (strstr(surfInfo->shader, "/"))
 		{
-			surfInfo->shaderIndex = sh->index;
-		}
+			// get the shader name
+			sh = R_FindShader( surfInfo->shader, lightmapsNone, stylesDefault, qtrue );
+
+			// insert it in the surface list
+			if ( !sh->defaultShader ) 
+			{
+				surfInfo->shaderIndex = sh->index;
+			}
 
-		RE_RegisterModels_StoreShaderRequest(mod_name, &surfInfo->shader[0], &surfInfo->shaderIndex);		
+		
+			if (surfInfo->shaderIndex)
 
+			{
+				RE_RegisterModels_StoreShaderRequest(mod_name, &surfInfo->shader[0], &surfInfo->shaderIndex);		
+
+			}
+		}
+		
 		// find the next surface
 		surfInfo = (mdxmSurfHierarchy_t *)( (byte *)surfInfo + (int)( &((mdxmSurfHierarchy_t *)0)->childIndexes[ surfInfo->numChildren ] ));
   	}
diff --git a/codemp/rd-vanilla/tr_image.cpp b/codemp/rd-vanilla/tr_image.cpp
index 1cecf27..8cb38c2 100644
--- a/codemp/rd-vanilla/tr_image.cpp
+++ b/codemp/rd-vanilla/tr_image.cpp
@@ -114,10 +114,10 @@ void GL_TextureMode( const char *string ) {
 	gl_filter_max = modes[i].maximize;
 
 	// If the level they requested is less than possible, set the max possible...
-	if ( r_ext_texture_filter_anisotropic->value > glConfig.maxTextureFilterAnisotropy )
+	/*if ( r_ext_texture_filter_anisotropic->value > glConfig.maxTextureFilterAnisotropy )
 	{
 		ri.Cvar_Set( "r_ext_texture_filter_anisotropic", va("%f",glConfig.maxTextureFilterAnisotropy) );
-	}
+	}*/
 	// change all the existing mipmap texture objects
 	   				 R_Images_StartIteration();
 	while ( (glt   = R_Images_GetNextIteration()) != NULL)
@@ -127,13 +127,13 @@ void GL_TextureMode( const char *string ) {
 			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
 			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
 
-			if(glConfig.maxTextureFilterAnisotropy>0) {
+			/*if(glConfig.maxTextureFilterAnisotropy>0) {
 				if(r_ext_texture_filter_anisotropic->integer>1) {
 					qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, r_ext_texture_filter_anisotropic->value);
 				} else {
 					qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1.0f);
 				}
-			}
+			}*/
 		}
 	}
 }
@@ -660,7 +660,7 @@ static void Upload32( unsigned *data,
 		// select proper internal format
 		if ( samples == 3 )
 		{
-			if ( glConfig.textureCompression == TC_S3TC && allowTC )
+			/*if ( glConfig.textureCompression == TC_S3TC && allowTC )
 			{
 				*pformat = GL_RGB4_S3TC;
 			}
@@ -673,7 +673,7 @@ static void Upload32( unsigned *data,
 					*pformat = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
 				}
 			}
-			else if ( isLightmap && r_texturebitslm->integer > 0 )
+			else*/ if ( isLightmap && r_texturebitslm->integer > 0 )
 			{
 				// Allow different bit depth when we are a lightmap
 				if ( r_texturebitslm->integer == 16 )
@@ -700,11 +700,11 @@ static void Upload32( unsigned *data,
 		}
 		else if ( samples == 4 )
 		{
-			if ( glConfig.textureCompression == TC_S3TC_DXT && allowTC)
+			/*if ( glConfig.textureCompression == TC_S3TC_DXT && allowTC)
 			{	// Compress both alpha and color
 				*pformat = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
 			}
-			else if ( r_texturebits->integer == 16 )
+			else*/ if ( r_texturebits->integer == 16 )
 			{
 				*pformat = GL_RGBA4;
 			}
@@ -767,10 +767,10 @@ done:
 	{
 		qglTexParameterf(uiTarget, GL_TEXTURE_MIN_FILTER, gl_filter_min);
 		qglTexParameterf(uiTarget, GL_TEXTURE_MAG_FILTER, gl_filter_max);
-		if(r_ext_texture_filter_anisotropic->integer>1 && glConfig.maxTextureFilterAnisotropy>0)
+		/*if(r_ext_texture_filter_anisotropic->integer>1 && glConfig.maxTextureFilterAnisotropy>0)
 		{			
 			qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, r_ext_texture_filter_anisotropic->value );
-		}
+		}*/
 	}
 	else
 	{
@@ -1203,7 +1203,7 @@ image_t *R_CreateImage( const char *name, const byte *pic, int width, int height
 	image_t		*image;
 	qboolean	isLightmap = qfalse;
 
-	if (strlen(name) >= MAX_QPATH ) {
+	if (strlen(name) >= MAX_OSPATH ) {
 		Com_Error (ERR_DROP, "R_CreateImage: \"%s\" is too long\n", name);
 	}
 
@@ -2134,7 +2134,7 @@ Loads any of the supported image types into a cannonical
 */
 void R_LoadImage( const char *shortname, byte **pic, int *width, int *height, GLenum *format ) {
 	int		bytedepth;
-	char	name[MAX_QPATH];
+	char	name[MAX_OSPATH];
 
 	*pic = NULL;
 	*width = 0;
@@ -2656,7 +2656,7 @@ static void R_CreateDefaultImage( void ) {
 		data[x][DEFAULT_SIZE-1][2] =
 		data[x][DEFAULT_SIZE-1][3] = 255;
 	}
-	tr.defaultImage = R_CreateImage("*default", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, GL_RGBA, qtrue, qfalse, qfalse, GL_REPEAT );
+	tr.defaultImage = R_CreateImage("*default", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, GL_RGBA, qtrue, qfalse, qtrue, GL_REPEAT );
 }
 
 /*
@@ -2926,87 +2926,7 @@ bool RE_SplitSkins(const char *INname, char *skinhead, char *skintorso, char *sk
 	return false;
 }
 
-// given a name, go get the skin we want and return
-qhandle_t RE_RegisterIndividualSkin( const char *name , qhandle_t hSkin) 
-{
-	skin_t			*skin;
-	skinSurface_t	*surf;
-	char			*text, *text_p;
-	char			*token;
-	char			surfName[MAX_QPATH];
-
-	// load and parse the skin file
-    ri.FS_ReadFile( name, (void **)&text );
-	if ( !text ) {
-#ifndef FINAL_BUILD
-		Com_Printf( "WARNING: RE_RegisterSkin( '%s' ) failed to load!\n", name );
-#endif
-		return 0;
-	}
-
-	assert (tr.skins[hSkin]);	//should already be setup, but might be an 3part append
-
-	skin = tr.skins[hSkin];
-
-	text_p = text;
-	while ( text_p && *text_p ) {
-		// get surface name
-		token = CommaParse( &text_p );
-		Q_strncpyz( surfName, token, sizeof( surfName ) );
-
-		if ( !token[0] ) {
-			break;
-		}
-		// lowercase the surface name so skin compares are faster
-		Q_strlwr( surfName );
-
-		if ( *text_p == ',' ) {
-			text_p++;
-		}
-
-		if ( !strncmp( token, "tag_", 4 ) ) {	//these aren't in there, but just in case you load an id style one...
-			continue;
-		}
-		
-		// parse the shader name
-		token = CommaParse( &text_p );
-
-		if ( !strcmp( &surfName[strlen(surfName)-4], "_off") )
-		{
-			if ( !strcmp( token ,"*off" ) )
-			{
-				continue;	//don't need these double offs
-			}
-			surfName[strlen(surfName)-4] = 0;	//remove the "_off"
-		}
-		if (sizeof( skin->surfaces) / sizeof( skin->surfaces[0] ) <= skin->numSurfaces)
-		{
-			assert( sizeof( skin->surfaces) / sizeof( skin->surfaces[0] ) > skin->numSurfaces );
-			Com_Printf( "WARNING: RE_RegisterSkin( '%s' ) more than %d surfaces!\n", name, sizeof( skin->surfaces) / sizeof( skin->surfaces[0] ) );
-			break;
-		}
-		surf = (skinSurface_t *) Hunk_Alloc( sizeof( *skin->surfaces[0] ), h_low );
-		skin->surfaces[skin->numSurfaces] = (_skinSurface_t *)surf;
-
-		Q_strncpyz( surf->name, surfName, sizeof( surf->name ) );
-
-		if (gServerSkinHack)	surf->shader = R_FindServerShader( token, lightmapsNone, stylesDefault, qtrue );
-		else					surf->shader = R_FindShader( token, lightmapsNone, stylesDefault, qtrue );
-		skin->numSurfaces++;
-	}
-
-	ri.FS_FreeFile( text );
-
-
-	// never let a skin have 0 shaders
-	if ( skin->numSurfaces == 0 ) {
-		return 0;		// use default skin
-	}
-
-	return hSkin;
-}
-
-qhandle_t RE_RegisterSkin( const char *name ) {
+qhandle_t RE_RegisterSkin( const char *name, int numPairs, char *skinPairs ) {
 	qhandle_t	hSkin;
 	skin_t		*skin;
 
@@ -3045,34 +2965,29 @@ qhandle_t RE_RegisterSkin( const char *name ) {
 	// make sure the render thread is stopped
 	R_SyncRenderThread();
 
-	// If not a .skin file, load as a single shader
-	if ( strcmp( name + strlen( name ) - 5, ".skin" ) ) {
-/*		skin->numSurfaces = 1;
-		skin->surfaces[0] = (skinSurface_t *)Hunk_Alloc( sizeof(skin->surfaces[0]), h_low );
-		skin->surfaces[0]->shader = R_FindShader( name, lightmapsNone, stylesDefault, qtrue );
-		return hSkin;
-*/
-	}
 
-	char skinhead[MAX_QPATH]={0};
-	char skintorso[MAX_QPATH]={0};
-	char skinlower[MAX_QPATH]={0};
-	if ( RE_SplitSkins(name, (char*)&skinhead, (char*)&skintorso, (char*)&skinlower ) )
-	{//three part
-		hSkin = RE_RegisterIndividualSkin(skinhead, hSkin);
-		if (hSkin)
-		{
-			hSkin = RE_RegisterIndividualSkin(skintorso, hSkin);
-			if (hSkin)
-			{
-				hSkin = RE_RegisterIndividualSkin(skinlower, hSkin);
-			}
-		}
+	char surfName[MAX_QPATH];
+	char *token;
+	for (int i = 0; i < numPairs; ++i) {
+		token = CommaParse(&skinPairs);
+		Q_strncpyz( surfName, token, sizeof( surfName ) );
+
+		token = CommaParse(&skinPairs);
+		skinSurface_t *surf = (skinSurface_t *) Hunk_Alloc( sizeof( *skin->surfaces[0] ), h_low );
+		skin->surfaces[skin->numSurfaces] = (_skinSurface_t *)surf;
+
+		Q_strncpyz( surf->name, surfName, sizeof( surf->name ) );
+
+		if (gServerSkinHack)	surf->shader = R_FindServerShader( token, lightmapsNone, stylesDefault, qtrue );
+		else					surf->shader = R_FindShader( token, lightmapsNone, stylesDefault, qtrue );
+		skin->numSurfaces++;
 	}
-	else
-	{//single skin
-		hSkin = RE_RegisterIndividualSkin(name, hSkin);
+
+	// never let a skin have 0 shaders
+	if ( skin->numSurfaces == 0 ) {
+		return 0;		// use default skin
 	}
+
 	return(hSkin);
 }
 
@@ -3199,11 +3114,13 @@ qhandle_t RE_RegisterServerSkin( const char *name ) {
 		ri.Com_TheHunkMarkHasBeenMade() &&
 		ShaderHashTableExists())
 	{ //If the client is running then we can go straight into the normal registerskin func
-		return RE_RegisterSkin(name);
+		//SOF2 TODO
+		return RE_RegisterSkin(name, 0, NULL);
 	}
 
 	gServerSkinHack = true;
-	r = RE_RegisterSkin(name);
+	//SOF2 TODO
+	r = RE_RegisterSkin(name, 0, NULL);
 	gServerSkinHack = false;
 
 	return r;
diff --git a/codemp/rd-vanilla/tr_init.cpp b/codemp/rd-vanilla/tr_init.cpp
index a5baf9f..d66a5a1 100644
--- a/codemp/rd-vanilla/tr_init.cpp
+++ b/codemp/rd-vanilla/tr_init.cpp
@@ -320,7 +320,7 @@ void R_Splash()
 		pImage = R_FindImageFile( "menu/splash", qfalse, qfalse, qfalse, GL_CLAMP);
 	}
 */
-	pImage = R_FindImageFile( "menu/splash", qfalse, qfalse, qfalse, GL_CLAMP);
+	pImage = R_FindImageFile( "gfx/menus/backdrop/pra1_sof2_logo.jpg", qfalse, qfalse, qfalse, GL_CLAMP);
 	extern void	RB_SetGL2D (void);
 	RB_SetGL2D();	
 	if (pImage )
@@ -329,12 +329,12 @@ void R_Splash()
 	}
 	GL_State(GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO);
 
-	const int width = 640;
-	const int height = 480;
-	const float x1 = 320 - width / 2;
-	const float x2 = 320 + width / 2;
-	const float y1 = 240 - height / 2;
-	const float y2 = 240 + height / 2;
+	const int width = glConfig.vidWidth;
+	const int height = glConfig.vidHeight;
+	const float x1 = 0;//320 - width / 2;
+	const float x2 = width;//320 + width / 2;
+	const float y1 = 0;//240 - height / 2;
+	const float y2 = height;//240 + height / 2;
 
 
 	qglBegin (GL_TRIANGLE_STRIP);
@@ -1081,11 +1081,11 @@ void GfxInfo_f( void )
 	Com_Printf ("multitexture: %s\n", enablestrings[qglActiveTextureARB != 0] );
 	Com_Printf ("compiled vertex arrays: %s\n", enablestrings[qglLockArraysEXT != 0 ] );
 	Com_Printf ("texenv add: %s\n", enablestrings[glConfig.textureEnvAddAvailable != 0] );
-	Com_Printf ("compressed textures: %s\n", enablestrings[glConfig.textureCompression != TC_NONE] );
-	Com_Printf ("compressed lightmaps: %s\n", enablestrings[(r_ext_compressed_lightmaps->integer != 0 && glConfig.textureCompression != TC_NONE)] );
-	Com_Printf ("texture compression method: %s\n", tc_table[glConfig.textureCompression] );
-	Com_Printf ("anisotropic filtering: %s  ", enablestrings[(r_ext_texture_filter_anisotropic->integer != 0) && glConfig.maxTextureFilterAnisotropy] );
-		Com_Printf ("(%f of %f)\n", r_ext_texture_filter_anisotropic->value, glConfig.maxTextureFilterAnisotropy );
+	//Com_Printf ("compressed textures: %s\n", enablestrings[glConfig.textureCompression != TC_NONE] );
+	//Com_Printf ("compressed lightmaps: %s\n", enablestrings[(r_ext_compressed_lightmaps->integer != 0 && glConfig.textureCompression != TC_NONE)] );
+	//Com_Printf ("texture compression method: %s\n", tc_table[glConfig.textureCompression] );
+	//Com_Printf ("anisotropic filtering: %s  ", enablestrings[(r_ext_texture_filter_anisotropic->integer != 0) && glConfig.maxTextureFilterAnisotropy] );
+	//	Com_Printf ("(%f of %f)\n", r_ext_texture_filter_anisotropic->value, glConfig.maxTextureFilterAnisotropy );
 	Com_Printf ("Dynamic Glow: %s\n", enablestrings[r_DynamicGlow->integer] );
 	if (g_bTextureRectangleHack) Com_Printf ("Dynamic Glow ATI BAD DRIVER HACK %s\n", enablestrings[g_bTextureRectangleHack] );
 
@@ -1305,7 +1305,7 @@ void R_Init( void ) {
 	int i;
 	byte *ptr;
 
-//	Com_Printf ("----- R_Init -----\n" );
+	Com_Printf ("----- R_Init -----\n" );
 	// clear all our internal state
 	memset( &tr, 0, sizeof( tr ) );
 	memset( &backEnd, 0, sizeof( backEnd ) );
@@ -1377,6 +1377,9 @@ void R_Init( void ) {
 	R_InitImages();
 	R_InitShaders(qfalse);
 	R_InitSkins();
+#ifdef _G2_GORE
+	G2API_InitGore();
+#endif
 
 	R_TerrainInit(); //rwwRMG - added
 
@@ -1392,7 +1395,7 @@ void R_Init( void ) {
 	if ( err != GL_NO_ERROR )
 		Com_Printf ( "glGetError() = 0x%x\n", err);
 
-//	Com_Printf ("----- finished R_Init -----\n" );
+	Com_Printf ("----- finished R_Init -----\n" );
 }
 
 /*
@@ -1605,11 +1608,8 @@ Q_EXPORT refexport_t* QDECL GetRefAPI( int apiVersion, refimport_t *rimp ) {
 
 	re.RegisterFont							= RE_RegisterFont;
 	re.Font_StrLenPixels					= RE_Font_StrLenPixels;
-	re.Font_StrLenChars						= RE_Font_StrLenChars;
 	re.Font_HeightPixels					= RE_Font_HeightPixels;
 	re.Font_DrawString						= RE_Font_DrawString;
-	re.Language_IsAsian						= Language_IsAsian;
-	re.Language_UsesSpaces					= Language_UsesSpaces;
 	re.AnyLanguage_ReadCharFromString		= AnyLanguage_ReadCharFromString;
 
 	re.RemapShader							= R_RemapShader;
@@ -1680,7 +1680,6 @@ Q_EXPORT refexport_t* QDECL GetRefAPI( int apiVersion, refimport_t *rimp ) {
 	re.G2API_GetSurfaceName					= G2API_GetSurfaceName;
 	re.G2API_GetSurfaceOnOff				= G2API_GetSurfaceOnOff;
 	re.G2API_GetSurfaceRenderStatus			= G2API_GetSurfaceRenderStatus;
-	re.G2API_GetTime						= G2API_GetTime;
 	re.G2API_Ghoul2Size						= G2API_Ghoul2Size;
 	re.G2API_GiveMeVectorFromMatrix			= G2API_GiveMeVectorFromMatrix;
 	re.G2API_HasGhoul2ModelOnIndex			= G2API_HasGhoul2ModelOnIndex;
@@ -1724,18 +1723,18 @@ Q_EXPORT refexport_t* QDECL GetRefAPI( int apiVersion, refimport_t *rimp ) {
 	re.G2API_SetShader						= G2API_SetShader;
 	re.G2API_SetSkin						= G2API_SetSkin;
 	re.G2API_SetSurfaceOnOff				= G2API_SetSurfaceOnOff;
-	re.G2API_SetTime						= G2API_SetTime;
 	re.G2API_SkinlessModel					= G2API_SkinlessModel;
 	re.G2API_StopBoneAngles					= G2API_StopBoneAngles;
 	re.G2API_StopBoneAnglesIndex			= G2API_StopBoneAnglesIndex;
 	re.G2API_StopBoneAnim					= G2API_StopBoneAnim;
 	re.G2API_StopBoneAnimIndex				= G2API_StopBoneAnimIndex;
+	re.G2API_GetBoltIndex					= G2API_GetBoltIndex;
 
 	#ifdef _G2_GORE
 	re.G2API_GetNumGoreMarks				= G2API_GetNumGoreMarks;
 	re.G2API_AddSkinGore					= G2API_AddSkinGore;
 	re.G2API_ClearSkinGore					= G2API_ClearSkinGore;
-	#endif // _SOF2
+	#endif // _G2_GORE
 
 	// RMG / Terrain stuff
 	re.LoadDataImage						= R_LoadDataImage;
diff --git a/codemp/rd-vanilla/tr_light.cpp b/codemp/rd-vanilla/tr_light.cpp
index 019aa18..ec119bc 100644
--- a/codemp/rd-vanilla/tr_light.cpp
+++ b/codemp/rd-vanilla/tr_light.cpp
@@ -335,24 +335,6 @@ void R_SetupEntityLighting( const trRefdef_t *refdef, trRefEntity_t *ent ) {
 		ent->ambientLight[2] += tr.identityLight * 32;
 	}
 
-	if (ent->e.renderfx & RF_MINLIGHT)
-	{ //the minlight flag is now for items rotating on their holo thing
-		if (ent->e.shaderRGBA[0] == 255 &&
-			ent->e.shaderRGBA[1] == 255 &&
-			ent->e.shaderRGBA[2] == 0)
-		{
-			ent->ambientLight[0] += tr.identityLight * 255;
-			ent->ambientLight[1] += tr.identityLight * 255;
-			ent->ambientLight[2] += tr.identityLight * 0;
-		}
-		else
-		{
-			ent->ambientLight[0] += tr.identityLight * 16;
-			ent->ambientLight[1] += tr.identityLight * 96;
-			ent->ambientLight[2] += tr.identityLight * 150;
-		}
-	}
-
 	//
 	// modify the light by dynamic lights
 	//
diff --git a/codemp/rd-vanilla/tr_local.h b/codemp/rd-vanilla/tr_local.h
index 1d49f48..6a7431f 100644
--- a/codemp/rd-vanilla/tr_local.h
+++ b/codemp/rd-vanilla/tr_local.h
@@ -21,7 +21,8 @@ inline long myftol( float f );
 
 // 14 bits
 // see QSORT_SHADERNUM_SHIFT
-#define	MAX_SHADERS				16384
+#define SHADERNUM_BITS        14
+#define MAX_SHADERS                (1<<SHADERNUM_BITS)
 // can't be increased without changing bit packing for drawsurfs
 
 #define MAX_SHADER_STATES 2048
@@ -472,6 +473,10 @@ typedef struct shader_s {
 
   int shaderStates[MAX_STATES_PER_SHADER];          // index to valid shader states
 */
+	char		hitMaterial[MAX_QPATH];
+	char		hitLocation[MAX_QPATH];
+	int			damage;
+	int			damageShaderNum;
 
 	struct shader_s *remappedShader;                  // current shader this one is remapped too
 	struct	shader_s	*next;
@@ -937,14 +942,17 @@ compared quickly during the qsorting process
 
 the bits are allocated as follows:
 
-18-31 : sorted shader index
-7-17  : entity index
+17-31 : sorted shader index
+7-16  : entity index
 2-6   : fog index
 0-1   : dlightmap index
 */
-#define	QSORT_SHADERNUM_SHIFT	18
-#define	QSORT_ENTITYNUM_SHIFT	7
 #define	QSORT_FOGNUM_SHIFT		2
+#define	QSORT_ENTITYNUM_SHIFT	7
+#define	QSORT_SHADERNUM_SHIFT	(QSORT_ENTITYNUM_SHIFT+GENTITYNUM_BITS)
+#if (QSORT_SHADERNUM_SHIFT+SHADERNUM_BITS) > 32
+        #error "Need to update sorting, too many bits."
+#endif
 
 extern	int			gl_filter_min, gl_filter_max;
 
@@ -1000,7 +1008,6 @@ typedef struct {
 	viewParms_t	viewParms;
 	orientationr_t	ori;		// Can't use or as it is a c++ reserved word DREWS 2/2/2002
 	backEndCounters_t	pc;
-	qboolean	isHyperspace;
 	trRefEntity_t	*currentEntity;
 	qboolean	skyRenderedThisView;	// flag for drawing sun
 
@@ -1402,7 +1409,7 @@ void		RE_SetWorldVisData( const byte *vis );
 
 qhandle_t	RE_RegisterServerModel( const char *name );
 qhandle_t	RE_RegisterModel( const char *name );
-qhandle_t	RE_RegisterSkin( const char *name );
+qhandle_t	RE_RegisterSkin( const char *name, int numPairs, char *skinPairs );
 void		RE_Shutdown( qboolean destroyWindow );
 
 void		RE_RegisterMedia_LevelLoadBegin(const char *psMapName, ForceReload_e eForceReload);
@@ -1795,8 +1802,8 @@ void	RB_CalcColorFromOneMinusEntity( unsigned char *dstColors );
 void	RB_CalcSpecularAlpha( unsigned char *alphas );
 void	RB_CalcDisintegrateColors( unsigned char *colors );
 void	RB_CalcDiffuseColor( unsigned char *colors );
-void	RB_CalcDiffuseEntityColor( unsigned char *colors );
-void	RB_CalcDisintegrateVertDeform( void );
+//void	RB_CalcDiffuseEntityColor( unsigned char *colors );
+//void	RB_CalcDisintegrateVertDeform( void );
 
 /*
 =============================================================
diff --git a/codemp/rd-vanilla/tr_main.cpp b/codemp/rd-vanilla/tr_main.cpp
index 2d586cb..f2f3e77 100644
--- a/codemp/rd-vanilla/tr_main.cpp
+++ b/codemp/rd-vanilla/tr_main.cpp
@@ -403,14 +403,14 @@ static void SetFarClip( void )
 	// if not rendering the world (icons, menus, etc)
 	// set a 2k far clip plane
 	if ( tr.refdef.rdflags & RDF_NOWORLDMODEL ) {
-		if (tr.refdef.rdflags & RDF_AUTOMAP)
+		/*if (tr.refdef.rdflags & RDF_AUTOMAP)
 		{ //override the zfar then
 			tr.viewParms.zFar = 32768.0f;
 		}
 		else
-		{
+		{*/
 			tr.viewParms.zFar = 2048.0f;
-		}
+		//}
 		return;
 	}
 
@@ -1224,15 +1224,6 @@ void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader,
 				   int fogIndex, int dlightMap ) {
 	int			index;
 
-	if (tr.refdef.rdflags & RDF_NOFOG)
-	{
-		fogIndex = 0;
-	}
-	else
-	{
-		fogIndex = fogIndex;
-	}
-
 	// instead of checking for overflow, we just mask the index
 	// so it wraps around
 	index = tr.refdef.numDrawSurfs & DRAWSURF_MASK;
@@ -1253,7 +1244,7 @@ void R_DecomposeSort( unsigned sort, int *entityNum, shader_t **shader,
 					 int *fogNum, int *dlightMap ) {
 	*fogNum = ( sort >> QSORT_FOGNUM_SHIFT ) & 31;
 	*shader = tr.sortedShaders[ ( sort >> QSORT_SHADERNUM_SHIFT ) & (MAX_SHADERS-1) ];
-	*entityNum = ( sort >> QSORT_ENTITYNUM_SHIFT ) & (MAX_ENTITIES-1);
+	*entityNum = ( sort >> QSORT_ENTITYNUM_SHIFT ) & (MAX_GENTITIES-1);
 	*dlightMap = sort & 3;
 }
 
@@ -1358,7 +1349,6 @@ void R_AddEntitySurfaces (void) {
 		case RT_LINE:
 		case RT_ORIENTEDLINE:
 		case RT_CYLINDER:
-		case RT_SABER_GLOW:
 			// self blood sprites, talk balloons, etc should not be drawn in the primary
 			// view.  We can't just do this check for all entities, because md3
 			// entities may still want to cast shadows from them
@@ -1395,13 +1385,13 @@ Ghoul2 Insert Start
 					}
   					break;
 				case MOD_BAD:		// null model axis
-					if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal)
+					/*if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal)
 					{
 						if (!(ent->e.renderfx & RF_SHADOW_ONLY))
 						{
 							break;
 						}
-					}
+					}*/
 
   					if (ent->e.ghoul2 && G2API_HaveWeGhoul2Models(*((CGhoul2Info_v *)ent->e.ghoul2)))
   					{
diff --git a/codemp/rd-vanilla/tr_model.cpp b/codemp/rd-vanilla/tr_model.cpp
index 7599856..a8621c9 100644
--- a/codemp/rd-vanilla/tr_model.cpp
+++ b/codemp/rd-vanilla/tr_model.cpp
@@ -856,7 +856,7 @@ qboolean ServerLoadMDXM( model_t *mod, void *buffer, const char *mod_name, qbool
 	}
 		
 	// first up, go load in the animation file we need that has the skeletal animation info for this model
-	mdxm->animIndex = RE_RegisterServerModel(va ("%s.gla",mdxm->animName));
+	mdxm->animIndex = RE_RegisterServerModel(va ("%s_mp.gla",mdxm->animName));
 	if (!mdxm->animIndex) 
 	{
 		return qfalse;
@@ -1200,6 +1200,10 @@ Ghoul2 Insert Start
 	//
 	for (mh=mhHashTable[hash]; mh; mh=mh->next) {
 		if (Q_stricmp(mh->name, name) == 0) {
+			if (tr.models[mh->handle]->type == MOD_BAD)
+			{
+				return 0;
+			}
 			return mh->handle;
 		}
 	}
@@ -1235,7 +1239,7 @@ Ghoul2 Insert Start
 
 	if (name[0] == '*')
 	{	// don't create a bad model for a bsp model
-		if (Q_stricmp(name, "*default.gla"))
+		if (Q_stricmp(name, "*default_mp.gla"))
 		{
 			return 0;
 		}
@@ -1256,7 +1260,7 @@ Ghoul2 Insert End
 	Q_strncpyz( mod->name, name, sizeof( mod->name ) );
 
 	// make sure the render thread is stopped
-	R_SyncRenderThread();
+	//R_SyncRenderThread();
 
 	int iLODStart = 0;
 	if (strstr (name, ".md3")) {
@@ -1359,14 +1363,14 @@ Ghoul2 Insert Start
 */
 
 #ifdef _DEBUG
-	if (r_noPrecacheGLA && r_noPrecacheGLA->integer && ident == MDXA_IDENT)
-	{ //I expect this will cause leaks, but I don't care because it's a debugging utility.
-		return mod->index;
-	}
+		if (r_noPrecacheGLA && r_noPrecacheGLA->integer && ident == MDXA_IDENT)
+		{ //I expect this will cause leaks, but I don't care because it's a debugging utility.
+			return mod->index;
+		}
 #endif
 
-	RE_InsertModelIntoHash(name, mod);
-	return mod->index;
+		RE_InsertModelIntoHash(name, mod);
+		return mod->index;
 /*
 Ghoul2 Insert End
 */
diff --git a/codemp/rd-vanilla/tr_scene.cpp b/codemp/rd-vanilla/tr_scene.cpp
index 86ae183..3d5cb3f 100644
--- a/codemp/rd-vanilla/tr_scene.cpp
+++ b/codemp/rd-vanilla/tr_scene.cpp
@@ -212,7 +212,7 @@ void RE_AddRefEntityToScene( const refEntity_t *ent ) {
 #ifdef _DEBUG
 	if (ent->reType == RT_MODEL)
 	{
-		assert(ent->hModel || ent->ghoul2 || ent->customShader);
+		assert(ent->hModel || ent->ghoul2 || ent->customShader || ent->renderfx);
 	}
 #endif
 
@@ -747,7 +747,7 @@ void RE_RenderScene( const refdef_t *fd ) {
 	tr.refdef.frametime = fd->time - lastTime;
 	lastTime = fd->time;
 
-	if (fd->rdflags & RDF_SKYBOXPORTAL)
+	/*if (fd->rdflags & RDF_SKYBOXPORTAL)
 	{
 		skyboxportal = 1;
 	}
@@ -757,9 +757,9 @@ void RE_RenderScene( const refdef_t *fd ) {
 		drawskyboxportal = 1;
 	}
 	else
-	{
+	{*/
 		drawskyboxportal = 0;
-	}
+	//}
 
 	if (tr.refdef.frametime > 500)
 	{
@@ -873,10 +873,10 @@ void RE_RenderScene( const refdef_t *fd ) {
 
 	RE_RenderWorldEffects();
 
-	if (tr.refdef.rdflags & RDF_AUTOMAP)
+	/*if (tr.refdef.rdflags & RDF_AUTOMAP)
 	{
 		RE_RenderAutoMap();
-	}
+	}*/
 }
 
 #if 0 //rwwFIXMEFIXME: Disable this before release!!!!!! I am just trying to find a crash bug.
diff --git a/codemp/rd-vanilla/tr_shade.cpp b/codemp/rd-vanilla/tr_shade.cpp
index 65dd206..0f4d527 100644
--- a/codemp/rd-vanilla/tr_shade.cpp
+++ b/codemp/rd-vanilla/tr_shade.cpp
@@ -232,12 +232,12 @@ void R_BindAnimatedImage( textureBundle_t *bundle ) {
 		return;
 	}
 
-	if (backEnd.currentEntity->e.renderfx & RF_SETANIMINDEX )
+	/*if (backEnd.currentEntity->e.renderfx & RF_SETANIMINDEX )
 	{
 		index = backEnd.currentEntity->e.skinNum;
 	}
 	else
-	{
+	{*/
 		// it is necessary to do this messy calc to make sure animations line up
 		// exactly with waveforms of the same frequency
 		index = myftol( tess.shaderTime * bundle->imageAnimationSpeed * FUNCTABLE_SIZE );
@@ -246,7 +246,7 @@ void R_BindAnimatedImage( textureBundle_t *bundle ) {
 		if ( index < 0 ) {
 			index = 0;	// may happen with shader time offsets
 		}
-	}
+	//}
 
 	if ( bundle->oneShotAnimMap )
 	{
@@ -710,6 +710,16 @@ static void ProjectDlightTexture2( void ) {
 			fogging = 0;
 		}
 
+		if (!needResetVerts)
+		{
+			needResetVerts=1;
+			if (qglUnlockArraysEXT) 
+			{
+				qglUnlockArraysEXT();
+				GLimp_LogComment( "glUnlockArraysEXT\n" );
+			}
+		}
+		qglVertexPointer (3, GL_FLOAT, 16, vertCoordsArray);	// padded for SIMD
 
 		dStage = NULL;
 		if (tess.shader && qglActiveTextureARB)
@@ -728,16 +738,7 @@ static void ProjectDlightTexture2( void ) {
 				i++;
 			}
 		}
-		if (!needResetVerts)
-		{
-			needResetVerts=1;
-			if (qglUnlockArraysEXT) 
-			{
-				qglUnlockArraysEXT();
-				GLimp_LogComment( "glUnlockArraysEXT\n" );
-			}
-		}
-		qglVertexPointer (3, GL_FLOAT, 16, vertCoordsArray);	// padded for SIMD
+
 
 		if (dStage)
 		{
@@ -781,12 +782,12 @@ static void ProjectDlightTexture2( void ) {
 			GL_Bind( tr.dlightImage );
 			// include GLS_DEPTHFUNC_EQUAL so alpha tested surfaces don't add light
 			// where they aren't rendered
-			if ( dl->additive ) {
-				GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
-			}
-			else {
+			//if ( dl->additive ) {
+			//	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+			//}
+			//else {
 				GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
-			}
+			//}
 
 			R_DrawElements( numIndexes, hitIndexes );
 		}
@@ -1122,12 +1123,12 @@ static void ProjectDlightTexture( void ) {
 			GL_Bind( tr.dlightImage );
 			// include GLS_DEPTHFUNC_EQUAL so alpha tested surfaces don't add light
 			// where they aren't rendered
-			if ( dl->additive ) {
-				GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
-			}
-			else {
+			//if ( dl->additive ) {
+			//	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+			//}
+			//else {
 				GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
-			}
+			//}
 
 			R_DrawElements( numIndexes, hitIndexes );
 		}
@@ -1194,15 +1195,15 @@ static void ComputeColors( shaderStage_t *pStage, int forceRGBGen )
 	qboolean killGen = qfalse;
 	alphaGen_t forceAlphaGen = pStage->alphaGen;//set this up so we can override below
 
-	if ( tess.shader != tr.projectionShadowShader && tess.shader != tr.shadowShader && 
-			( backEnd.currentEntity->e.renderfx & (RF_DISINTEGRATE1|RF_DISINTEGRATE2)))
-	{
-		RB_CalcDisintegrateColors( (unsigned char *)tess.svars.colors );
-		RB_CalcDisintegrateVertDeform();
+	//if ( tess.shader != tr.projectionShadowShader && tess.shader != tr.shadowShader && 
+	//		( backEnd.currentEntity->e.renderfx & (RF_DISINTEGRATE1|RF_DISINTEGRATE2)))
+	//{
+		/*RB_CalcDisintegrateColors( (unsigned char *)tess.svars.colors );
+		RB_CalcDisintegrateVertDeform();*/
 
 		// We've done some custom alpha and color stuff, so we can skip the rest.  Let it do fog though
-		killGen = qtrue;
-	}
+	//	killGen = qtrue;
+	//}
 
 	//
 	// rgbGen
@@ -1212,7 +1213,7 @@ static void ComputeColors( shaderStage_t *pStage, int forceRGBGen )
 		forceRGBGen = pStage->rgbGen;
 	}
 
-	if ( backEnd.currentEntity->e.renderfx & RF_VOLUMETRIC ) // does not work for rotated models, technically, this should also be a CGEN type, but that would entail adding new shader commands....which is too much work for one thing
+	/*if ( backEnd.currentEntity->e.renderfx & RF_VOLUMETRIC ) // does not work for rotated models, technically, this should also be a CGEN type, but that would entail adding new shader commands....which is too much work for one thing
 	{
 		int			i;
 		float		*normal, dot;
@@ -1239,7 +1240,7 @@ static void ComputeColors( shaderStage_t *pStage, int forceRGBGen )
 		}
 
 		killGen = qtrue;
-	}
+	}*/
 
 	if (killGen)
 	{
@@ -1261,7 +1262,7 @@ static void ComputeColors( shaderStage_t *pStage, int forceRGBGen )
 		case CGEN_LIGHTING_DIFFUSE:
 			RB_CalcDiffuseColor( ( unsigned char * ) tess.svars.colors );
 			break;
-		case CGEN_LIGHTING_DIFFUSE_ENTITY:
+		/*case CGEN_LIGHTING_DIFFUSE_ENTITY:
 			RB_CalcDiffuseEntityColor( ( unsigned char * ) tess.svars.colors );
 			if ( forceAlphaGen == AGEN_IDENTITY && 
 				 backEnd.currentEntity->e.shaderRGBA[3] == 0xff 
@@ -1269,7 +1270,7 @@ static void ComputeColors( shaderStage_t *pStage, int forceRGBGen )
 			{
 				forceAlphaGen = AGEN_SKIP;	//already got it in this set since it does all 4 components
 			}
-			break;
+			break;*/
 		case CGEN_EXACT_VERTEX:
 			memcpy( tess.svars.colors, tess.vertexColors, tess.numVertexes * sizeof( tess.vertexColors[0] ) );
 			break;
@@ -1692,7 +1693,7 @@ static void RB_IterateStagesGeneric( shaderCommands_t *input )
 
 		stateBits = pStage->stateBits;
 
-		if ( backEnd.currentEntity )
+		/*if ( backEnd.currentEntity )
 		{
 			assert(backEnd.currentEntity->e.renderfx >= 0);
 
@@ -1706,7 +1707,7 @@ static void RB_IterateStagesGeneric( shaderCommands_t *input )
 			{//want to use RGBGen from ent
 				forceRGBGen = CGEN_ENTITY;
 			}
-		}
+		}*/
 
 		if (pStage->ss && pStage->ss->surfaceSpriteType)
 		{
@@ -1812,14 +1813,14 @@ static void RB_IterateStagesGeneric( shaderCommands_t *input )
 			//
 			// set state
 			//
-			if ( (tess.shader == tr.distortionShader) || 
+			/*if ( (tess.shader == tr.distortionShader) || 
 				 (backEnd.currentEntity && (backEnd.currentEntity->e.renderfx & RF_DISTORTION)) )
 			{ //special distortion effect -rww
 				//tr.screenImage should have been set for this specific entity before we got in here.
 				GL_Bind( tr.screenImage );
 				GL_Cull(CT_TWO_SIDED);
 			}
-			else if ( pStage->bundle[0].vertexLightmap && ( r_vertexLight->integer && !r_uiFullScreen->integer ) && r_lightmap->integer )
+			else*/ if ( pStage->bundle[0].vertexLightmap && ( r_vertexLight->integer && !r_uiFullScreen->integer ) && r_lightmap->integer )
 			{
 				GL_Bind( tr.whiteImage );
 			}
@@ -1839,7 +1840,7 @@ static void RB_IterateStagesGeneric( shaderCommands_t *input )
 				//don't depthmask, don't blend.. don't do anything
 				GL_State(0);
 			}
-			else if (backEnd.currentEntity && (backEnd.currentEntity->e.renderfx & RF_FORCE_ENT_ALPHA))
+			/*else if (backEnd.currentEntity && (backEnd.currentEntity->e.renderfx & RF_FORCE_ENT_ALPHA))
 			{
 				ForceAlpha((unsigned char *) tess.svars.colors, backEnd.currentEntity->e.shaderRGBA[3]);
 				if (backEnd.currentEntity->e.renderfx & RF_ALPHA_DEPTH)
@@ -1851,7 +1852,7 @@ static void RB_IterateStagesGeneric( shaderCommands_t *input )
 				{
 					GL_State(GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA);
 				}
-			}
+			}*/
 			else
 			{
 				GL_State( stateBits );
@@ -2064,7 +2065,7 @@ void RB_EndSurface( void ) {
 		return;
 	}
 
-	if ( skyboxportal )
+	/*if ( skyboxportal )
 	{
 		// world
 		if(!(backEnd.refdef.rdflags & RDF_SKYBOXPORTAL)) 
@@ -2085,7 +2086,7 @@ void RB_EndSurface( void ) {
 				}
 			}
 		}
-	}
+	}*/
 
 	//
 	// update performance counters
diff --git a/codemp/rd-vanilla/tr_shade_calc.cpp b/codemp/rd-vanilla/tr_shade_calc.cpp
index 15ff372..52b0e1d 100644
--- a/codemp/rd-vanilla/tr_shade_calc.cpp
+++ b/codemp/rd-vanilla/tr_shade_calc.cpp
@@ -1257,7 +1257,7 @@ void RB_CalcDiffuseEntityColor( unsigned char *colors )
 }
 
 //---------------------------------------------------------
-void RB_CalcDisintegrateColors( unsigned char *colors )
+/*void RB_CalcDisintegrateColors( unsigned char *colors )
 {
 	int			i, numVertexes;
 	float		dis, threshold;
@@ -1348,10 +1348,10 @@ void RB_CalcDisintegrateColors( unsigned char *colors )
 			}
 		}
 	}
-}
+}*/
 
 //---------------------------------------------------------
-void RB_CalcDisintegrateVertDeform( void )
+/*void RB_CalcDisintegrateVertDeform( void )
 {
 	float	*xyz = ( float * ) tess.xyz;
 	float	*normal = ( float * ) tess.normal;
@@ -1383,3 +1383,4 @@ void RB_CalcDisintegrateVertDeform( void )
 		}
 	}
 }
+*/
\ No newline at end of file
diff --git a/codemp/rd-vanilla/tr_shader.cpp b/codemp/rd-vanilla/tr_shader.cpp
index 30e2c16..60e3b0b 100644
--- a/codemp/rd-vanilla/tr_shader.cpp
+++ b/codemp/rd-vanilla/tr_shader.cpp
@@ -5,7 +5,7 @@
 
 // tr_shader.c -- this file deals with the parsing and definition of shaders
 
-#define USE_NEW_SHADER_HASH
+//#define USE_NEW_SHADER_HASH
 
 
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -358,7 +358,7 @@ static void Shader_SkipRestOfLine ( const char **data ) {
 #define Shader_GetCurrentParseLine COM_GetCurrentParseLine
 #define Shader_Parse COM_Parse
 #define Shader_Shader_SkipWhitespace SkipWhitespace
-#define Shader_Compress COM_Comress
+#define Shader_Compress COM_Compress
 #define Shader_ParseExt COM_ParseExt
 #define Shader_SkipBracedSection SkipBracedSection
 #define Shader_SkipRestOfLine SkipRestOfLine
@@ -2754,6 +2754,76 @@ static qboolean ParseShader( const char **text )
 			ParseSort( text );
 			continue;
 		}
+/*
+Ghoul2 Insert Start
+*/
+
+		// 
+		// location hit mesh load
+		//
+		else if ( !Q_stricmp( token, "hitLocation" ) )
+		{
+		   
+			// grab the filename of the hit location texture
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 )
+				break;
+			Q_strncpyz(shader.hitLocation, token, MAX_QPATH);
+			continue;
+		}
+		// 
+		// location hit material mesh load
+		//
+		else if ( !Q_stricmp( token, "hitMaterial" ) )
+		{
+
+			// grab the filename of the hit location texture
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 )
+				break;
+			Q_strncpyz(shader.hitMaterial, token, MAX_QPATH);
+			continue;
+
+		}
+		//
+		// damage shader
+		//
+		else if ( !Q_stricmp( token, "damageShader" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( !token[0] )
+			{
+				Com_Printf( S_COLOR_YELLOW "WARNING: missing param for 'damageShader' keyword in shader '%s'\n", shader.name );
+				continue;
+			}
+
+			//SOF2 TODO
+			/*CCMShader *damageShader = CM_GetShaderInfo(token);
+			if(damageShader)
+			{
+				shader.damageShaderNum = damageShader - cm.shaders;
+			}*/
+
+			token = COM_ParseExt( text, qfalse );
+			if (token)
+			{
+				shader.damage = atof(token);
+			}
+			continue;
+		}
+		//
+		// alias shader
+		//
+		else if ( !Q_stricmp( token, "aliasShader" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 )
+				break;
+			//SOF2 TODO
+		}
+/*
+Ghoul2 Insert End
+*/
 		else
 		{
 			Com_Printf (S_COLOR_YELLOW  "WARNING: unknown general shader parameter '%s' in '%s'\n", token, shader.name );
@@ -3131,7 +3201,6 @@ what it is supposed to look like.
   OUTPUT:  Number of stages after the collapse (in the case of surfacesprites this isn't one).
 =================
 */
-//rww - no longer used, at least for now. destroys alpha shaders completely.
 #if 0
 static int VertexLightingCollapse( void ) {
 	int		stage, nextopenstage;
@@ -3169,7 +3238,7 @@ static int VertexLightingCollapse( void ) {
 			}
 
 			// SurfaceSprites are most certainly NOT desireable as the collapsed surface texture.
-			if ( pStage->ss && pstage->ss->surfaceSpriteType)
+			if ( pStage->ss && pStage->ss->surfaceSpriteType)
 			{
 				rank -= 1000;
 			}
@@ -3216,7 +3285,7 @@ static int VertexLightingCollapse( void ) {
 			break;
 		}
 
-		if ( pStage->ss && pstage->ss->surfaceSpriteType)
+		if ( pStage->ss && pStage->ss->surfaceSpriteType)
 		{
 			// Copy this stage to the next open stage list (that is, we don't want any inactive stages before this one)
 			if (nextopenstage != stage)
@@ -3527,7 +3596,6 @@ static shader_t *FinishShader( void ) {
 	//
 	if ( stage > 1 && (r_vertexLight->integer && !r_uiFullScreen->integer) ) {
 		//stage = VertexLightingCollapse();
-		//rww - since this does bad things, I am commenting it out for now. If you want to attempt a fix, feel free.
 		hasLightmapStage = qfalse;
 	}
 
@@ -3748,8 +3816,8 @@ most world construction surfaces.
 */
 shader_t *R_FindShader( const char *name, const int *lightmapIndex, const byte *styles, qboolean mipRawImage ) 
 {
-	char		strippedName[MAX_QPATH];
-	char		fileName[MAX_QPATH];
+	char		strippedName[MAX_OSPATH];
+	char		fileName[MAX_OSPATH];
 	int			hash;
 	const char	*shaderText;
 	image_t		*image;
@@ -4074,8 +4142,8 @@ For menu graphics that should never be picmiped
 qhandle_t RE_RegisterShaderNoMip( const char *name ) {
 	shader_t	*sh;
 
-	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+	if ( strlen( name ) >= MAX_OSPATH ) {
+		Com_Printf( "Shader name exceeds MAX_OSPATH\n" );
 		return 0;
 	}
 
@@ -4339,7 +4407,7 @@ static void ScanAndLoadShaderFiles( const char *path )
 		ri.Printf( PRINT_DEVELOPER, "...loading '%s'\n", filename );
 		summand = ri.FS_ReadFile( filename, (void **)&buffers[i] );
 		if ( !buffers[i] ) {
-			ri.Com_Error( ERR_DROP, "Couldn't load %s", filename );
+			Com_Error( ERR_DROP, "Couldn't load %s", filename );
 		}
 
 		// Do a simple check on the shader structure in that file to make sure one bad shader file cannot fuck up all other shaders.
@@ -4712,7 +4780,7 @@ R_InitShaders
 */
 void R_InitShaders(qboolean server)
 {
-	//Com_Printf ("Initializing Shaders\n" );
+	Com_Printf ("Initializing Shaders\n" );
 
 #if defined(USE_NEW_SHADER_HASH) && !(DEDICATED)
 	int time, mem;
diff --git a/codemp/rd-vanilla/tr_sky.cpp b/codemp/rd-vanilla/tr_sky.cpp
index ebe9e0a..b317fe3 100644
--- a/codemp/rd-vanilla/tr_sky.cpp
+++ b/codemp/rd-vanilla/tr_sky.cpp
@@ -785,10 +785,10 @@ void RB_StageIteratorSky( void )
 		return;
 	}
 
-	if (skyboxportal && !(backEnd.refdef.rdflags & RDF_SKYBOXPORTAL))
+/*	if (skyboxportal && !(backEnd.refdef.rdflags & RDF_SKYBOXPORTAL))
 	{
 		return;
-	}
+	}*/
 
 	// go through all the polygons and project them onto
 	// the sky box to see which blocks on each side need
diff --git a/codemp/rd-vanilla/tr_surface.cpp b/codemp/rd-vanilla/tr_surface.cpp
index ff6220e..2404c64 100644
--- a/codemp/rd-vanilla/tr_surface.cpp
+++ b/codemp/rd-vanilla/tr_surface.cpp
@@ -451,31 +451,6 @@ static void DoSprite( vec3_t origin, float radius, float rotation )
 	RB_AddQuadStamp( origin, left, up, backEnd.currentEntity->e.shaderRGBA );
 }
 
-//------------------
-// RB_SurfaceSaber
-//------------------
-static void RB_SurfaceSaberGlow()
-{ 
-	vec3_t		end;
-	refEntity_t *e;
-
-	e = &backEnd.currentEntity->e;
-
-	// Render the glow part of the blade
-	for ( float i = e->saberLength; i > 0; i -= e->radius * 0.65f )
-	{
-		VectorMA( e->origin, i, e->axis[0], end );
-
-		DoSprite( end, e->radius, 0.0f );//random() * 360.0f );
-		e->radius += 0.017f;
-	}
-
-	// Big hilt sprite
-	// Please don't kill me Pat...I liked the hilt glow blob, but wanted a subtle pulse.:)  Feel free to ditch it if you don't like it.  --Jeff
-	// Please don't kill me Jeff...  The pulse is good, but now I want the halo bigger if the saber is shorter...  --Pat
-	DoSprite( e->origin, 5.5f + random() * 0.25f, 0.0f );//random() * 360.0f );
-}
-
 /*
 ==============
 RB_SurfaceLine
@@ -1557,6 +1532,7 @@ RB_SurfaceAxis
 Draws x/y/z lines from the origin for orientation debugging
 ===================
 */
+#ifdef _DEBUG
 static void RB_SurfaceAxis( void ) {
 	GL_Bind( tr.whiteImage );
 	qglLineWidth( 3 );
@@ -1573,6 +1549,7 @@ static void RB_SurfaceAxis( void ) {
 	qglEnd();
 	qglLineWidth( 1 );
 }
+#endif
 
 //===========================================================================
 
@@ -1603,9 +1580,6 @@ void RB_SurfaceEntity( surfaceType_t *surfType ) {
 	case RT_ORIENTEDLINE:
 		RB_SurfaceOrientedLine();
 		break;
-	case RT_SABER_GLOW:
-		RB_SurfaceSaberGlow();
-		break;
 	case RT_CYLINDER:
 		RB_SurfaceCylinder();
 		break;
@@ -1635,7 +1609,9 @@ void RB_SurfaceEntity( surfaceType_t *surfType ) {
 		}
 		break;
 	default:
+#ifdef _DEBUG
 		RB_SurfaceAxis();
+#endif
 		break;
 	}
 	return;
diff --git a/codemp/rd-vanilla/tr_world.cpp b/codemp/rd-vanilla/tr_world.cpp
index d586991..ff417be 100644
--- a/codemp/rd-vanilla/tr_world.cpp
+++ b/codemp/rd-vanilla/tr_world.cpp
@@ -976,7 +976,7 @@ qboolean R_WriteWireframeMapToFile(void)
 	}
 	
 
-	f = ri.FS_FOpenFileWrite("blahblah.bla");
+	f = ri.FS_FOpenFileWrite("blahblah.bla", false);
 	if (!f)
 	{ //can't create?
 		return qfalse;
diff --git a/codemp/renderer/mdx_format.h b/codemp/renderer/mdx_format.h
index 2230b27..1600a7e 100644
--- a/codemp/renderer/mdx_format.h
+++ b/codemp/renderer/mdx_format.h
@@ -66,7 +66,7 @@
 #define iG2_BONEWEIGHT_TOPBITS_AND		0x300	// 2 bits, giving 10 total, or 10 bits, for 1023/1024 above
 
 
-#define sDEFAULT_GLA_NAME "*default"	// used when making special simple ghoul2 models, usually from MD3 files
+#define sDEFAULT_GLA_NAME "*default_mp"	// used when making special simple ghoul2 models, usually from MD3 files
 
 
 ////////////////////////////////////
diff --git a/codemp/renderer/tr_public.h b/codemp/renderer/tr_public.h
index 6a979bd..8ded4ca 100644
--- a/codemp/renderer/tr_public.h
+++ b/codemp/renderer/tr_public.h
@@ -29,7 +29,7 @@ typedef struct {
 	void				(*BeginRegistration)					( glconfig_t *config );
 	qhandle_t			(*RegisterModel)						( const char *name );
 	qhandle_t			(*RegisterServerModel)					( const char *name );
-	qhandle_t			(*RegisterSkin)							( const char *name );
+	qhandle_t			(*RegisterSkin)							( const char *name, int numPairs, char *skinPairs );
 	qhandle_t			(*RegisterServerSkin)					( const char *name );
 	qhandle_t			(*RegisterShader)						( const char *name );
 	qhandle_t			(*RegisterShaderNoMip)					( const char *name );
@@ -86,11 +86,8 @@ typedef struct {
 
 	qhandle_t			(*RegisterFont)							( const char *fontName );
 	int					(*Font_StrLenPixels)					( const char *text, const int iFontIndex, const float scale );
-	int					(*Font_StrLenChars)						( const char *text );
 	int					(*Font_HeightPixels)					( const int iFontIndex, const float scale );
-	void				(*Font_DrawString)						( int ox, int oy, const char *text, const float *rgba, const int setIndex, int iCharLimit, const float scale );
-	qboolean			(*Language_IsAsian)						( void );
-	qboolean			(*Language_UsesSpaces)					( void );
+	void				(*Font_DrawString)						( int x, int y, qhandle_t font, float scale, vec4_t color, const char* text, int limit, int flags, int cursorPos, char cursor );
 	unsigned int		(*AnyLanguage_ReadCharFromString)		( const char *psText, int *piAdvanceCount, qboolean *pbIsTrailingPunctuation/* = NULL*/ );
 
 	void				(*RemapShader)							( const char *oldShader, const char *newShader, const char *offsetTime );
@@ -144,7 +141,7 @@ typedef struct {
 	void				(*G2API_CollisionDetect)				( CollisionRecord_t *collRecMap, CGhoul2Info_v &ghoul2, const vec3_t angles, const vec3_t position, int frameNumber, int entNum, vec3_t rayStart, vec3_t rayEnd, vec3_t scale, CMiniHeap *G2VertSpace, int traceFlags, int useLod, float fRadius );
 	void				(*G2API_CollisionDetectCache)			( CollisionRecord_t *collRecMap, CGhoul2Info_v &ghoul2, const vec3_t angles, const vec3_t position, int frameNumber, int entNum, vec3_t rayStart, vec3_t rayEnd, vec3_t scale, CMiniHeap *G2VertSpace, int traceFlags, int useLod, float fRadius );
 	int					(*G2API_CopyGhoul2Instance)				( CGhoul2Info_v &g2From, CGhoul2Info_v &g2To, int modelIndex );
-	void				(*G2API_CopySpecificG2Model)			( CGhoul2Info_v &ghoul2From, int modelFrom, CGhoul2Info_v &ghoul2To, int modelTo );
+	int					(*G2API_CopySpecificG2Model)			( CGhoul2Info_v &ghoul2From, int modelFrom, CGhoul2Info_v &ghoul2To, int modelTo );
 	qboolean			(*G2API_DetachG2Model)					( CGhoul2Info *ghlInfo );
 	qboolean			(*G2API_DoesBoneExist)					( CGhoul2Info *ghlInfo, const char *boneName );
 	void				(*G2API_DuplicateGhoul2Instance)		( CGhoul2Info_v &g2From, CGhoul2Info_v **g2To );
@@ -163,7 +160,6 @@ typedef struct {
 	char *				(*G2API_GetSurfaceName)					( CGhoul2Info *ghlInfo, int surfNumber );
 	int					(*G2API_GetSurfaceOnOff)				( CGhoul2Info *ghlInfo, const char *surfaceName );
 	int					(*G2API_GetSurfaceRenderStatus)			( CGhoul2Info *ghlInfo, const char *surfaceName );
-	int					(*G2API_GetTime)						( int argTime );
 	int					(*G2API_Ghoul2Size)						( CGhoul2Info_v &ghoul2 );
 	void				(*G2API_GiveMeVectorFromMatrix)			( mdxaBone_t *boltMatrix, Eorientations flags, vec3_t vec );
 	qboolean			(*G2API_HasGhoul2ModelOnIndex)			( CGhoul2Info_v **ghlRemove, const int modelIndex );
@@ -201,24 +197,24 @@ typedef struct {
 	void				(*G2API_SetGhoul2ModelIndexes)			( CGhoul2Info_v &ghoul2, qhandle_t *modelList, qhandle_t *skinList );
 	qboolean			(*G2API_SetGhoul2ModelFlags)			( CGhoul2Info *ghlInfo, const int flags );
 	qboolean			(*G2API_SetLodBias)						( CGhoul2Info *ghlInfo, int lodBias );
-	qboolean			(*G2API_SetNewOrigin)					( CGhoul2Info_v &ghoul2, const int boltIndex );
+	qboolean			(*G2API_SetNewOrigin)					( CGhoul2Info_v &ghoul2, const int modelIndex, const int boltIndex );
 	void				(*G2API_SetRagDoll)						( CGhoul2Info_v &ghoul2, CRagDollParams *parms );
 	qboolean			(*G2API_SetRootSurface)					( CGhoul2Info_v &ghoul2, const int modelIndex, const char *surfaceName );
 	qboolean			(*G2API_SetShader)						( CGhoul2Info *ghlInfo, qhandle_t customShader );
 	qboolean			(*G2API_SetSkin)						( CGhoul2Info *ghlInfo, qhandle_t customSkin, qhandle_t renderSkin );
-	qboolean			(*G2API_SetSurfaceOnOff)				( CGhoul2Info_v &ghoul2, const char *surfaceName, const int flags );
-	void				(*G2API_SetTime)						( int currentTime, int clock );
+	qboolean			(*G2API_SetSurfaceOnOff)				( CGhoul2Info_v &ghoul2, const int modelIndex, const char *surfaceName, const int flags );
 	qboolean			(*G2API_SkinlessModel)					( CGhoul2Info *g2 );
 	qboolean			(*G2API_StopBoneAngles)					( CGhoul2Info *ghlInfo, const char *boneName );
 	qboolean			(*G2API_StopBoneAnglesIndex)			( CGhoul2Info *ghlInfo, const int index );
 	qboolean			(*G2API_StopBoneAnim)					( CGhoul2Info *ghlInfo, const char *boneName );
 	qboolean			(*G2API_StopBoneAnimIndex)				( CGhoul2Info *ghlInfo, const int index );
+	int					(*G2API_GetBoltIndex)					( CGhoul2Info *ghlInfo, const int modelIndex);
 
 	#ifdef _G2_GORE
 	int					(*G2API_GetNumGoreMarks)				( CGhoul2Info *g2 );
 	void				(*G2API_AddSkinGore)					( CGhoul2Info_v &ghoul2, SSkinGoreData &gore );
 	void				(*G2API_ClearSkinGore)					( CGhoul2Info_v &ghoul2 );
-	#endif // _SOF2
+	#endif // _G2_GORE
 
 	// RMG / Terrain stuff
 	void				(*LoadDataImage)						( const char *name, byte **pic, int *width, int *height );
@@ -264,14 +260,13 @@ typedef struct {
 	float			(*Cvar_VariableValue)				( const char *var_name );
 	int				(*Cvar_VariableIntegerValue)		( const char *var_name );
 	qboolean		(*Sys_LowPhysicalMemory)			( void );
-	const char *	(*SE_GetString)						( const char * psPackageAndStringReference );
 	void			(*FS_FreeFile)						( void *buffer );
 	void			(*FS_FreeFileList)					( char **fileList );
 	int				(*FS_Read)							( void *buffer, int len, fileHandle_t f );
 	int				(*FS_ReadFile)						( const char *qpath, void **buffer );
 	void			(*FS_FCloseFile)					( fileHandle_t f );
 	int				(*FS_FOpenFileRead)					( const char *qpath, fileHandle_t *file, qboolean uniqueFILE );
-	fileHandle_t	(*FS_FOpenFileWrite)				( const char *qpath );
+	fileHandle_t	(*FS_FOpenFileWrite)				( const char *qpath, const bool astext );
 	int				(*FS_FOpenFileByMode)				( const char *qpath, fileHandle_t *f, fsMode_t mode );
 	qboolean		(*FS_FileExists)					( const char *file );
 	int				(*FS_FileIsInPAK)					( const char *filename, int *pChecksum );
diff --git a/codemp/renderer/tr_types.h b/codemp/renderer/tr_types.h
index 949f0d5..e2f6245 100644
--- a/codemp/renderer/tr_types.h
+++ b/codemp/renderer/tr_types.h
@@ -5,62 +5,62 @@
 
 
 #define	MAX_DLIGHTS		32			// can't be increased, because bit flags are used on surfaces
-#define	MAX_ENTITIES	2048		// 11 bits, can't be increased without changing drawsurf bit packing (QSORT_ENTITYNUM_SHIFT)
+#define	MAX_ENTITIES	1023		// 11 bits, can't be increased without changing drawsurf bit packing (QSORT_ENTITYNUM_SHIFT)
 #define	MAX_MINI_ENTITIES	1024		
 
 #define	TR_WORLDENT		(MAX_ENTITIES-1)
 
 // renderfx flags
-#define	RF_MINLIGHT			0x00001	// allways have some light (viewmodel, some items)
-#define	RF_THIRD_PERSON		0x00002	// don't draw through eyes, only mirrors (player bodies, chat sprites)
-#define	RF_FIRST_PERSON		0x00004	// only draw through eyes (view weapon, damage blood blob)
-#define	RF_DEPTHHACK		0x00008	// for view weapon Z crunching
-#define RF_NODEPTH			0x00010	// No depth at all (seeing through walls)
+#define	RF_MINLIGHT			1	// allways have some light (viewmodel, some items)
+#define	RF_THIRD_PERSON		2	// don't draw through eyes, only mirrors (player bodies, chat sprites)
+#define	RF_FIRST_PERSON		4	// only draw through eyes (view weapon, damage blood blob)
+#define	RF_DEPTHHACK		8	// for view weapon Z crunching
+//#define RF_NODEPTH			0x00010	// No depth at all (seeing through walls)
 
-#define RF_VOLUMETRIC		0x00020	// fake volumetric shading
+//#define RF_VOLUMETRIC		0x00020	// fake volumetric shading
 
-#define	RF_NOSHADOW			0x00040	// don't add stencil shadows
+#define	RF_NOSHADOW			64	// don't add stencil shadows
 
-#define RF_LIGHTING_ORIGIN	0x00080	// use refEntity->lightingOrigin instead of refEntity->origin
+#define RF_LIGHTING_ORIGIN	128	// use refEntity->lightingOrigin instead of refEntity->origin
 									// for lighting.  This allows entities to sink into the floor
 									// with their origin going solid, and allows all parts of a
 									// player to get the same lighting
-#define	RF_SHADOW_PLANE		0x00100	// use refEntity->shadowPlane
-#define	RF_WRAP_FRAMES		0x00200	// mod the model frames by the maxframes to allow continuous
+#define	RF_SHADOW_PLANE		256	// use refEntity->shadowPlane
+#define	RF_WRAP_FRAMES		512	// mod the model frames by the maxframes to allow continuous
 										// animation without needing to know the frame count
 
-#define RF_FORCE_ENT_ALPHA	0x00400 // override shader alpha settings
-#define RF_RGB_TINT			0x00800 // override shader rgb settings
+//#define RF_FORCE_ENT_ALPHA	0x00400 // override shader alpha settings
+//#define RF_RGB_TINT			0x00800 // override shader rgb settings
 
-#define	RF_SHADOW_ONLY		0x01000	//add surfs for shadowing but don't draw them -rww
+//#define	RF_SHADOW_ONLY		0x01000	//add surfs for shadowing but don't draw them -rww
 
-#define	RF_DISTORTION		0x02000	//area distortion effect -rww
+//#define	RF_DISTORTION		0x02000	//area distortion effect -rww
 
-#define RF_FORKED			0x04000	// override lightning to have forks
-#define RF_TAPERED			0x08000	// lightning tapers
-#define RF_GROW				0x10000	// lightning grows from start to end during its life
+#define RF_FORKED			0x00001000	// override lightning to have forks
+#define RF_TAPERED			0x00002000	// lightning tapers
+#define RF_GROW				0x00004000	// lightning grows from start to end during its life
+#define RF_NO_FOG			0x00008000	// no fog for g2 models
+//#define RF_DISINTEGRATE1	0x20000	// does a procedural hole-ripping thing.
+//#define RF_DISINTEGRATE2	0x40000	// does a procedural hole-ripping thing with scaling at the ripping point
 
-#define RF_DISINTEGRATE1	0x20000	// does a procedural hole-ripping thing.
-#define RF_DISINTEGRATE2	0x40000	// does a procedural hole-ripping thing with scaling at the ripping point
+//#define RF_SETANIMINDEX		0x80000	//use backEnd.currentEntity->e.skinNum for R_BindAnimatedImage
 
-#define RF_SETANIMINDEX		0x80000	//use backEnd.currentEntity->e.skinNum for R_BindAnimatedImage
+//#define RF_ALPHA_DEPTH		0x100000 //depth write on alpha model
 
-#define RF_ALPHA_DEPTH		0x100000 //depth write on alpha model
-
-#define RF_FORCEPOST		0x200000 //force it to post-render -rww
+//#define RF_FORCEPOST		0x200000 //force it to post-render -rww
 
 // refdef flags
 #define RDF_NOWORLDMODEL	1		// used for player configuration screen
-#define RDF_HYPERSPACE		4		// teleportation effect
+#define RDF_PROJECTION2D	2
 
-#define RDF_SKYBOXPORTAL	8
-#define RDF_DRAWSKYBOX		16		// the above marks a scene as being a 'portal sky'.  this flag says to draw it or not
+//#define RDF_SKYBOXPORTAL	8
+//#define RDF_DRAWSKYBOX		16		// the above marks a scene as being a 'portal sky'.  this flag says to draw it or not
 
-#define RDF_AUTOMAP			32		//means this scene is to draw the automap -rww
-#define	RDF_NOFOG			64		//no global fog in this scene (but still brush fog) -rww
+//#define RDF_AUTOMAP			32		//means this scene is to draw the automap -rww
+//#define	RDF_NOFOG			64		//no global fog in this scene (but still brush fog) -rww
 
-extern int	skyboxportal;
-extern int	drawskyboxportal;
+//extern int	skyboxportal;
+//extern int	drawskyboxportal;
 
 typedef byte color4ub_t[4];
 
@@ -82,7 +82,6 @@ typedef enum {
 	RT_SPRITE,
 	RT_ORIENTED_QUAD,
 	RT_BEAM,
-	RT_SABER_GLOW,
 	RT_ELECTRICITY,
 	RT_PORTALSURFACE,		// doesn't draw anything, just info for portals
 	RT_LINE,
@@ -230,9 +229,6 @@ typedef struct {
 		} electricity;
 	} data;
 
-	float		endTime;
-	float		saberLength;
-
 /*
 Ghoul2 Insert Start
 */
@@ -311,9 +307,9 @@ typedef struct {
 	int			x, y, width, height;
 	float		fov_x, fov_y;
 	vec3_t		vieworg;
-	vec3_t		viewangles;
+	//vec3_t		viewangles;
 	vec3_t		viewaxis[3];		// transformation matrix
-	int			viewContents;		// world contents at vieworg
+	//int			viewContents;		// world contents at vieworg
 
 	// time in milliseconds for shader effects and other time dependent rendering issues
 	int			time;
@@ -325,6 +321,7 @@ typedef struct {
 
 	// text messages for deform text shaders
 	char		text[MAX_RENDER_STRINGS][MAX_RENDER_STRING_LENGTH];
+	vec3_t		viewangles;
 } refdef_t;
 
 
@@ -349,24 +346,63 @@ typedef enum { // r_ext_preferred_tc_method
 	TC_S3TC_DXT
 } textureCompression_t;
 
+typedef enum {
+	GLDRV_ICD,					// driver is integrated with window system
+								// WARNING: there are tests that check for
+								// > GLDRV_ICD for minidriverness, so this
+								// should always be the lowest value in this
+								// enum set
+	GLDRV_STANDALONE,			// driver is a non-3Dfx standalone driver
+	GLDRV_VOODOO				// driver is a 3Dfx standalone driver
+} glDriverType_t;
+
+typedef enum {
+	GLHW_GENERIC,			// where everthing works the way it should
+	GLHW_3DFX_2D3D,			// Voodoo Banshee or Voodoo3, relevant since if this is
+							// the hardware type then there can NOT exist a secondary
+							// display adapter
+	GLHW_RIVA128,			// where you can't interpolate alpha
+	GLHW_RAGEPRO,			// where you can't modulate alpha on alpha textures
+	GLHW_PERMEDIA2			// where you don't have src*dst
+} glHardwareType_t;
+
 typedef struct {
-	const char				*renderer_string;
-	const char				*vendor_string;
-	const char				*version_string;
-	const char				*extensions_string;
+	char					renderer_string[MAX_STRING_CHARS];
+	char					vendor_string[MAX_STRING_CHARS];
+	char					version_string[MAX_STRING_CHARS];
+	char					extensions_string[BIG_INFO_STRING];
 
 	int						maxTextureSize;			// queried from GL
 	int						maxActiveTextures;		// multitexture ability
-	float					maxTextureFilterAnisotropy;
+
+	int						tfSolidCompressed;
+	float					tfSolidCompressedBPT;
+	int						tfAlphaCompressed;	
+	float					tfAlphaCompressedBPT;	
+	int						tfSolidUncompressed;
+	float					tfSolidUncompressedBPT;
+	int						tfAlphaUncompressed;
+	float					tfAlphaUncompressedBPT;
+	int						tfLightmap;			
+	float					tfLightmapBPT;			
+	int						tfCinematic;					// Specially for the Voodoo4 - glTexImage2D can only handle 16 bit
+	float					tfCinematicBPT;
 
 	int						colorBits, depthBits, stencilBits;
 
+	glDriverType_t			driverType;
+	glHardwareType_t		hardwareType;
+
 	qboolean				deviceSupportsGamma;
-	textureCompression_t	textureCompression;
 	qboolean				textureEnvAddAvailable;
+	qboolean				textureFilterAnisotropicAvailable;
 	qboolean				clampToEdgeAvailable;
 
 	int						vidWidth, vidHeight;
+	// aspect is the screen's physical width / height, which may be different
+	// than scrWidth / scrHeight if the pixels are non-square
+	// normal screens should be 4/3, but wide aspect monitors may be 16/9
+	float					windowAspect;
 
 	int						displayFrequency;
 
@@ -375,6 +411,7 @@ typedef struct {
 	// used CDS.
 	qboolean				isFullscreen;
 	qboolean				stereoEnabled;
+	qboolean				smpActive;		// dual processor
 } glconfig_t;
 
 
diff --git a/codemp/server/NPCNav/gameCallbacks.cpp b/codemp/server/NPCNav/gameCallbacks.cpp
index edd3343..7b615d9 100644
--- a/codemp/server/NPCNav/gameCallbacks.cpp
+++ b/codemp/server/NPCNav/gameCallbacks.cpp
@@ -3,7 +3,7 @@
 #include "game/g_public.h"
 #include "server/server.h"
 
-qboolean GNavCallback_NAV_ClearPathToPoint( sharedEntity_t *self, vec3_t pmins, vec3_t pmaxs, vec3_t point, int clipmask, int okToHitEntNum )
+/*qboolean GNavCallback_NAV_ClearPathToPoint( sharedEntity_t *self, vec3_t pmins, vec3_t pmaxs, vec3_t point, int clipmask, int okToHitEntNum )
 {
 	return (qboolean)VM_Call(gvm, GAME_NAV_CLEARPATHTOPOINT, self->s.number, pmins, pmaxs, point, clipmask, okToHitEntNum);
 }
@@ -47,3 +47,4 @@ void GNavCallback_CP_FindCombatPointWaypoints( void )
 {
 	VM_Call(gvm, GAME_NAV_FINDCOMBATPOINTWAYPOINTS);
 }
+*/
\ No newline at end of file
diff --git a/codemp/server/NPCNav/navigator.cpp b/codemp/server/NPCNav/navigator.cpp
index 2dc7a3d..c768bf4 100644
--- a/codemp/server/NPCNav/navigator.cpp
+++ b/codemp/server/NPCNav/navigator.cpp
@@ -18,7 +18,7 @@
 DWORD timeGetTime(void);
 #endif
 
-extern qboolean GNavCallback_NAV_ClearPathToPoint( sharedEntity_t *self, vec3_t pmins, vec3_t pmaxs, vec3_t point, int clipmask, int okToHitEntNum );
+/*extern qboolean GNavCallback_NAV_ClearPathToPoint( sharedEntity_t *self, vec3_t pmins, vec3_t pmaxs, vec3_t point, int clipmask, int okToHitEntNum );
 extern qboolean GNavCallback_NPC_ClearLOS( sharedEntity_t *ent, const vec3_t end );
 extern int GNavCallback_NAVNEW_ClearPathBetweenPoints(vec3_t start, vec3_t end, vec3_t mins, vec3_t maxs, int ignore, int clipmask);
 extern qboolean GNavCallback_NAV_CheckNodeFailedForEnt( sharedEntity_t *ent, int nodeNum );
@@ -26,7 +26,7 @@ extern qboolean GNavCallback_G_EntIsUnlockedDoor( int entityNum );
 extern qboolean GNavCallback_G_EntIsDoor( int entityNum );
 extern qboolean GNavCallback_G_EntIsBreakable( int entityNum );
 extern qboolean GNavCallback_G_EntIsRemovableUsable( int entNum );
-extern void GNavCallback_CP_FindCombatPointWaypoints( void );
+extern void GNavCallback_CP_FindCombatPointWaypoints( void );*/
 
 //Global navigator
 CNavigator		navigator;
diff --git a/codemp/server/server.h b/codemp/server/server.h
index 0294d19..5c179cc 100644
--- a/codemp/server/server.h
+++ b/codemp/server/server.h
@@ -79,13 +79,6 @@ typedef struct {
 	int				areabytes;
 	byte			areabits[MAX_MAP_AREA_BYTES];		// portalarea visibility bits
 	playerState_t	ps;
-	playerState_t	vps; //vehicle I'm riding's playerstate (if applicable) -rww
-#ifdef _ONEBIT_COMBO
-	int				*pDeltaOneBit;
-	int				*pDeltaOneBitVeh;
-	int				*pDeltaNumBit;
-	int				*pDeltaNumBitVeh;
-#endif
 	int				num_entities;
 	int				first_entity;		// into the circular sv_packet_entities[]
 										// the entities MUST be in increasing state number
diff --git a/codemp/server/sv_ccmds.cpp b/codemp/server/sv_ccmds.cpp
index 064d5d1..efde9c4 100644
--- a/codemp/server/sv_ccmds.cpp
+++ b/codemp/server/sv_ccmds.cpp
@@ -2,7 +2,6 @@
 #include "qcommon/exe_headers.h"
 
 #include "server.h"
-#include "qcommon/stringed_ingame.h"
 
 /*
 ===============================================================================
@@ -174,31 +173,15 @@ static void SV_Map_f( void ) {
 	}
 
 	// force latched values to get set
-	Cvar_Get ("g_gametype", "0", CVAR_SERVERINFO | CVAR_LATCH );
+	Cvar_Get ("g_gametype", "dm", CVAR_SERVERINFO | CVAR_LATCH );
 
 	cmd = Cmd_Argv(0);
-	if( Q_stricmpn( cmd, "sp", 2 ) == 0 ) {
-		Cvar_SetValue( "g_gametype", GT_SINGLE_PLAYER );
-		Cvar_SetValue( "g_doWarmup", 0 );
-		// may not set sv_maxclients directly, always set latched
-		Cvar_SetLatched( "sv_maxclients", "8" );
-		cmd += 2;
-		cheat = qfalse;
+	if ( !Q_stricmpn( cmd, "devmap",6 ) || !Q_stricmp( cmd, "spdevmap" ) ) {
+		cheat = qtrue;
 		killBots = qtrue;
-	}
-	else {
-		if ( !Q_stricmpn( cmd, "devmap",6 ) || !Q_stricmp( cmd, "spdevmap" ) ) {
-			cheat = qtrue;
-			killBots = qtrue;
-		} else {
-			cheat = qfalse;
-			killBots = qfalse;
-		}
-		/*
-		if( sv_gametype->integer == GT_SINGLE_PLAYER ) {
-			Cvar_SetValue( "g_gametype", GT_FFA );
-		}
-		*/
+	} else {
+		cheat = qfalse;
+		killBots = qfalse;
 	}
 
 	// save the map name here cause on a map restart we reload the jampconfig.cfg
@@ -696,86 +679,6 @@ static void SV_ConSay_f(void) {
 	SV_SendServerCommand(NULL, "chat \"%s\n\"", text);
 }
 
-static const char *forceToggleNamePrints[] = 
-{
-	"HEAL",//FP_HEAL
-	"JUMP",//FP_LEVITATION
-	"SPEED",//FP_SPEED
-	"PUSH",//FP_PUSH
-	"PULL",//FP_PULL
-	"MINDTRICK",//FP_TELEPTAHY
-	"GRIP",//FP_GRIP
-	"LIGHTNING",//FP_LIGHTNING
-	"DARK RAGE",//FP_RAGE
-	"PROTECT",//FP_PROTECT
-	"ABSORB",//FP_ABSORB
-	"TEAM HEAL",//FP_TEAM_HEAL
-	"TEAM REPLENISH",//FP_TEAM_FORCE
-	"DRAIN",//FP_DRAIN
-	"SEEING",//FP_SEE
-	"SABER OFFENSE",//FP_SABER_OFFENSE
-	"SABER DEFENSE",//FP_SABER_DEFENSE
-	"SABER THROW",//FP_SABERTHROW
-	NULL
-};
-
-/*
-==================
-SV_ForceToggle_f
-==================
-*/
-void SV_ForceToggle_f(void)
-{
-	int i = 0;
-	int fpDisabled = Cvar_VariableValue("g_forcePowerDisable");
-	int targetPower = 0;
-	const char *powerDisabled = "Enabled";
-
-	if ( Cmd_Argc () < 2 )
-	{ //no argument supplied, spit out a list of force powers and their numbers
-		while (i < NUM_FORCE_POWERS)
-		{
-			if (fpDisabled & (1 << i))
-			{
-				powerDisabled = "Disabled";
-			}
-			else
-			{
-				powerDisabled = "Enabled";
-			}
-
-			Com_Printf(va("%i - %s - Status: %s\n", i, forceToggleNamePrints[i], powerDisabled));
-			i++;
-		}
-
-		Com_Printf("Example usage: forcetoggle 3\n(toggles PUSH)\n");
-		return;
-	}
-
-	targetPower = atoi(Cmd_Argv(1));
-
-	if (targetPower < 0 || targetPower >= NUM_FORCE_POWERS)
-	{
-		Com_Printf("Specified a power that does not exist.\nExample usage: forcetoggle 3\n(toggles PUSH)\n");
-		return;
-	}
-
-	if (fpDisabled & (1 << targetPower))
-	{
-		powerDisabled = "enabled";
-		fpDisabled &= ~(1 << targetPower);
-	}
-	else
-	{
-		powerDisabled = "disabled";
-		fpDisabled |= (1 << targetPower);
-	}
-
-	Cvar_SetValue("g_forcePowerDisable", fpDisabled);
-
-	Com_Printf("%s has been %s.\n", forceToggleNamePrints[targetPower], powerDisabled);
-}
-
 /*
 ==================
 SV_Heartbeat_f
@@ -902,8 +805,6 @@ void SV_AddOperatorCommands( void ) {
 	{
 		Cmd_AddCommand ("svsay", SV_ConSay_f);
 	}
-
-	Cmd_AddCommand ("forcetoggle", SV_ForceToggle_f);
 }
 
 /*
diff --git a/codemp/server/sv_client.cpp b/codemp/server/sv_client.cpp
index ddf47f6..2aab2be 100644
--- a/codemp/server/sv_client.cpp
+++ b/codemp/server/sv_client.cpp
@@ -4,7 +4,6 @@
 // sv_client.c -- server code for dealing with clients
 
 #include "server.h"
-#include "qcommon/stringed_ingame.h"
 #include "RMG/RM_Headers.h"
 #include "../zlib/zlib.h"
 //#include "zlib32/zip.h"
@@ -253,23 +252,23 @@ void SV_DirectConnect( netadr_t from ) {
 		}
 
 		ping = svs.time - svs.challenges[i].pingTime;
-		Com_Printf( SE_GetString("MP_SVGAME", "CLIENT_CONN_WITH_PING"), i, ping);//"Client %i connecting with %i challenge ping\n", i, ping );
+		Com_Printf( "Client %i connecting with %i challenge ping\n", i, ping );
 		svs.challenges[i].connected = qtrue;
 
 		// never reject a LAN client based on ping
 		if ( !Sys_IsLANAddress( from ) ) {
 			if ( sv_minPing->value && ping < sv_minPing->value ) {
 				// don't let them keep trying until they get a big delay
-				NET_OutOfBandPrint( NS_SERVER, from, va("print\n%s\n", SE_GetString("MP_SVGAME", "SERVER_FOR_HIGH_PING")));//Server is for high pings only\n" );
-				Com_DPrintf (SE_GetString("MP_SVGAME", "CLIENT_REJECTED_LOW_PING"), i);//"Client %i rejected on a too low ping\n", i);
+				NET_OutOfBandPrint( NS_SERVER, from, "print\nServer is for high pings only\n" );
+				Com_DPrintf ("Client %i rejected on a too low ping\n", i);
 				// reset the address otherwise their ping will keep increasing
 				// with each connect message and they'd eventually be able to connect
 				svs.challenges[i].adr.port = 0;
 				return;
 			}
 			if ( sv_maxPing->value && ping > sv_maxPing->value ) {
-				NET_OutOfBandPrint( NS_SERVER, from, va("print\n%s\n", SE_GetString("MP_SVGAME", "SERVER_FOR_LOW_PING")));//Server is for low pings only\n" );
-				Com_DPrintf (SE_GetString("MP_SVGAME", "CLIENT_REJECTED_HIGH_PING"), i);//"Client %i rejected on a too high ping\n", i);
+				NET_OutOfBandPrint( NS_SERVER, from, "print\nServer is for low pings only\n" );
+				Com_DPrintf ("Client %i rejected on a too high ping\n", i);
 				return;
 			}
 		}
@@ -643,6 +642,8 @@ void SV_SendClientGameState( client_t *client ) {
 	else
 	{
 		MSG_WriteShort ( &msg, 0 );
+		//SOF2 TODO
+		MSG_WriteLong ( &msg, 0 );
 	}
 
 	// deliver this to the client
@@ -1102,22 +1103,22 @@ static void SV_VerifyPaks_f( client_t *cl ) {
 		//dlls are valid too now -rww
 		if (Cvar_VariableValue( "vm_cgame" ))
 		{
-			bGood = (qboolean)(FS_FileIsInPAK("vm/cgame.qvm", &nChkSum1) == 1);
+			bGood = (qboolean)(FS_FileIsInPAK("vm/sof2mp_cgame.qvm", &nChkSum1) == 1);
 		}
 		else
 		{
-			bGood = (qboolean)(FS_FileIsInPAK("cgamex86.dll", &nChkSum1) == 1);
+			bGood = (qboolean)(FS_FileIsInPAK("sof2mp_cgamex86.dll", &nChkSum1) == 1);
 		}
 
 		if (bGood)
 		{
 			if (Cvar_VariableValue( "vm_ui" ))
 			{
-				bGood = (qboolean)(FS_FileIsInPAK("vm/ui.qvm", &nChkSum2) == 1);
+				bGood = (qboolean)(FS_FileIsInPAK("vm/sof2mp_ui.qvm", &nChkSum2) == 1);
 			}
 			else
 			{
-				bGood = (qboolean)(FS_FileIsInPAK("uix86.dll", &nChkSum2) == 1);
+				bGood = (qboolean)(FS_FileIsInPAK("sof2mp_uix86.dll", &nChkSum2) == 1);
 			}
 		}
 
diff --git a/codemp/server/sv_game.cpp b/codemp/server/sv_game.cpp
index 302f431..abab5b6 100644
--- a/codemp/server/sv_game.cpp
+++ b/codemp/server/sv_game.cpp
@@ -5,7 +5,6 @@
 #include "server.h"
 
 #include "botlib/botlib.h"
-#include "qcommon/stringed_ingame.h"
 
 #if !defined(CROFFSYSTEM_H_INC)
 	#include "qcommon/RoffSystem.h"
@@ -437,8 +436,6 @@ sharedEntity_t *ConvertedEntity(sharedEntity_t *ent)
 	return &gLocalModifier;
 }
 
-siegePers_t sv_siegePersData = {qfalse, 0, 0};
-
 extern float g_svCullDist;
 int SV_GameSystemCalls( int *args ) {
 	switch( args[0] ) {
@@ -495,7 +492,7 @@ int SV_GameSystemCalls( int *args ) {
 		return Sys_Milliseconds();
 	//rww - precision timer funcs... -ALWAYS- call end after start with supplied ptr, or you'll get a nasty memory leak.
 	//not that you should be using these outside of debug anyway.. because you shouldn't be. So don't.
-	case CG_PRECISIONTIMER_START:
+	/*case CG_PRECISIONTIMER_START:
 		{
 			void **suppliedPtr =(void **)VMA(1); //we passed in a pointer to a point
 			timing_c *newTimer = new timing_c; //create the new timer
@@ -510,7 +507,7 @@ int SV_GameSystemCalls( int *args ) {
 			r = timer->End(); //get the result
 			delete timer; //delete the timer since we're done with it
 			return r; //return the result
-		}
+		}*/
 	case G_CVAR_REGISTER:
 		Cvar_Register( (vmCvar_t *)VMA(1), (const char *)VMA(2), (const char *)VMA(3), args[4] ); 
 		return 0;
@@ -572,17 +569,17 @@ int SV_GameSystemCalls( int *args ) {
 	case G_TRACE:
 		SV_Trace( (trace_t *)VMA(1), (const float *)VMA(2), (const float *)VMA(3), (const float *)VMA(4), (const float *)VMA(5), args[6], args[7], /*int capsule*/ qfalse, /*args[8]*/0, args[9] );
 		return 0;
-	case G_G2TRACE:
-		SV_Trace( (trace_t *)VMA(1), (const float *)VMA(2), (const float *)VMA(3), (const float *)VMA(4), (const float *)VMA(5), args[6], args[7], /*int capsule*/ qfalse, args[8], args[9] );
-		return 0;
+	/*case G_G2TRACE:
+		SV_Trace( (trace_t *)VMA(1), (const float *)VMA(2), (const float *)VMA(3), (const float *)VMA(4), (const float *)VMA(5), args[6], args[7], qfalse, args[8], args[9] );
+		return 0;*/
 	case G_TRACECAPSULE:
 		SV_Trace( (trace_t *)VMA(1), (const float *)VMA(2), (const float *)VMA(3), (const float *)VMA(4), (const float *)VMA(5), args[6], args[7], /*int capsule*/ qtrue, args[8], args[9]  );
 		return 0;
 	case G_POINT_CONTENTS:
 		return SV_PointContents( (const float *)VMA(1), args[2] );
-	case G_SET_SERVER_CULL:
+	/*case G_SET_SERVER_CULL:
 		g_svCullDist = VMF(1);
-		return 0;
+		return 0;*/
 	case G_SET_BRUSH_MODEL:
 		SV_SetBrushModel( (sharedEntity_t *)VMA(1), (const char *)VMA(2) );
 		return 0;
@@ -622,13 +619,13 @@ int SV_GameSystemCalls( int *args ) {
 		SV_GetUsercmd( args[1], (struct usercmd_s *)VMA(2) );
 		return 0;
 
-	case G_SIEGEPERSSET:
+	/*case G_SIEGEPERSSET:
 		sv_siegePersData = *((siegePers_t *)VMA(1));
 		return 0;
 
 	case G_SIEGEPERSGET:
 		*((siegePers_t *)VMA(1)) = sv_siegePersData;
-		return 0;
+		return 0;*/
 
 		//rwwRMG - see below
 		/*
@@ -668,7 +665,7 @@ int SV_GameSystemCalls( int *args ) {
 
 //	case SP_REGISTER_SERVER_CMD:
 //		return SP_RegisterServer( (const char *)VMA(1) );
-	case SP_GETSTRINGTEXTSTRING:
+	/*case SP_GETSTRINGTEXTSTRING:
 		//return (int)SP_GetStringTextString((char *)VMA(1));
 		const char* text;
 
@@ -718,10 +715,10 @@ int SV_GameSystemCalls( int *args ) {
 		return 0;
 	case G_TRUEFREE:
 		VM_Shifted_Free((void **)VMA(1));
-		return 0;
+		return 0;*/
 
 	//rww - icarus traps
-	case G_ICARUS_RUNSCRIPT:
+	/*case G_ICARUS_RUNSCRIPT:
 		return ICARUS_RunScript(ConvertedEntity((sharedEntity_t *)VMA(1)), (const char *)VMA(2));
 
 	case G_ICARUS_REGISTERSCRIPT:
@@ -815,11 +812,11 @@ int SV_GameSystemCalls( int *args ) {
 		}
 
 	case G_ICARUS_GETVECTORVARIABLE:
-		return Q3_GetVectorVariable((const char *)VMA(1), (float *)VMA(2));
+		return Q3_GetVectorVariable((const char *)VMA(1), (float *)VMA(2));*/
 
 
 	//rww - BEGIN NPC NAV TRAPS
-	case G_NAV_INIT:
+	/*case G_NAV_INIT:
 		navigator.Init();
 		return 0;
 	case G_NAV_FREE:
@@ -919,11 +916,11 @@ int SV_GameSystemCalls( int *args ) {
 	case G_NAV_SETPATHSCALCULATED:
 		navigator.pathsCalculated = (qboolean)args[1];
 		return 0;
-	//rww - END NPC NAV TRAPS
+	//rww - END NPC NAV TRAPS*/
 
-	case G_SET_SHARED_BUFFER:
+	/*case G_SET_SHARED_BUFFER:
 		sv.mSharedMemory = ((char *)VMA(1));
-		return 0;
+		return 0;*/
 		//====================================
 
 	case BOTLIB_SETUP:
@@ -1295,8 +1292,8 @@ int SV_GameSystemCalls( int *args ) {
 	case BOTLIB_AI_GENETIC_PARENTS_AND_CHILD_SELECTION:
 		return botlib_export->ai.GeneticParentsAndChildSelection(args[1], (float *)VMA(2), (int *)VMA(3), (int *)VMA(4), (int *)VMA(5));
 
-	case G_R_REGISTERSKIN:
-		return re.RegisterServerSkin((const char *)VMA(1));
+	/*case G_R_REGISTERSKIN:
+		return re.RegisterServerSkin((const char *)VMA(1));*/
 
 	case G_G2_LISTBONES:
 		re.G2API_ListBones( (CGhoul2Info *) VMA(1), args[2]);
@@ -1316,14 +1313,14 @@ int SV_GameSystemCalls( int *args ) {
 	case G_G2_GETBOLT:
 		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
 
-	case G_G2_GETBOLT_NOREC:
+	/*case G_G2_GETBOLT_NOREC:
 		re.G2API_BoltMatrixReconstruction( qfalse );//gG2_GBMNoReconstruct = qtrue;
 		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
 
 	case G_G2_GETBOLT_NOREC_NOROT:
 		re.G2API_BoltMatrixReconstruction( qfalse );//gG2_GBMNoReconstruct = qtrue;
 		re.G2API_BoltMatrixSPMethod( qtrue );//gG2_GBMUseSPMethod = qtrue;
-		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));
+		return re.G2API_GetBoltMatrix(*((CGhoul2Info_v *)args[1]), args[2], args[3], (mdxaBone_t *)VMA(4), (const float *)VMA(5),(const float *)VMA(6), args[7], (qhandle_t *)VMA(8), (float *)VMA(9));*/
 
 	case G_G2_INITGHOUL2MODEL:
 #ifdef _FULL_G2_LEAK_CHECKING
@@ -1340,9 +1337,9 @@ int SV_GameSystemCalls( int *args ) {
 			return re.G2API_SetSkin(&g2[modelIndex], args[3], args[4]);
 		}
 
-	case G_G2_SIZE:
+	/*case G_G2_SIZE:
 		return re.G2API_Ghoul2Size ( *((CGhoul2Info_v *)args[1]) );
-		break;
+		break;*/
 
 	case G_G2_ADDBOLT:
 		return	re.G2API_AddBolt(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3));
@@ -1360,14 +1357,14 @@ int SV_GameSystemCalls( int *args ) {
 		return re.G2API_SetBoneAnim(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3), args[4], args[5],
 								args[6], VMF(7), args[8], VMF(9), args[10]);
 
-	case G_G2_GETBONEANIM:
+	/*case G_G2_GETBONEANIM:
 		{
 			CGhoul2Info_v &g2 = *((CGhoul2Info_v *)args[1]);
 			int modelIndex = args[10];
 
 			return re.G2API_GetBoneAnim(&g2[modelIndex], (const char*)VMA(2), args[3], (float *)VMA(4), (int *)VMA(5),
 								(int *)VMA(6), (int *)VMA(7), (float *)VMA(8), (int *)VMA(9));
-		}
+		}*/
 
 	case G_G2_GETGLANAME:
 		//return (int)G2API_GetGLAName(*((CGhoul2Info_v *)args[1]), args[2]);
@@ -1397,9 +1394,9 @@ int SV_GameSystemCalls( int *args ) {
 		re.G2API_DuplicateGhoul2Instance(*((CGhoul2Info_v *)args[1]), (CGhoul2Info_v **)VMA(2));
 		return 0;
 
-	case G_G2_HASGHOUL2MODELONINDEX:
+	/*case G_G2_HASGHOUL2MODELONINDEX:
 		//return (int)G2API_HasGhoul2ModelOnIndex((CGhoul2Info_v **)args[1], args[2]);
-		return (int)re.G2API_HasGhoul2ModelOnIndex((CGhoul2Info_v **)VMA(1), args[2]);
+		return (int)re.G2API_HasGhoul2ModelOnIndex((CGhoul2Info_v **)VMA(1), args[2]);*/
 
 	case G_G2_REMOVEGHOUL2MODEL:
 #ifdef _FULL_G2_LEAK_CHECKING
@@ -1408,12 +1405,12 @@ int SV_GameSystemCalls( int *args ) {
 		//return (int)G2API_RemoveGhoul2Model((CGhoul2Info_v **)args[1], args[2]);
 		return (int)re.G2API_RemoveGhoul2Model((CGhoul2Info_v **)VMA(1), args[2]);
 
-	case G_G2_REMOVEGHOUL2MODELS:
+	/*case G_G2_REMOVEGHOUL2MODELS:
 #ifdef _FULL_G2_LEAK_CHECKING
 		g_G2AllocServer = 1;
 #endif
 		//return (int)G2API_RemoveGhoul2Models((CGhoul2Info_v **)args[1]);
-		return (int)re.G2API_RemoveGhoul2Models((CGhoul2Info_v **)VMA(1));
+		return (int)re.G2API_RemoveGhoul2Models((CGhoul2Info_v **)VMA(1));*/
 
 	case G_G2_CLEANMODELS:
 #ifdef _FULL_G2_LEAK_CHECKING
@@ -1438,7 +1435,7 @@ int SV_GameSystemCalls( int *args ) {
 								   VMF(12) );
 		return 0;
 
-	case G_G2_COLLISIONDETECTCACHE:
+	/*case G_G2_COLLISIONDETECTCACHE:
 		re.G2API_CollisionDetectCache ( (CollisionRecord_t*)VMA(1), *((CGhoul2Info_v *)args[2]), 
 								   (const float*)VMA(3),
 								   (const float*)VMA(4),
@@ -1457,10 +1454,10 @@ int SV_GameSystemCalls( int *args ) {
 		return re.G2API_SetRootSurface(*((CGhoul2Info_v *)args[1]), args[2], (const char *)VMA(3));
 
 	case G_G2_SETSURFACEONOFF:
-		return re.G2API_SetSurfaceOnOff(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), /*(const int)VMA(3)*/args[3]);
+		return re.G2API_SetSurfaceOnOff(*((CGhoul2Info_v *)args[1]), (const char *)VMA(2), args[3]);
 
 	case G_G2_SETNEWORIGIN:
-		return re.G2API_SetNewOrigin(*((CGhoul2Info_v *)args[1]), /*(const int)VMA(2)*/args[2]);
+		return re.G2API_SetNewOrigin(*((CGhoul2Info_v *)args[1]), args[2]);
 
 	case G_G2_DOESBONEEXIST:
 		{
@@ -1600,7 +1597,7 @@ int SV_GameSystemCalls( int *args ) {
 		}
 
 
-		return 0;
+		return 0;*/
 
 	case G_SET_ACTIVE_SUBBSP:
 		SV_SetActiveSubBSP(args[1]);
@@ -1625,18 +1622,115 @@ int SV_GameSystemCalls( int *args ) {
 	case G_CM_REGISTER_TERRAIN:
 		return CM_RegisterTerrain((const char *)VMA(1), true)->GetTerrainId();
 
-	case G_BOT_UPDATEWAYPOINTS:
+	/*case G_BOT_UPDATEWAYPOINTS:
 		SV_BotWaypointReception(args[1], (wpobject_t **)VMA(2));
 		return 0;
 	case G_BOT_CALCULATEPATHS:
 		SV_BotCalculatePaths(args[1]);
-		return 0;
+		return 0;*/
 
 	case G_GET_ENTITY_TOKEN:
 		return SV_GetEntityToken((char *)VMA(1), args[2]);
 
+
+	case G_VM_LOCALALLOC:
+		return (int)VM_Local_Alloc(args[1]);
+	case G_VM_LOCALALLOCUNALIGNED:
+		return (int)VM_Local_AllocUnaligned(args[1]);
+	case G_VM_LOCALTEMPALLOC:
+		return (int)VM_Local_TempAlloc(args[1]);
+	case G_VM_LOCALTEMPFREE:
+		VM_Local_TempFree(args[1]);
+		return 0;
+	case G_VM_LOCALSTRINGALLOC:
+		return (int)VM_Local_StringAlloc((char *) VMA(1));
+
+	case G_GP_PARSE:
+		return (int)GP_Parse((char **) VMA(1), (bool) args[2], (bool) args[3]);
+	case G_GP_PARSE_FILE:
+		{
+			char * data;
+			FS_ReadFile((char *) VMA(1), (void **) &data);
+			return (int)GP_Parse(&data, (bool) args[2], (bool) args[3]);
+		}
+	case G_GP_CLEAN:
+		GP_Clean((TGenericParser2) args[1]);
+		return 0;
+	case G_GP_DELETE:
+		GP_Delete((TGenericParser2 *) VMA(1));
+		return 0;
+	case G_GP_GET_BASE_PARSE_GROUP:
+		return (int)GP_GetBaseParseGroup((TGenericParser2) args[1]);
+
+	case G_GPG_GET_NAME:
+		return (int)GPG_GetName((TGPGroup) args[1], (char *) VMA(2));
+	case G_GPG_GET_NEXT:
+		return (int)GPG_GetNext((TGPGroup) args[1]);
+	case G_GPG_GET_INORDER_NEXT:
+		return (int)GPG_GetInOrderNext((TGPGroup) args[1]);
+	case G_GPG_GET_INORDER_PREVIOUS:
+		return (int)GPG_GetInOrderPrevious((TGPGroup) args[1]);
+	case G_GPG_GET_PAIRS:
+		return (int)GPG_GetPairs((TGPGroup) args[1]);
+	case G_GPG_GET_INORDER_PAIRS:
+		return (int)GPG_GetInOrderPairs((TGPGroup) args[1]);
+	case G_GPG_GET_SUBGROUPS:
+		return (int)GPG_GetSubGroups((TGPGroup) args[1]);
+	case G_GPG_GET_INORDER_SUBGROUPS:
+		return (int)GPG_GetInOrderSubGroups((TGPGroup) args[1]);
+	case G_GPG_FIND_SUBGROUP:
+		return (int)GPG_FindSubGroup((TGPGroup) args[1], (char *) VMA(2));
+	case G_GPG_FIND_PAIR:
+		return (int)GPG_FindPair((TGPGroup) args[1], (const char *) VMA(2));
+	case G_GPG_FIND_PAIRVALUE:
+		return (int)GPG_FindPairValue((TGPGroup) args[1], (const char *) VMA(2), (const char *) VMA(3), (char *) VMA(4));
+
+	case G_GET_WORLD_BOUNDS:
+		CM_ModelBounds(0, (vec_t *)VMA(1), (vec_t *)VMA(2));
+		return 0;
+
+	case G_GPV_GET_NAME:
+		return (int)GPV_GetName((TGPValue) args[1], (char *) VMA(2));
+	case G_GPV_GET_NEXT:
+		return (int)GPV_GetNext((TGPValue) args[1]);
+	case G_GPV_GET_INORDER_NEXT:
+		return (int)GPV_GetInOrderNext((TGPValue) args[1]);
+	case G_GPV_GET_INORDER_PREVIOUS:
+		return (int)GPV_GetInOrderPrevious((TGPValue) args[1]);
+	case G_GPV_IS_LIST:
+		return (int)GPV_IsList((TGPValue) args[1]);
+	case G_GPV_GET_TOP_VALUE:
+		{
+			const char * topValue = GPV_GetTopValue((TGPValue) args[1]);
+			if (topValue)
+			{
+				strcpy((char *) VMA(2), topValue);
+			}
+			return 0;
+		}
+	case G_GPV_GET_LIST:
+		return (int)GPV_GetList((TGPValue) args[1]);
+
+	case G_GT_INIT:
+		//SOF2 TODO
+		//  const char* gametype, qboolean restart
+		return 0;
+	case G_GT_RUNFRAME:
+		//SOF2 TODO
+		// int time
+		return 0;
+	case G_GT_START:
+		//SOF2 TODO
+		// int time
+		return 0;
+	case G_GT_SENDEVENT:
+		//SOF2 TODO
+		// int event, int time, int arg0, int arg1, int arg2, int arg3, int arg4
+		return 0;
+
 	default:
-		Com_Error( ERR_DROP, "Bad game system trap: %i", args[0] );
+		Com_Printf("Bad game system trap: %i", args[0] );
+		//Com_Error( ERR_DROP, "Bad game system trap: %i", args[0] );
 	}
 	return -1;
 }
@@ -1730,7 +1824,7 @@ void SV_InitGameProgs( void ) {
 	}
 
 	// load the dll or bytecode
-	gvm = VM_Create( "jampgame", SV_GameSystemCalls, (vmInterpret_t)(int)Cvar_VariableValue( "vm_game" ) );
+	gvm = VM_Create( "sof2mp_game", SV_GameSystemCalls, (vmInterpret_t)(int)Cvar_VariableValue( "vm_game" ) );
 	if ( !gvm ) {
 		Com_Error( ERR_FATAL, "VM_Create on game failed" );
 	}
diff --git a/codemp/server/sv_init.cpp b/codemp/server/sv_init.cpp
index c6df46a..3c111aa 100644
--- a/codemp/server/sv_init.cpp
+++ b/codemp/server/sv_init.cpp
@@ -12,8 +12,6 @@ Ghoul2 Insert Start
 #include "qcommon/MiniHeap.h"
 #endif
 
-#include "qcommon/stringed_ingame.h"
-
 /*
 ===============
 SV_SendConfigstring
@@ -563,10 +561,6 @@ Ghoul2 Insert End
 		sv.configstrings[i] = CopyString("");
 	}
 
-	//rww - RAGDOLL_BEGIN
-	re.G2API_SetTime(sv.time,0);
-	//rww - RAGDOLL_END
-
 	// make sure we are not paused
 	Cvar_Set("cl_paused", "0");
 
@@ -605,17 +599,11 @@ Ghoul2 Insert End
 
 	// run a few frames to allow everything to settle
 	for ( i = 0 ;i < 3 ; i++ ) {
-		//rww - RAGDOLL_BEGIN
-		re.G2API_SetTime(sv.time,0);
-		//rww - RAGDOLL_END
 		VM_Call( gvm, GAME_RUN_FRAME, sv.time );
 		SV_BotFrame( sv.time );
 		sv.time += 100;
 		svs.time += 100;
 	}
-	//rww - RAGDOLL_BEGIN
-	re.G2API_SetTime(sv.time,0);
-	//rww - RAGDOLL_END
 
 	// create a baseline for more efficient communications
 	SV_CreateBaseline ();
@@ -672,9 +660,6 @@ Ghoul2 Insert End
 	SV_BotFrame( sv.time );
 	sv.time += 100;
 	svs.time += 100;
-	//rww - RAGDOLL_BEGIN
-	re.G2API_SetTime(sv.time,0);
-	//rww - RAGDOLL_END
 
 	if ( sv_pure->integer ) {
 		// the server sends these to the clients so they will only
@@ -909,7 +894,6 @@ void SV_Init (void) {
 	// Get these to establish them and to make sure they have a default before the menus decide to stomp them.
 	Cvar_Get ("g_maxHolocronCarry", "3", CVAR_SERVERINFO);
 	Cvar_Get ("g_privateDuel", "1", CVAR_SERVERINFO );
-	Cvar_Get ("g_saberLocking", "1", CVAR_SERVERINFO );
 	Cvar_Get ("g_maxForceRank", "7", CVAR_SERVERINFO );
 	Cvar_Get ("duel_fraglimit", "10", CVAR_SERVERINFO);
 	Cvar_Get ("g_forceBasedTeams", "0", CVAR_SERVERINFO);
@@ -950,8 +934,7 @@ void SV_Init (void) {
 
 	sv_allowDownload = Cvar_Get ("sv_allowDownload", "0", CVAR_SERVERINFO);
 	sv_master[0] = Cvar_Get ("sv_master1", MASTER_SERVER_NAME, 0 );
-	sv_master[1] = Cvar_Get("sv_master2", JKHUB_MASTER_SERVER_NAME, 0);
-	for(int index = 2; index < MAX_MASTER_SERVERS; index++)
+	for(int index = 1; index < MAX_MASTER_SERVERS; index++)
 		sv_master[index] = Cvar_Get(va("sv_master%d", index + 1), "", CVAR_ARCHIVE);
 	sv_reconnectlimit = Cvar_Get ("sv_reconnectlimit", "3", 0);
 	sv_showghoultraces = Cvar_Get ("sv_showghoultraces", "0", 0);
diff --git a/codemp/server/sv_main.cpp b/codemp/server/sv_main.cpp
index 20ec9ce..79a68c3 100644
--- a/codemp/server/sv_main.cpp
+++ b/codemp/server/sv_main.cpp
@@ -567,7 +567,7 @@ if a user is interested in a server to do a full status
 ================
 */
 void SVC_Info( netadr_t from ) {
-	int		i, count, humans, wDisable;
+	int		i, count, humans;
 	char	*gamedir;
 	char	infostring[MAX_INFO_STRING];
 
@@ -630,19 +630,8 @@ void SVC_Info( netadr_t from ) {
 	Info_SetValueForKey(infostring, "g_humanplayers", va("%i", humans));
 	Info_SetValueForKey( infostring, "sv_maxclients", 
 		va("%i", sv_maxclients->integer - sv_privateClients->integer ) );
-	Info_SetValueForKey( infostring, "gametype", va("%i", sv_gametype->integer ) );
+	Info_SetValueForKey( infostring, "gametype", sv_gametype->string );
 	Info_SetValueForKey( infostring, "needpass", va("%i", sv_needpass->integer ) );
-	Info_SetValueForKey( infostring, "truejedi", va("%i", Cvar_VariableIntegerValue( "g_jediVmerc" ) ) );
-	if ( sv_gametype->integer == GT_DUEL || sv_gametype->integer == GT_POWERDUEL )
-	{
-		wDisable = Cvar_VariableIntegerValue( "g_duelWeaponDisable" );
-	}
-	else
-	{
-		wDisable = Cvar_VariableIntegerValue( "g_weaponDisable" );
-	}
-	Info_SetValueForKey( infostring, "wdisable", va("%i", wDisable ) );
-	Info_SetValueForKey( infostring, "fdisable", va("%i", Cvar_VariableIntegerValue( "g_forcePowerDisable" ) ) );
 	//Info_SetValueForKey( infostring, "pure", va("%i", sv_pure->integer ) );
 
 	if( sv_minPing->integer ) {
@@ -1130,10 +1119,6 @@ void SV_Frame( int msec ) {
 		VM_Call( gvm, GAME_RUN_FRAME, sv.time );
 	}
 
-	//rww - RAGDOLL_BEGIN
-	re.G2API_SetTime(sv.time,0);
-	//rww - RAGDOLL_END
-
 	if ( com_speeds->integer ) {
 		time_game = Sys_Milliseconds () - startTime;
 	}
diff --git a/codemp/server/sv_snapshot.cpp b/codemp/server/sv_snapshot.cpp
index 852ac2e..f22dba9 100644
--- a/codemp/server/sv_snapshot.cpp
+++ b/codemp/server/sv_snapshot.cpp
@@ -177,40 +177,12 @@ static void SV_WriteSnapshotToClient( client_t *client, msg_t *msg ) {
 #else
 		MSG_WriteDeltaPlayerstate( msg, &oldframe->ps, &frame->ps );
 #endif
-		if (frame->ps.m_iVehicleNum)
-		{ //then write the vehicle's playerstate too
-			if (!oldframe->ps.m_iVehicleNum)
-			{ //if last frame didn't have vehicle, then the old vps isn't gonna delta
-				//properly (because our vps on the client could be anything)
-#ifdef _ONEBIT_COMBO
-				MSG_WriteDeltaPlayerstate( msg, NULL, &frame->vps, NULL, NULL, qtrue );
-#else
-				MSG_WriteDeltaPlayerstate( msg, NULL, &frame->vps, qtrue );
-#endif
-			}
-			else
-			{
-#ifdef _ONEBIT_COMBO
-				MSG_WriteDeltaPlayerstate( msg, &oldframe->vps, &frame->vps, frame->pDeltaOneBitVeh, frame->pDeltaNumBitVeh, qtrue );
-#else
-				MSG_WriteDeltaPlayerstate( msg, &oldframe->vps, &frame->vps, qtrue );
-#endif
-			}
-		}
 	} else {
 #ifdef _ONEBIT_COMBO
 		MSG_WriteDeltaPlayerstate( msg, NULL, &frame->ps, NULL, NULL );
 #else
 		MSG_WriteDeltaPlayerstate( msg, NULL, &frame->ps );
 #endif
-		if (frame->ps.m_iVehicleNum)
-		{ //then write the vehicle's playerstate too
-#ifdef _ONEBIT_COMBO
-			MSG_WriteDeltaPlayerstate( msg, NULL, &frame->vps, NULL, NULL, qtrue );
-#else
-			MSG_WriteDeltaPlayerstate( msg, NULL, &frame->vps, qtrue );
-#endif
-		}
 	}
 
 	// delta encode the entities
@@ -390,12 +362,6 @@ static void SV_AddEntitiesVisibleFromPoint( vec3_t origin, clientSnapshot_t *fra
 			continue;
 		}
 
-		if (ent->s.isPortalEnt)
-		{ //rww - portal entities are always sent as well
-			SV_AddEntToSnapshot( svEnt, ent, eNums );
-			continue;
-		}
-
 		if (com_RMG && com_RMG->integer)
 		{
 			VectorAdd(ent->r.absmax, ent->r.absmin, difference);
@@ -537,22 +503,6 @@ static void SV_BuildClientSnapshot( client_t *client ) {
 	frame->pDeltaNumBit = &ps->deltaNumBits;
 #endif
 
-	if (ps->m_iVehicleNum)
-	{ //get the vehicle's playerstate too then
-		sharedEntity_t *veh = SV_GentityNum(ps->m_iVehicleNum);
-
-		if (veh && veh->playerState)
-		{ //Now VMA it and we've got ourselves a playerState
-			playerState_t *vps = ((playerState_t *)VM_ArgPtr((int)veh->playerState));
-
-            frame->vps = *vps;
-#ifdef _ONEBIT_COMBO
-			frame->pDeltaOneBitVeh = &vps->deltaOneBits;
-			frame->pDeltaNumBitVeh = &vps->deltaNumBits;
-#endif
-		}
-	}
-
 	int							clientNum;
 	// never send client's own entity, because it can
 	// be regenerated from the playerstate
@@ -709,46 +659,6 @@ void SV_SendClientSnapshot( client_t *client ) {
 	byte		msg_buf[MAX_MSGLEN];
 	msg_t		msg;
 
-	if (!client->sentGamedir)
-	{ //rww - if this is the case then make sure there is an svc_setgame sent before this snap
-		int i = 0;
-
-		MSG_Init (&msg, msg_buf, sizeof(msg_buf));
-
-		//have to include this for each message.
-		MSG_WriteLong( &msg, client->lastClientCommand );
-
-		MSG_WriteByte (&msg, svc_setgame);
-
-		while (fs_gamedirvar->string[i])
-		{
-			MSG_WriteByte(&msg, fs_gamedirvar->string[i]);
-			i++;
-		}
-		MSG_WriteByte(&msg, 0);
-
-		// MW - my attempt to fix illegible server message errors caused by 
-		// packet fragmentation of initial snapshot.
-		//rww - reusing this code here
-		while(client->state&&client->netchan.unsentFragments)
-		{
-			// send additional message fragments if the last message
-			// was too large to send at once
-			Com_Printf ("[ISM]SV_SendClientGameState() [1] for %s, writing out old fragments\n", client->name);
-			SV_Netchan_TransmitNextFragment(&client->netchan);
-		}
-
-		// record information about the message
-		client->frames[client->netchan.outgoingSequence & PACKET_MASK].messageSize = msg.cursize;
-		client->frames[client->netchan.outgoingSequence & PACKET_MASK].messageSent = svs.time;
-		client->frames[client->netchan.outgoingSequence & PACKET_MASK].messageAcked = -1;
-
-		// send the datagram
-		SV_Netchan_Transmit( client, &msg );	//msg->cursize, msg->data );
-
-		client->sentGamedir = qtrue;
-	}
-
 	// build the snapshot
 	SV_BuildClientSnapshot( client );
 
diff --git a/codemp/server/sv_world.cpp b/codemp/server/sv_world.cpp
index c2ee9a1..30955e5 100644
--- a/codemp/server/sv_world.cpp
+++ b/codemp/server/sv_world.cpp
@@ -523,7 +523,7 @@ static void SV_ClipMoveToEntities( moveclip_t *clip ) {
 	int			i, num;
 	sharedEntity_t *touch;
 	int			passOwnerNum;
-	trace_t		trace, oldTrace= {0};
+	trace_t		trace, oldTrace= {qfalse};
 	clipHandle_t	clipHandle;
 	float		*origin, *angles;
 	int			thisOwnerShared = 1;
@@ -558,8 +558,7 @@ static void SV_ClipMoveToEntities( moveclip_t *clip ) {
 			if ( touch->r.ownerNum == clip->passEntityNum) {
 				if (touch->r.svFlags & SVF_OWNERNOTSHARED)
 				{
-					if ( clip->contentmask != (MASK_SHOT | CONTENTS_LIGHTSABER) &&
-						clip->contentmask != (MASK_SHOT))
+					if (clip->contentmask != (MASK_SHOT))
 					{ //it's not a laser hitting the other "missile", don't care then
 						continue;
 					}
@@ -589,7 +588,7 @@ static void SV_ClipMoveToEntities( moveclip_t *clip ) {
 			continue;
 		}
 
-		if ((clip->contentmask == (MASK_SHOT|CONTENTS_LIGHTSABER) || clip->contentmask == MASK_SHOT) && (touch->r.contents > 0 && (touch->r.contents & CONTENTS_NOSHOT)))
+		if (clip->contentmask == MASK_SHOT && (touch->r.contents > 0 && (touch->r.contents & CONTENTS_NOSHOT)))
 		{
 			continue;
 		}
@@ -734,18 +733,7 @@ Ghoul2 Insert Start
 			}
 #endif
 
-			if (com_optvehtrace &&
-				com_optvehtrace->integer &&
-				touch->s.eType == ET_NPC &&
-				touch->s.NPC_class == CLASS_VEHICLE &&
-				touch->m_pVehicle)
-			{ //for vehicles cache the transform data.
-				re.G2API_CollisionDetectCache(G2Trace, *((CGhoul2Info_v *)touch->ghoul2), angles, touch->r.currentOrigin, svs.time, touch->s.number, clip->start, clip->end, touch->modelScale, G2VertSpaceServer, 0, clip->useLod, fRadius);
-			}
-			else
-			{
-				re.G2API_CollisionDetect(G2Trace, *((CGhoul2Info_v *)touch->ghoul2), angles, touch->r.currentOrigin, svs.time, touch->s.number, clip->start, clip->end, touch->modelScale, G2VertSpaceServer, 0, clip->useLod, fRadius);
-			}
+			re.G2API_CollisionDetect(G2Trace, *((CGhoul2Info_v *)touch->ghoul2), angles, touch->r.currentOrigin, svs.time, touch->s.number, clip->start, clip->end, touch->modelScale, G2VertSpaceServer, 0, clip->useLod, fRadius);
 
 			tN = 0;
 			while (tN < MAX_G2_COLLISIONS)
diff --git a/codemp/ui/keycodes.h b/codemp/ui/keycodes.h
index 2a53a2d..86d8101 100644
--- a/codemp/ui/keycodes.h
+++ b/codemp/ui/keycodes.h
@@ -7,338 +7,234 @@
 
 typedef enum
 {
-	A_NULL = 0,
-	A_SHIFT,
-	A_CTRL,
-	A_ALT,
-	A_CAPSLOCK,
-	A_NUMLOCK,
-	A_SCROLLLOCK,
-	A_PAUSE,
-	A_BACKSPACE,
-	A_TAB,
-	A_ENTER,
-	A_KP_PLUS,
-	A_KP_MINUS,
-	A_KP_ENTER,
-	A_KP_PERIOD,
-	A_PRINTSCREEN,
-	A_KP_0,
-	A_KP_1,
-	A_KP_2,
-	A_KP_3,
-	A_KP_4,
-	A_KP_5,
-	A_KP_6,
-	A_KP_7,
-	A_KP_8,
-	A_KP_9,
-	A_CONSOLE,
-	A_ESCAPE,
-	A_F1,
-	A_F2,
-	A_F3,
-	A_F4,
+	K_TAB = 9,
+	K_ENTER = 13,
+	K_ESCAPE = 27,
+	K_SPACE = 32,
+	
+	K_PLING,
+	K_DOUBLE_QUOTE,
+	K_HASH,
+	K_STRING,
+	K_PERCENT,
+	K_AND,
+	K_SINGLE_QUOTE,
+	K_OPEN_BRACKET,
+	K_CLOSE_BRACKET,
+	K_STAR,
+	K_PLUS,
+	K_COMMA,
+	K_MINUS,
+	K_PERIOD,
+	K_FORWARD_SLASH,
 
-	A_SPACE,
-	A_PLING,
-	A_DOUBLE_QUOTE,
-	A_HASH,
-	A_STRING,
-	A_PERCENT,
-	A_AND,
-	A_SINGLE_QUOTE,
-	A_OPEN_BRACKET,
-	A_CLOSE_BRACKET,
-	A_STAR,
-	A_PLUS,
-	A_COMMA,
-	A_MINUS,
-	A_PERIOD,
-	A_FORWARD_SLASH,
-	A_0,
-	A_1,
-	A_2,
-	A_3,
-	A_4,
-	A_5,
-	A_6,
-	A_7,
-	A_8,
-	A_9,
-	A_COLON,
-	A_SEMICOLON,
-	A_LESSTHAN,
-	A_EQUALS,
-	A_GREATERTHAN,
-	A_QUESTION,
+	K_0,
+	K_1,
+	K_2,
+	K_3,
+	K_4,
+	K_5,
+	K_6,
+	K_7,
+	K_8,
+	K_9,
 
-	A_AT,
-	A_CAP_A,
-	A_CAP_B,
-	A_CAP_C,
-	A_CAP_D,
-	A_CAP_E,
-	A_CAP_F,
-	A_CAP_G,
-	A_CAP_H,
-	A_CAP_I,
-	A_CAP_J,
-	A_CAP_K,
-	A_CAP_L,
-	A_CAP_M,
-	A_CAP_N,
-	A_CAP_O,
-	A_CAP_P,
-	A_CAP_Q,
-	A_CAP_R,
-	A_CAP_S,
-	A_CAP_T,
-	A_CAP_U,
-	A_CAP_V,
-	A_CAP_W,
-	A_CAP_X,
-	A_CAP_Y,
-	A_CAP_Z,
-	A_OPEN_SQUARE,
-	A_BACKSLASH,
-	A_CLOSE_SQUARE,
-	A_CARET,
-	A_UNDERSCORE,
+	K_COLON,
+	K_SEMICOLON,
+	K_LESSTHAN,
+	K_EQUALS,
+	K_GREATERTHAN,
+	K_QUESTION,
+	K_AT,
 
-	A_LEFT_SINGLE_QUOTE,
-	A_LOW_A,
-	A_LOW_B,
-	A_LOW_C,
-	A_LOW_D,
-	A_LOW_E,
-	A_LOW_F,
-	A_LOW_G,
-	A_LOW_H,
-	A_LOW_I,
-	A_LOW_J,
-	A_LOW_K,
-	A_LOW_L,
-	A_LOW_M,
-	A_LOW_N,
-	A_LOW_O,
-	A_LOW_P,
-	A_LOW_Q,
-	A_LOW_R,
-	A_LOW_S,
-	A_LOW_T,
-	A_LOW_U,
-	A_LOW_V,
-	A_LOW_W,
-	A_LOW_X,
-	A_LOW_Y,
-	A_LOW_Z,
-	A_OPEN_BRACE,
-	A_BAR,
-	A_CLOSE_BRACE,
-	A_TILDE,
-	A_DELETE,
+	K_CAP_A,
+	K_CAP_B,
+	K_CAP_C,
+	K_CAP_D,
+	K_CAP_E,
+	K_CAP_F,
+	K_CAP_G,
+	K_CAP_H,
+	K_CAP_I,
+	K_CAP_J,
+	K_CAP_K,
+	K_CAP_L,
+	K_CAP_M,
+	K_CAP_N,
+	K_CAP_O,
+	K_CAP_P,
+	K_CAP_Q,
+	K_CAP_R,
+	K_CAP_S,
+	K_CAP_T,
+	K_CAP_U,
+	K_CAP_V,
+	K_CAP_W,
+	K_CAP_X,
+	K_CAP_Y,
+	K_CAP_Z,
 
-	A_EURO,
-	A_SHIFT2,
-	A_CTRL2,
-	A_ALT2,
-	A_F5,
-	A_F6,
-	A_F7,
-	A_F8,
-	A_CIRCUMFLEX,
-	A_MWHEELUP,
-	A_CAP_SCARON,
-	A_MWHEELDOWN,
-	A_CAP_OE,
-	A_MOUSE1,
-	A_MOUSE2,
-	A_INSERT,
-	A_HOME,
-	A_PAGE_UP,
-	A_RIGHT_SINGLE_QUOTE,
-	A_LEFT_DOUBLE_QUOTE,
-	A_RIGHT_DOUBLE_QUOTE,
-	A_F9,
-	A_F10,
-	A_F11,
-	A_F12,
-	A_TRADEMARK,
-	A_LOW_SCARON,
-	A_SHIFT_ENTER,
-	A_LOW_OE,
-	A_END,
-	A_PAGE_DOWN,
-	A_CAP_YDIERESIS,
+	K_OPEN_SQUARE,
+	K_BACKSLASH,
+	K_CLOSE_SQUARE,
+	K_CARET,
+	K_UNDERSCORE,
+	K_LEFT_SINGLE_QUOTE,
 
-	A_SHIFT_SPACE,
-	A_EXCLAMDOWN,
-	A_CENT,
-	A_POUND,
-	A_SHIFT_KP_ENTER,
-	A_YEN,
-	A_MOUSE3,
-	A_MOUSE4,
-	A_MOUSE5,
-	A_COPYRIGHT,
-	A_CURSOR_UP,
-	A_CURSOR_DOWN,
-	A_CURSOR_LEFT,
-	A_CURSOR_RIGHT,
-	A_REGISTERED,
-	A_UNDEFINED_7,
-	A_UNDEFINED_8,
-	A_UNDEFINED_9,
-	A_UNDEFINED_10,
-	A_UNDEFINED_11,
-	A_UNDEFINED_12,
-	A_UNDEFINED_13,
-	A_UNDEFINED_14,
-	A_UNDEFINED_15,
-	A_UNDEFINED_16,
-	A_UNDEFINED_17,
-	A_UNDEFINED_18,
-	A_UNDEFINED_19,
-	A_UNDEFINED_20,
-	A_UNDEFINED_21,
-	A_UNDEFINED_22,
-	A_QUESTION_DOWN,
+	K_LOW_A,
+	K_LOW_B,
+	K_LOW_C,
+	K_LOW_D,
+	K_LOW_E,
+	K_LOW_F,
+	K_LOW_G,
+	K_LOW_H,
+	K_LOW_I,
+	K_LOW_J,
+	K_LOW_K,
+	K_LOW_L,
+	K_LOW_M,
+	K_LOW_N,
+	K_LOW_O,
+	K_LOW_P,
+	K_LOW_Q,
+	K_LOW_R,
+	K_LOW_S,
+	K_LOW_T,
+	K_LOW_U,
+	K_LOW_V,
+	K_LOW_W,
+	K_LOW_X,
+	K_LOW_Y,
+	K_LOW_Z,
 
-	A_CAP_AGRAVE,
-	A_CAP_AACUTE,
-	A_CAP_ACIRCUMFLEX,
-	A_CAP_ATILDE,
-	A_CAP_ADIERESIS,
-	A_CAP_ARING,
-	A_CAP_AE,
-	A_CAP_CCEDILLA,
-	A_CAP_EGRAVE,
-	A_CAP_EACUTE,
-	A_CAP_ECIRCUMFLEX,
-	A_CAP_EDIERESIS,
-	A_CAP_IGRAVE,
-	A_CAP_IACUTE,
-	A_CAP_ICIRCUMFLEX,
-	A_CAP_IDIERESIS,
-	A_CAP_ETH,
-	A_CAP_NTILDE,
-	A_CAP_OGRAVE,
-	A_CAP_OACUTE,
-	A_CAP_OCIRCUMFLEX,
-	A_CAP_OTILDE,
-	A_CAP_ODIERESIS,
-	A_MULTIPLY,
-	A_CAP_OSLASH,
-	A_CAP_UGRAVE,
-	A_CAP_UACUTE,
-	A_CAP_UCIRCUMFLEX,
-	A_CAP_UDIERESIS,
-	A_CAP_YACUTE,
-	A_CAP_THORN,
-	A_GERMANDBLS,
+	K_OPEN_BRACE,
+	K_BAR,
+	K_CLOSE_BRACE,
+	K_TILDE,
 
-	A_LOW_AGRAVE,
-	A_LOW_AACUTE,
-	A_LOW_ACIRCUMFLEX,
-	A_LOW_ATILDE,
-	A_LOW_ADIERESIS,
-	A_LOW_ARING,
-	A_LOW_AE,
-	A_LOW_CCEDILLA,
-	A_LOW_EGRAVE,
-	A_LOW_EACUTE,
-	A_LOW_ECIRCUMFLEX,
-	A_LOW_EDIERESIS,
-	A_LOW_IGRAVE,
-	A_LOW_IACUTE,
-	A_LOW_ICIRCUMFLEX,
-	A_LOW_IDIERESIS,
-	A_LOW_ETH,
-	A_LOW_NTILDE,
-	A_LOW_OGRAVE,
-	A_LOW_OACUTE,
-	A_LOW_OCIRCUMFLEX,
-	A_LOW_OTILDE,
-	A_LOW_ODIERESIS,
-	A_DIVIDE,
-	A_LOW_OSLASH,
-	A_LOW_UGRAVE,
-	A_LOW_UACUTE,
-	A_LOW_UCIRCUMFLEX,
-	A_LOW_UDIERESIS,
-	A_LOW_YACUTE,
-	A_LOW_THORN,
-	A_LOW_YDIERESIS,
-	
-	A_JOY0,
-	A_JOY1,
-	A_JOY2,
-	A_JOY3,
-	A_JOY4,
-	A_JOY5,
-	A_JOY6,
-	A_JOY7,
-	A_JOY8,
-	A_JOY9,
-	A_JOY10,
-	A_JOY11,
-	A_JOY12,
-	A_JOY13,
-	A_JOY14,
-	A_JOY15,
-	A_JOY16,
-	A_JOY17,
-	A_JOY18,
-	A_JOY19,
-	A_JOY20,
-	A_JOY21,
-	A_JOY22,
-	A_JOY23,
-	A_JOY24,
-	A_JOY25,
-	A_JOY26,
-	A_JOY27,
-	A_JOY28,
-	A_JOY29,
-	A_JOY30,
-	A_JOY31,
+	K_BACKSPACE = 127,
+
+	K_COMMAND = 128,
+	K_CAPSLOCK,
+	K_POWER,
+	K_PAUSE,
+
+	K_UPARROW,
+	K_DOWNARROW,
+	K_LEFTARROW,
+	K_RIGHTARROW,
+
+	K_ALT,
+	K_CTRL,
+	K_SHIFT,
+	K_INS,
+	K_DEL,
+	K_PGDN,
+	K_PGUP,
+	K_HOME,
+	K_END,
+
+	K_F1,
+	K_F2,
+	K_F3,
+	K_F4,
+	K_F5,
+	K_F6,
+	K_F7,
+	K_F8,
+	K_F9,
+	K_F10,
+	K_F11,
+	K_F12,
+	K_F13,
+	K_F14,
+	K_F15,
+
+	K_SCROLL,
+
+	K_KP_HOME,
+	K_KP_UPARROW,
+	K_KP_PGUP,
+	K_KP_LEFTARROW,
+	K_KP_5,
+	K_KP_RIGHTARROW,
+	K_KP_END,
+	K_KP_DOWNARROW,
+	K_KP_PGDN,
+	K_KP_ENTER,
+	K_KP_INS,
+	K_KP_DEL,
+	K_KP_SLASH,
+	K_KP_MINUS,
+	K_KP_PLUS,
+	K_KP_NUMLOCK,
+	K_KP_STAR,
+	K_KP_EQUALS,
+
+	K_MOUSE1,
+	K_MOUSE2,
+	K_MOUSE3,
+	K_MOUSE4,
+	K_MOUSE5,
+
+	K_MWHEELDOWN,
+	K_MWHEELUP,
+
+	K_JOY1,
+	K_JOY2,
+	K_JOY3,
+	K_JOY4,
+	K_JOY5,
+	K_JOY6,
+	K_JOY7,
+	K_JOY8,
+	K_JOY9,
+	K_JOY10,
+	K_JOY11,
+	K_JOY12,
+	K_JOY13,
+	K_JOY14,
+	K_JOY15,
+	K_JOY16,
+	K_JOY17,
+	K_JOY18,
+	K_JOY19,
+	K_JOY20,
+	K_JOY21,
+	K_JOY22,
+	K_JOY23,
+	K_JOY24,
+	K_JOY25,
+	K_JOY26,
+	K_JOY27,
+	K_JOY28,
+	K_JOY29,
+	K_JOY30,
+	K_JOY31,
+	K_JOY32,
+
+	K_AUX1,
+	K_AUX2,
+	K_AUX3,
+	K_AUX4,
+	K_AUX5,
+	K_AUX6,
+	K_AUX7,
+	K_AUX8,
+	K_AUX9,
+	K_AUX10,
+	K_AUX11,
+	K_AUX12,
+	K_AUX13,
+	K_AUX14,
+	K_AUX15,
+	K_AUX16,
 
-	A_AUX0,
-	A_AUX1,
-	A_AUX2,
-	A_AUX3,
-	A_AUX4,
-	A_AUX5,
-	A_AUX6,
-	A_AUX7,
-	A_AUX8,
-	A_AUX9,
-	A_AUX10,
-	A_AUX11,
-	A_AUX12,
-	A_AUX13,
-	A_AUX14,
-	A_AUX15,
-	A_AUX16,
-	A_AUX17,
-	A_AUX18,
-	A_AUX19,
-	A_AUX20,
-	A_AUX21,
-	A_AUX22,
-	A_AUX23,
-	A_AUX24,
-	A_AUX25,
-	A_AUX26,
-	A_AUX27,
-	A_AUX28,
-	A_AUX29,
-	A_AUX30,
-	A_AUX31,
+	K_CONSOLE,
 
-	MAX_KEYS
-} fakeAscii_t;
+	K_LAST_KEY		// this had better be <256!
+} keyNum_t;
 
 
 // The menu code needs to get both key and char events, but
diff --git a/codemp/ui/ui.vcxproj b/codemp/ui/ui.vcxproj
index ac18ecd..ddb956e 100644
--- a/codemp/ui/ui.vcxproj
+++ b/codemp/ui/ui.vcxproj
@@ -18,10 +18,12 @@
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
+    <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseOfMfc>false</UseOfMfc>
+    <PlatformToolset>v110</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
diff --git a/codemp/ui/ui.vcxproj.filters b/codemp/ui/ui.vcxproj.filters
index c3a645e..0dcd289 100644
--- a/codemp/ui/ui.vcxproj.filters
+++ b/codemp/ui/ui.vcxproj.filters
@@ -26,12 +26,6 @@
     <ClCompile Include="..\game\bg_weapons.c">
       <Filter>Source Files</Filter>
     </ClCompile>
-    <ClCompile Include="..\game\q_math.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\game\q_shared.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
     <ClCompile Include="ui_atoms.c">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -53,6 +47,12 @@
     <ClCompile Include="ui_syscalls.c">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\qcommon\q_math.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\qcommon\q_shared.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\game\anims.h">
@@ -73,51 +73,46 @@
     <ClInclude Include="..\game\bg_weapons.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\shared\qcommon\disablewarnings.h">
+    <ClInclude Include="keycodes.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\shared\qcommon\game_version.h">
+    <ClInclude Include="menudef.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="keycodes.h">
+    <ClInclude Include="..\game\surfaceflags.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="menudef.h">
+    <ClInclude Include="..\cgame\tr_types.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\game\q_shared.h">
+    <ClInclude Include="ui_force.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\shared\qcommon\qfiles.h">
+    <ClInclude Include="ui_local.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\game\surfaceflags.h">
+    <ClInclude Include="ui_public.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\shared\qcommon\tags.h">
+    <ClInclude Include="ui_shared.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="..\cgame\tr_types.h">
+    <ClInclude Include="..\qcommon\disablewarnings.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="ui_force.h">
+    <ClInclude Include="..\qcommon\game_version.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="ui_local.h">
+    <ClInclude Include="..\qcommon\q_shared.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="ui_public.h">
+    <ClInclude Include="..\qcommon\qfiles.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="ui_shared.h">
+    <ClInclude Include="..\qcommon\tags.h">
       <Filter>Header Files</Filter>
     </ClInclude>
   </ItemGroup>
-  <ItemGroup>
-    <None Include="ui.def">
-      <Filter>Header Files</Filter>
-    </None>
-  </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="..\win32\ui.rc">
       <Filter>win32</Filter>
diff --git a/codemp/ui/ui_public.h b/codemp/ui/ui_public.h
index 10622b6..6f97789 100644
--- a/codemp/ui/ui_public.h
+++ b/codemp/ui/ui_public.h
@@ -1,9 +1,9 @@
-// Copyright (C) 1999-2000 Id Software, Inc.
+// Copyright (C) 2001-2002 Raven Software
 //
 #ifndef __UI_PUBLIC_H__
 #define __UI_PUBLIC_H__
 
-#define UI_API_VERSION	7
+#define UI_API_VERSION	6
 
 typedef struct {
 	connstate_t		connState;
@@ -14,78 +14,87 @@ typedef struct {
 	char			messageString[MAX_STRING_CHARS];
 } uiClientState_t;
 
-typedef enum {
-	UI_ERROR,
+typedef enum 
+{
+	UI_ERROR,							
 	UI_PRINT,
 	UI_MILLISECONDS,
 	UI_CVAR_SET,
-	UI_CVAR_VARIABLEVALUE,
-	UI_CVAR_VARIABLESTRINGBUFFER,
+	UI_CVAR_VARIABLEVALUE,			
+
+	UI_CVAR_VARIABLESTRINGBUFFER,	
 	UI_CVAR_SETVALUE,
 	UI_CVAR_RESET,
 	UI_CVAR_CREATE,
 	UI_CVAR_INFOSTRINGBUFFER,
-	UI_ARGC,
+
+	UI_ARGC,							
 	UI_ARGV,
 	UI_CMD_EXECUTETEXT,
 	UI_FS_FOPENFILE,
 	UI_FS_READ,
-	UI_FS_WRITE,
+
+	UI_FS_WRITE,						
 	UI_FS_FCLOSEFILE,
 	UI_FS_GETFILELIST,
 	UI_R_REGISTERMODEL,
 	UI_R_REGISTERSKIN,
-	UI_R_REGISTERSHADERNOMIP,
-	UI_R_SHADERNAMEFROMINDEX,
+
+	UI_R_REGISTERSHADERNOMIP,			
 	UI_R_CLEARSCENE,
 	UI_R_ADDREFENTITYTOSCENE,
 	UI_R_ADDPOLYTOSCENE,
 	UI_R_ADDLIGHTTOSCENE,
-	UI_R_RENDERSCENE,
+
+	UI_R_RENDERSCENE,					
 	UI_R_SETCOLOR,
 	UI_R_DRAWSTRETCHPIC,
 	UI_UPDATESCREEN,
 	UI_CM_LERPTAG,
-	UI_CM_LOADMODEL,
+
+	UI_CM_LOADMODEL,					
 	UI_S_REGISTERSOUND,
 	UI_S_STARTLOCALSOUND,
 	UI_KEY_KEYNUMTOSTRINGBUF,
 	UI_KEY_GETBINDINGBUF,
-	UI_KEY_SETBINDING,
+
+	UI_KEY_SETBINDING,					
 	UI_KEY_ISDOWN,
 	UI_KEY_GETOVERSTRIKEMODE,
 	UI_KEY_SETOVERSTRIKEMODE,
 	UI_KEY_CLEARSTATES,
-	UI_KEY_GETCATCHER,
+
+	UI_KEY_GETCATCHER,					
 	UI_KEY_SETCATCHER,
 	UI_GETCLIPBOARDDATA,
 	UI_GETGLCONFIG,
 	UI_GETCLIENTSTATE,
-	UI_GETCONFIGSTRING,
+
+	UI_GETCONFIGSTRING,					
 	UI_LAN_GETPINGQUEUECOUNT,
 	UI_LAN_CLEARPING,
 	UI_LAN_GETPING,
 	UI_LAN_GETPINGINFO,
-	UI_CVAR_REGISTER,
+
+	UI_CVAR_REGISTER,					
 	UI_CVAR_UPDATE,
 	UI_MEMORY_REMAINING,
 	UI_GET_CDKEY,
 	UI_SET_CDKEY,
-	UI_VERIFY_CDKEY,
-	UI_R_REGISTERFONT,
-	UI_R_FONT_STRLENPIXELS,
-	UI_R_FONT_STRLENCHARS,
-	UI_R_FONT_STRHEIGHTPIXELS,
-	UI_R_FONT_DRAWSTRING,
-	UI_LANGUAGE_ISASIAN,
-	UI_LANGUAGE_USESSPACES,
-	UI_ANYLANGUAGE_READCHARFROMSTRING,
-	UI_R_MODELBOUNDS,
+
+	UI_R_REGISTERFONT,					
+	UI_R_GETTEXTWIDTH,
+	UI_R_GETTEXTHEIGHT,
+	UI_R_DRAWTEXT,
+	UI_R_DRAWTEXTWITHCURSOR,
+
+	UI_R_MODELBOUNDS,					
 	UI_PC_ADD_GLOBAL_DEFINE,
 	UI_PC_LOAD_SOURCE,
 	UI_PC_FREE_SOURCE,
 	UI_PC_READ_TOKEN,
-	UI_PC_SOURCE_FILE_AND_LINE,
+
+	UI_PC_SOURCE_FILE_AND_LINE,			
 	UI_PC_LOAD_GLOBAL_DEFINES,
 	UI_PC_REMOVE_ALL_GLOBAL_DEFINES,
 
@@ -93,37 +102,42 @@ typedef enum {
 	UI_S_STARTBACKGROUNDTRACK,
 	UI_REAL_TIME,
 	UI_LAN_GETSERVERCOUNT,
-	UI_LAN_GETSERVERADDRESSSTRING,
+
+	UI_LAN_GETSERVERADDRESSSTRING,		
 	UI_LAN_GETSERVERINFO,
 	UI_LAN_MARKSERVERVISIBLE,
 	UI_LAN_UPDATEVISIBLEPINGS,
 	UI_LAN_RESETPINGS,
-	UI_LAN_LOADCACHEDSERVERS,
+
+	UI_LAN_LOADCACHEDSERVERS,			
 	UI_LAN_SAVECACHEDSERVERS,
 	UI_LAN_ADDSERVER,
 	UI_LAN_REMOVESERVER,
 	UI_CIN_PLAYCINEMATIC,
-	UI_CIN_STOPCINEMATIC,
+
+	UI_CIN_STOPCINEMATIC,				
 	UI_CIN_RUNCINEMATIC,
 	UI_CIN_DRAWCINEMATIC,
 	UI_CIN_SETEXTENTS,
 	UI_R_REMAP_SHADER,
+
+	UI_VERIFY_CDKEY,					
 	UI_LAN_SERVERSTATUS,
 	UI_LAN_GETSERVERPING,
 	UI_LAN_SERVERISVISIBLE,
 	UI_LAN_COMPARESERVERS,
 
-	UI_MEMSET = 100,
+	UI_MEMSET = 100,					
 	UI_MEMCPY,
 	UI_STRNCPY,
 	UI_SIN,
 	UI_COS,
-	UI_ATAN2,
+
+	UI_ATAN2,							
 	UI_SQRT,
-	UI_MATRIXMULTIPLY,
+	UI_FLOOR,
 	UI_ANGLEVECTORS,
 	UI_PERPENDICULARVECTOR,
-	UI_FLOOR,
 	UI_CEIL,
 
 	UI_TESTPRINTINT,
@@ -131,89 +145,121 @@ typedef enum {
 
 	UI_ACOS,
 	UI_ASIN,
+	UI_MATRIXMULTIPLY,
 
-	UI_SP_GETNUMLANGUAGES,
-	UI_SP_GETLANGUAGENAME,
-	UI_SP_GETSTRINGTEXTSTRING = 200,
-
-/*
-Ghoul2 Insert Start
-*/
-	UI_G2_LISTSURFACES,
 	UI_G2_LISTBONES,
-	UI_G2_SETMODELS,
+	UI_G2_LISTSURFACES,
+	UI_G2_ADDBOLT,
+	UI_G2_REMOVEBOLT,
+
+	UI_G2_ATTACHG2MODEL,				
 	UI_G2_HAVEWEGHOULMODELS,
+	UI_G2_SETMODELS,
 	UI_G2_GETBOLT,
-	UI_G2_GETBOLT_NOREC,
-	UI_G2_GETBOLT_NOREC_NOROT,
 	UI_G2_INITGHOUL2MODEL,
-	UI_G2_COLLISIONDETECT,
-	UI_G2_COLLISIONDETECTCACHE,
-	UI_G2_CLEANMODELS,
+
+	UI_G2_CLEANMODELS,					
 	UI_G2_ANGLEOVERRIDE,
 	UI_G2_PLAYANIM,
-	UI_G2_GETBONEANIM,
-	UI_G2_GETBONEFRAME, //trimmed down version of GBA, so I don't have to pass all those unused args across the VM-exe border
 	UI_G2_GETGLANAME,
 	UI_G2_COPYGHOUL2INSTANCE,
-	UI_G2_COPYSPECIFICGHOUL2MODEL,
+
+	UI_G2_COPYSPECIFICGHOUL2MODEL,		
 	UI_G2_DUPLICATEGHOUL2INSTANCE,
-	UI_G2_HASGHOUL2MODELONINDEX,
 	UI_G2_REMOVEGHOUL2MODEL,
-	UI_G2_ADDBOLT,
-	UI_G2_SETBOLTON,
-	UI_G2_SETROOTSURFACE,
+
+	// CGenericParser2 (void *) routines
+	UI_GP_PARSE,						
+	UI_GP_PARSE_FILE,
+	UI_GP_CLEAN,
+	UI_GP_DELETE,
+	UI_GP_GET_BASE_PARSE_GROUP,
+
 	UI_G2_SETSURFACEONOFF,
-	UI_G2_SETNEWORIGIN,
-
-	UI_G2_GETTIME,
-	UI_G2_SETTIME,
-
-/*
-	//rww - RAGDOLL_BEGIN
-*/
-	UI_G2_SETRAGDOLL,
-	UI_G2_ANIMATEG2MODELS,
-/*
-	//rww - RAGDOLL_END
-*/
-
-	//rww - ik move method, allows you to specify a bone and move it to a world point (within joint constraints)
-	//by using the majority of gil's existing bone angling stuff from the ragdoll code.
-	UI_G2_SETBONEIKSTATE,
-	UI_G2_IKMOVE,
-
-	UI_G2_GETSURFACENAME,
+	UI_G2_REGISTERSKIN,
 	UI_G2_SETSKIN,
-	UI_G2_ATTACHG2MODEL,
-/*
-Ghoul2 Insert End
-*/
+	UI_G2_GETANIMFILENAMEINDEX,
+
+	// CGPGroup (void *) routines
+	UI_GPG_GET_NAME,					
+	UI_GPG_GET_NEXT,
+	UI_GPG_GET_INORDER_NEXT,
+	UI_GPG_GET_INORDER_PREVIOUS,
+	UI_GPG_GET_PAIRS,
+
+	UI_GPG_GET_INORDER_PAIRS,			
+	UI_GPG_GET_SUBGROUPS,
+	UI_GPG_GET_INORDER_SUBGROUPS,
+	UI_GPG_FIND_SUBGROUP,
+	UI_GPG_FIND_PAIR,
+
+	UI_GPG_FIND_PAIRVALUE,				
+
+	// CGPValue (void *) routines
+	UI_GPV_GET_NAME,
+	UI_GPV_GET_NEXT,
+	UI_GPV_GET_INORDER_NEXT,
+	UI_GPV_GET_INORDER_PREVIOUS,
+
+	UI_GPV_IS_LIST,						
+	UI_GPV_GET_TOP_VALUE,
+	UI_GPV_GET_LIST,
+	
+	UI_CL_READ_G2SKIN,					
+	UI_CL_READ_NPCFILES,
+	UI_CL_FREE_NPCFILES,
+	UI_CL_GET_MODEL_LIST,
+
+	UI_PARENTAL_UPDATE,					
+	UI_PARENTAL_SET_PASSWORD,
+	UI_PARENTAL_GET_PASSWORD,
+
+	UI_VM_LOCALALLOC,
+	UI_VM_LOCALALLOCUNALIGNED,
+	UI_VM_LOCALTEMPALLOC,
+	UI_VM_LOCALTEMPFREE,
+	UI_VM_LOCALSTRINGALLOC,
+
+	UI_NET_AVAILABLE,
+
+	UI_VERSION_GET_DESCRIPTION,
+	UI_VERSION_GET_NUM_SITES,
+	UI_VERSION_GET_SITE,
+	UI_VERSION_DOWNLOAD,
+
+	UI_PB_ENABLE,
+	UI_PB_DISABLE,
+	UI_PB_ISENABLED,
+
+	UI_GET_TEAM_COUNT,
+	UI_GET_TEAM_SCORE,
+
 } uiImport_t;
 
-typedef enum {
+typedef enum 
+{
 	UIMENU_NONE,
 	UIMENU_MAIN,
 	UIMENU_INGAME,
-	UIMENU_PLAYERCONFIG,
+	UIMENU_BAD_CD_KEY,
 	UIMENU_TEAM,
-	UIMENU_POSTGAME,
-	UIMENU_PLAYERFORCE,
-	UIMENU_SIEGEMESSAGE,
-	UIMENU_SIEGEOBJECTIVES,
-	UIMENU_VOICECHAT,
-	UIMENU_CLOSEALL,
-	UIMENU_CLASSSEL
-};
-typedef int uiMenuCommand_t;
-
-#define SORT_HOST			0
-#define SORT_MAP			1
-#define SORT_CLIENTS		2
-#define SORT_GAME			3
-#define SORT_PING			4
-
-typedef enum {
+	UIMENU_OBJECTIVES,
+	UIMENU_OUTFITTING,
+	UIMENU_RADIO,
+	UIMENU_VERSION,
+
+} uiMenuCommand_t;
+
+#define	SORT_NEEDPASS		0
+#define SORT_HOST			1
+#define SORT_MAP			2
+#define SORT_CLIENTS		3
+#define SORT_GAME			4
+#define SORT_PING			5
+#define SORT_PUNKBUSTER		6
+
+typedef enum 
+{
 	UI_GETAPIVERSION = 0,	// system reserved
 
 	UI_INIT,
@@ -243,11 +289,16 @@ typedef enum {
 	UI_DRAW_CONNECT_SCREEN,
 //	void	UI_DrawConnectScreen( qboolean overlay );
 	UI_HASUNIQUECDKEY,
+
+	UI_CLOSEALL,
+//	void	Menus_CloseAll ( void );
+
 // if !overlay, the background will be drawn, otherwise it will be
 // overlayed over whatever the cgame has drawn.
 // a GetClientState syscall will be made to get the current strings
 
-	UI_MENU_RESET
+	UI_DRAW_LOADING_SCREEN,
+
 } uiExport_t;
 
 #endif
diff --git a/codemp/win32/engine.rc b/codemp/win32/engine.rc
index a513c40..e9a04e1 100644
--- a/codemp/win32/engine.rc
+++ b/codemp/win32/engine.rc
@@ -80,12 +80,12 @@ BEGIN
     BEGIN
         BLOCK "040904b0"
         BEGIN
-            VALUE "Comments", "OpenJK Contributors"
-            VALUE "FileDescription", "OpenJK Multiplayer"
+            VALUE "Comments", "OpenSOF2 Contributors"
+            VALUE "FileDescription", "OpenSOF2 Multiplayer"
             VALUE "FileVersion", VERSION_STRING
-            VALUE "InternalName", "JK MP"
-            VALUE "OriginalFilename", "OpenJK.exe"
-            VALUE "ProductName", "OpenJK"
+            VALUE "InternalName", "SOF2 MP"
+            VALUE "OriginalFilename", "OpenSOF2MP.exe"
+            VALUE "ProductName", "OpenSOF2"
             VALUE "ProductVersion", VERSION_STRING
         END
     END
diff --git a/codemp/win32/icon.ico b/codemp/win32/icon.ico
index 1978a752399938283fbcc66f14cb6b614dd9a597..6cf4a4663ba9a79140f25f595815de53dc7a7f38 100644
GIT binary patch
literal 2686
zcmeH{y^fqP5XWb=k+4#2np_?sB`1okM6-{R@}w(Fhb0PIx`J0pL~|0&K2kd9od1ly
zz+$)*QPL#CVUOqM`C#llq641G<%IDaeSJ^#k%&Iyz2G%?*)9UMEhcO<M)vavm9Ez-
zW+>$4kGy9MFCI2wuvot(?kx!B{<s*mmm(0Noed^bH}R>~s7yQtSaD#nU<!msQR6b&
z4Q8nTX6R6bPi8iX1xUCFtEn!I$|iA@O_E4<L1W<!?2DOCSVfNjd4v(><v26Z1o5UI
zYK3EjeJnNH@UpZikibyFHs_*6LW3s9sNkz|#z%b2n(^A82h1_3Ek0McO@&K+I~=hQ
z7-=@sb8g_>4U4J}f;ZmD0*6nzqkQ%%gr)=LbqhE%xu*C~K+fDhvrG{RYYLQz{uL5>
zvBALGxu&za%Ct5Jz!I#Y%24LkkID~p>}TVwHJ!5l2Z6hn*V#O2<=Mesxa%hCtiX2T
z_9av>LsW;DS@gHhX##e+aaW}Yklsw(mCMkg!{b++qQ7zu(N^*u9dG?`_MZE8O!&8x
z96Fk?&E;wn#VPgYgDr~3M>%0W<CWmh@yl1ZT8K}nzqe1>NV+xIXuV1KsD^BekKgcr
zwgZ`V%rItNrT!KNPvG95O}0P}?#26xR4x3$+dSnXZf!d}41{Z>)_2c2-&kCb;mb&$
zz@HNTS`V&rzOIyOeLdbM#|n2_X{WWQb(L_OX>PUSz8=%tBisAjF+Ze-AEGsVamuME
cUpIn_sp-3}>^a5X6aAYa|1$m$|7-_-0x`6QRsaA1

literal 3262
zcmd5;_g7O{5DqD?q=%43fJ7vSAWFv|MHDb1N0R`88dL<qf(jz5B190dMR0A1g(6Y}
z6jT%ukfPX7Fob~Uv4DGab^nW<m?LLZM2=^F*d#A`@7}rJo%!awGa(Qx;4PIB;9E$z
zLMIUT1OmYcE*K&#gv&H;dgZ_zmu9{`4^01yNVFi6EGY0Hn{G%%3ybM5{+T6(OytnX
z)-0mEkTz3D6LUzGbTUFA{%qZJ=b1Rk*NK1TSZ-=u=;mm@;-b8Oc{Xe+X}arwW+z~g
z<CeOOy?a}cAAcqzVtnlV*4Q91`@g{lwq-&rHQHmuIM{S7{z^{7=*!{Eb%D-e6s7!n
z8X$i_I~^l&aDv|~){*TIL;C)k7qmA^euJA6nHq(+SirDg;Y199Z2ydcujfH6bes&!
z=SW!VW5V-xZz|QL4-WJ-U(BvQo?;kycCKLSfsDi*No)M)No+VoHjM&devR?NC$O}n
zQ)GP7T4g|4$?<IoG0VKIvoxMYgTARSzAkt9h|#bw&L`M~8MDm4xF|n0K|Rk7=d%!q
z_lKZgCLmNRCgLtZ3w9?y>}p-T)XR=z;U=N(jP(Zo8w(R_a#h1a`W-8MT<xf0HZjCQ
zTvu`CWI;xN6HCZJr;Y+5WYH)dQtZf{`1fx{)7SXR9WV(Gn=PiMM0x`L)nf@&IZC79
zMY7V}L5K<1sGA+KKFp!_-mNnQY5ubqTm~}5!9&QzSt2xT^@2af-&N?+G=YLc`?iJq
z*er5kW~}lV9vZw>m{7G}1^L~ga-T0_$Q_xxl4CT%cDnRP<KTccIee}i4(a|v#<#z)
zdxR&qtGRk)urGP3y=uO&x4W&W`fO&jW6>5rzz6>??^hXKJlDo~ZVDAvp2~rs)-0B7
zSZsa&Zew>#eN2E@z(yv`G%zm{qS}q2<L}=#mL6W>%J8(O?@d~+?|;(Kc%dqL89>$P
z5-w?#hJn7abidZhgP%VA-BA8}pfe}Tl~GZ+>-DRb2e&I-#FJ+MqY&i|c+Kgo@v*U!
znHqNq#%G~kGqCI=#q%e<?bj<?8_r)YSbIsUe%#Y`t5WyZ$B&KW#}sZHTPw^>f*;<o
z0`Tk4=LgNE<LD$5F>rFYyJdT0+3QhbZc>P&(BuY(j`-N)+Qh|Ad+&8L*Ou%Iu0F7`
ztL;`-`|YN(BjN6BTdwI8&lI4U>lO?T_IEZ{t?=QosN`>{ClJ^)vRW>D(AqF!c)ll2
zK7)^f4Tu4@SmaDEN{bj7Hr5^8P;(&i;r-6C{Dc&RXqK2}uA&kix+~UesQ>Y!dpB14
zi#c@4_xLOtS?Me2xl=!^f3`<6-;57tP+}ZKI4u9H&&0a?sP6Wb+LD9&)(5!QQZb5&
z3aJ_Y#gj)J*VS?nxcWUl4I_uTvRdj&UK;h<goTbGY(mKrD`Z;~;2S_cwRuqw?%i&`
zS=-yyy2M+;#7!j*gpm~=_-e$^-c$x4bZioQ5WlAsD?OU_=JhMk^E^9j;xGb!%4hrr
z&}UBMz~j#1^pLJQ*OmvnF)>p+17le7VSKEjFvCNF0@U~ZgC8?^Nc!ppqa%jO<GX{L
zXb_Rv%#8oiXaIcBPv67Nlx30#`3#vY7e}DRk^`NnHK(&bjJ-`;C6`(uKPsn?m$13)
zmWGQU#~6QWYfIEjk(nP8zHS5HKk8{y`H5}0h^ZZuh+-}p6JV`>+TC&eQm``vYU%gR
zn@6Akf-F;42N(yR=WSEL5ul=`5Nx@WEo!gP;UUmZxmFF#FZC2yF-$n%Jd_~aZq1(`
z-fxZawdcd8laMp9BkT@>FFuqGC2M7n6c~egB82{^aMkzsRUh6^nx($qaXZYN2W1we
zkfc_W*hR9}!}`<tscyCillnvF&09c~5VFz0*{t$Y1=lX04f7DezXe+!9^%TZFF#Rz
zbkq4vRd-vn!rjV_hl^OmC0;f?cdwV9%J;U%d8}!5GRVF)2k~{F7wp|!d9Elb%yW(n
z7V3=El^w6qZN9Ki-P3kM<--NdL@Ru+R$t7`NSbSdnEK0<%uG-OH;@P(6Or-B>JX2D
z?48>5r0p^CrmEulqODbVv7IefGc^ADcO~Uz?F<i?Be68~y9qJ>8)u4pAPQPAk3o|1
z5XAzQJ;}<J#>+P^>8_pI|FH8;?v7RA{w_8g5|>T{4M4x10&0pW@CrvrA~q#ZMyb6}
zc%^U)<hSictzs@6^a)eo#uUq^IYmWDjsjA3>FIO%n~$chxZ8Xc8afl7qzFtC@EbFT
z0*G3r42h3i7#-@iQKJ;G|I7cMaEhU2Ffjt3Nrv{v!U#}0ewp)coHswh761rrn?L5d
KF{$PMZ15kAg)o)?

diff --git a/codemp/win32/win_glimp.cpp b/codemp/win32/win_glimp.cpp
index 163d772..e786544 100644
--- a/codemp/win32/win_glimp.cpp
+++ b/codemp/win32/win_glimp.cpp
@@ -22,7 +22,6 @@
 #include "resource.h"
 #include "glw_win.h"
 #include "win_local.h"
-#include "qcommon/stringed_ingame.h"
 extern void WG_CheckHardwareGamma( void );
 extern void WG_RestoreGamma( void );
 
@@ -715,6 +714,7 @@ static rserr_t GLW_SetMode( int mode,
 		Com_Printf (" invalid mode\n" );
 		return RSERR_INVALID_MODE;
 	}
+	glConfig.windowAspect = glConfig.vidWidth / (glConfig.vidHeight * 1.0f);
 	Com_Printf (" %d %d %s\n", glConfig.vidWidth, glConfig.vidHeight, win_fs[cdsFullscreen] );
 
 	//
@@ -733,27 +733,10 @@ static rserr_t GLW_SetMode( int mode,
 	{
 		if (!cdsFullscreen && (colorbits == 0 || colorbits >= 15 ) )
 		{
-			// since I can't be bothered trying to mess around with asian codepages and MBCS stuff for a windows
-			//	error box that'll only appear if something's seriously fucked then I'm going to fallback to
-			//	english text when these would otherwise be used...
-			//
-			char sErrorHead[1024];	// ott
-
-			extern qboolean Language_IsAsian(void);
-			Q_strncpyz(sErrorHead, Language_IsAsian() ? "Low Desktop Color Depth" : ri.SE_GetString("CON_TEXT_LOW_DESKTOP_COLOUR_DEPTH"), sizeof(sErrorHead) );
-
-			const char *psErrorBody = Language_IsAsian() ?
-												"It is highly unlikely that a correct windowed\n"
-												"display can be initialized with the current\n"
-												"desktop display depth.  Select 'OK' to try\n"
-												"anyway.  Select 'Cancel' to try a fullscreen\n"
-												"mode instead."
-												:
-												ri.SE_GetString("CON_TEXT_TRY_ANYWAY");
-
 			if ( MessageBox( NULL, 							
-						psErrorBody,
-						sErrorHead,
+						"It is highly unlikely that a correct\nwindowed display can be initialized with\nthe current desktop display depth.  Select\n"
+						"'OK' to try anyway.  Press 'Cancel' if you\nhave a 3Dfx Voodoo, Voodoo-2, or Voodoo Rush\n3D accelerator installed, or if you otherwise\nwish to quit.",
+						"Low Desktop Color Depth",
 						MB_OKCANCEL | MB_ICONEXCLAMATION ) != IDOK )
 			{
 				return RSERR_INVALID_MODE;
@@ -972,13 +955,13 @@ static void GLW_InitTextureCompression( void )
 	if ( !r_ext_compressed_textures->value )
 	{
 		// Compressed textures are off
-		glConfig.textureCompression = TC_NONE;
+		//glConfig.textureCompression = TC_NONE;
 		Com_Printf ("...ignoring texture compression\n" );
 	}
 	else if ( !old_tc && !newer_tc )
 	{
 		// Requesting texture compression, but no method found
-		glConfig.textureCompression = TC_NONE;
+		//glConfig.textureCompression = TC_NONE;
 		Com_Printf ("...no supported texture compression method found\n" );
 		Com_Printf (".....ignoring texture compression\n" );
 	}
@@ -992,13 +975,13 @@ static void GLW_InitTextureCompression( void )
 			{
 				Com_Printf ("...no tc preference specified\n" );
 				Com_Printf (".....using GL_EXT_texture_compression_s3tc\n" );
-				glConfig.textureCompression = TC_S3TC_DXT;
+				//glConfig.textureCompression = TC_S3TC_DXT;
 			}
 			else
 			{
 				Com_Printf ("...no tc preference specified\n" );
 				Com_Printf (".....using GL_S3_s3tc\n" );
-				glConfig.textureCompression = TC_S3TC;
+				//glConfig.textureCompression = TC_S3TC;
 			}
 		}
 		else
@@ -1010,12 +993,12 @@ static void GLW_InitTextureCompression( void )
 				if ( r_ext_preferred_tc_method->integer == TC_S3TC )
 				{
 					Com_Printf ("...using preferred tc method, GL_S3_s3tc\n" );
-					glConfig.textureCompression = TC_S3TC;
+					//glConfig.textureCompression = TC_S3TC;
 				}
 				else
 				{
 					Com_Printf ("...using preferred tc method, GL_EXT_texture_compression_s3tc\n" );
-					glConfig.textureCompression = TC_S3TC_DXT;
+					//glConfig.textureCompression = TC_S3TC_DXT;
 				}
 			}
 			else
@@ -1027,14 +1010,14 @@ static void GLW_InitTextureCompression( void )
 					if ( old_tc )
 					{
 						Com_Printf ("...using GL_S3_s3tc\n" );
-						glConfig.textureCompression = TC_S3TC;
+						//glConfig.textureCompression = TC_S3TC;
 					}
 					else
 					{
 						// Drat, preference can't be honored 
 						Com_Printf ("...preferred tc method, GL_S3_s3tc not available\n" );
 						Com_Printf (".....falling back to GL_EXT_texture_compression_s3tc\n" );
-						glConfig.textureCompression = TC_S3TC_DXT;
+						//glConfig.textureCompression = TC_S3TC_DXT;
 					}
 				}
 				else
@@ -1043,14 +1026,14 @@ static void GLW_InitTextureCompression( void )
 					if ( newer_tc )
 					{
 						Com_Printf ("...using GL_EXT_texture_compression_s3tc\n" );
-						glConfig.textureCompression = TC_S3TC_DXT;
+						//glConfig.textureCompression = TC_S3TC_DXT;
 					}
 					else
 					{
 						// Drat, preference can't be honored 
 						Com_Printf ("...preferred tc method, GL_EXT_texture_compression_s3tc not available\n" );
 						Com_Printf (".....falling back to GL_S3_s3tc\n" );
-						glConfig.textureCompression = TC_S3TC;
+						//glConfig.textureCompression = TC_S3TC;
 					}
 				}
 			}
@@ -1097,7 +1080,7 @@ static void GLW_InitExtensions( void )
 	}
 
 	// GL_EXT_texture_filter_anisotropic
-	glConfig.maxTextureFilterAnisotropy = 0;
+	/*glConfig.maxTextureFilterAnisotropy = 0;
 	if ( strstr( glConfig.extensions_string, "EXT_texture_filter_anisotropic" ) )
 	{
 #define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF	//can't include glext.h here ... sigh
@@ -1119,10 +1102,10 @@ static void GLW_InitExtensions( void )
 		}
 	}
 	else
-	{
+	{*/
 		Com_Printf ("...GL_EXT_texture_filter_anisotropic not found\n" );
 		ri.Cvar_Set( "r_ext_texture_filter_anisotropic_avail", "0" );
-	}
+	//}
 
 	// GL_EXT_clamp_to_edge
 	glConfig.clampToEdgeAvailable = qfalse;
@@ -1657,10 +1640,10 @@ void GLimp_Init( void )
 	GLW_StartOpenGL();
 
 	// get our config strings
-	glConfig.vendor_string = (const char *) qglGetString (GL_VENDOR);
-	glConfig.renderer_string = (const char *) qglGetString (GL_RENDERER);
-	glConfig.version_string = (const char *) qglGetString (GL_VERSION);
-	glConfig.extensions_string = (const char *) qglGetString (GL_EXTENSIONS);
+	strcpy(glConfig.vendor_string, (const char *) qglGetString (GL_VENDOR));
+	strcpy(glConfig.renderer_string, (const char *) qglGetString (GL_RENDERER));
+	strcpy(glConfig.version_string, (const char *) qglGetString (GL_VERSION));
+	strcpy(glConfig.extensions_string, (const char *) qglGetString (GL_EXTENSIONS));
 	
 	if (!glConfig.vendor_string || !glConfig.renderer_string || !glConfig.version_string || !glConfig.extensions_string)
 	{
@@ -1722,7 +1705,7 @@ void GLimp_Init( void )
 		
 		GLW_InitExtensions();	//get the values for test below
 		//this must be a really sucky card!
-		if ( (glConfig.textureCompression == TC_NONE) || (glConfig.maxActiveTextures < 2)  || (glConfig.maxTextureSize <= 512) )
+		if (/* (glConfig.textureCompression == TC_NONE) ||*/ (glConfig.maxActiveTextures < 2)  || (glConfig.maxTextureSize <= 512) )
 		{
 			ri.Cvar_Set( "r_picmip", "2");
 			ri.Cvar_Set( "r_colorbits", "16");
@@ -1747,7 +1730,7 @@ void GLimp_Init( void )
 void GLimp_Shutdown( void )
 {
 //	const char *strings[] = { "soft", "hard" };
-//	const char *success[] = { "failed", "success" };
+	const char *success[] = { "failed", "success" };
 	int retVal;
 
 	// FIXME: Brian, we need better fallbacks from partially initialized failures
@@ -1765,14 +1748,14 @@ void GLimp_Shutdown( void )
 	{
 		retVal = qwglMakeCurrent( NULL, NULL ) != 0;
 
-//		Com_Printf ("...wglMakeCurrent( NULL, NULL ): %s\n", success[retVal] );
+		Com_Printf ("...wglMakeCurrent( NULL, NULL ): %s\n", success[retVal] );
 	}
 
 	// delete HGLRC
 	if ( glw_state.hGLRC )
 	{
 		retVal = qwglDeleteContext( glw_state.hGLRC ) != 0;
-//		Com_Printf ("...deleting GL context: %s\n", success[retVal] );
+		Com_Printf ("...deleting GL context: %s\n", success[retVal] );
 		glw_state.hGLRC = NULL;
 	}
 
@@ -1780,14 +1763,14 @@ void GLimp_Shutdown( void )
 	if ( glw_state.hDC )
 	{
 		retVal = ReleaseDC( tr.wv->hWnd, glw_state.hDC ) != 0;
-//		Com_Printf ("...releasing DC: %s\n", success[retVal] );
+		Com_Printf ("...releasing DC: %s\n", success[retVal] );
 		glw_state.hDC   = NULL;
 	}
 
 	// destroy window
 	if ( tr.wv->hWnd )
 	{
-//		Com_Printf ("...destroying window\n" );
+		Com_Printf ("...destroying window\n" );
 		ShowWindow( tr.wv->hWnd, SW_HIDE );
 		DestroyWindow( tr.wv->hWnd );
 		tr.wv->hWnd = NULL;
@@ -1804,7 +1787,7 @@ void GLimp_Shutdown( void )
 	// reset display settings
 	if ( glw_state.cdsFullscreen )
 	{
-//		Com_Printf ("...resetting display\n" );
+		Com_Printf ("...resetting display\n" );
 		ChangeDisplaySettings( 0, 0 );
 		glw_state.cdsFullscreen = qfalse;
 	}
diff --git a/codemp/win32/win_input.cpp b/codemp/win32/win_input.cpp
index b701032..b26028d 100644
--- a/codemp/win32/win_input.cpp
+++ b/codemp/win32/win_input.cpp
@@ -410,39 +410,39 @@ void IN_DIMouse( int *mx, int *my ) {
 		switch (od.dwOfs) {
 		case DIMOFS_BUTTON0:
 			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE1, qtrue, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE1, qtrue, 0, NULL );
 			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE1, qfalse, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE1, qfalse, 0, NULL );
 			break;
 
 		case DIMOFS_BUTTON1:
 			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE2, qtrue, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE2, qtrue, 0, NULL );
 			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE2, qfalse, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE2, qfalse, 0, NULL );
 			break;
 			
 		case DIMOFS_BUTTON2:
 			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE3, qtrue, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE3, qtrue, 0, NULL );
 			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE3, qfalse, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE3, qfalse, 0, NULL );
 			break;
 
 		case DIMOFS_BUTTON3:
 			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE4, qtrue, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE4, qtrue, 0, NULL );
 			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE4, qfalse, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE4, qfalse, 0, NULL );
 			break;
 
 		// needs DIRECTINPUT_VERSION >= 0x0700 to compile, which we seem to have, so...
 		//
 		case DIMOFS_BUTTON4:
 			if (od.dwData & 0x80)
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE5, qtrue, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE5, qtrue, 0, NULL );
 			else
-				Sys_QueEvent( od.dwTimeStamp, SE_KEY, A_MOUSE5, qfalse, 0, NULL );
+				Sys_QueEvent( od.dwTimeStamp, SE_KEY, K_MOUSE5, qfalse, 0, NULL );
 			break;
 		}
 	}
@@ -564,11 +564,11 @@ IN_MouseEvent
 
 static int mouseConvert[MAX_MOUSE_BUTTONS] =
 {
-	A_MOUSE1,
-	A_MOUSE2,
-	A_MOUSE3,
-	A_MOUSE4,
-	A_MOUSE5
+	K_MOUSE1,
+	K_MOUSE2,
+	K_MOUSE3,
+	K_MOUSE4,
+	K_MOUSE5
 };
 
 void IN_MouseEvent (int mstate)
@@ -732,7 +732,7 @@ void IN_Frame (void) {
 		//}
 	}
 
-	if( !Cvar_VariableIntegerValue("r_fullscreen") && loading ) {
+	if( !Cvar_VariableIntegerValue("r_fullscreen") && loading && !(cls.keyCatchers & KEYCATCH_UI)) {
 		IN_DeactivateMouse ();
 		return;
 	}
@@ -874,15 +874,15 @@ int JoyToI( int value ) {
 }
 
 int	joyDirectionKeys[16] = {
-	A_CURSOR_LEFT, A_CURSOR_RIGHT,
-	A_CURSOR_UP, A_CURSOR_DOWN,
-	A_JOY16, A_JOY17,
-	A_JOY18, A_JOY19,
-	A_JOY20, A_JOY21,
-	A_JOY22, A_JOY23,
-
-	A_JOY24, A_JOY25,
-	A_JOY26, A_JOY27
+	K_LEFTARROW, K_RIGHTARROW,
+	K_UPARROW, K_DOWNARROW,
+	K_JOY16, K_JOY17,
+	K_JOY18, K_JOY19,
+	K_JOY20, K_JOY21,
+	K_JOY22, K_JOY23,
+
+	K_JOY24, K_JOY25,
+	K_JOY26, K_JOY27
 };
 
 /*
@@ -929,10 +929,10 @@ void IN_JoyMove( void ) {
 	buttonstate = joy.ji.dwButtons;
 	for ( i=0 ; i < joy.jc.wNumButtons ; i++ ) {
 		if ( (buttonstate & (1<<i)) && !(joy.oldbuttonstate & (1<<i)) ) {
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_JOY0 + i, qtrue, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_JOY1 + i, qtrue, 0, NULL );
 		}
 		if ( !(buttonstate & (1<<i)) && (joy.oldbuttonstate & (1<<i)) ) {
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_JOY0 + i, qfalse, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_JOY1 + i, qfalse, 0, NULL );
 		}
 	}
 	joy.oldbuttonstate = buttonstate;
@@ -1017,9 +1017,9 @@ static void MIDI_NoteOff( int note )
 {
 	int qkey;
 
-	qkey = note - 60 + A_AUX0;
+	qkey = note - 60 + K_AUX1;
 
-	if ( qkey < A_AUX0 )
+	if ( qkey < K_AUX1 )
 	{
 		return;
 	}
@@ -1035,9 +1035,9 @@ static void MIDI_NoteOn( int note, int velocity )
 		MIDI_NoteOff( note );
 	}
 
-	qkey = note - 60 + A_AUX0;
+	qkey = note - 60 + K_AUX1;
 
-	if ( qkey < A_AUX0 )
+	if ( qkey < K_AUX1 )
 	{
 		return;
 	}
diff --git a/codemp/win32/win_main.cpp b/codemp/win32/win_main.cpp
index 0a57bed..b6fc327 100644
--- a/codemp/win32/win_main.cpp
+++ b/codemp/win32/win_main.cpp
@@ -12,7 +12,6 @@
 #include <direct.h>
 #include <io.h>
 #include <conio.h>
-#include "qcommon/stringed_ingame.h"
 
 #define	CD_BASEDIR	"gamedata\\gamedata"
 #define	CD_EXE		"jamp.exe"
@@ -594,7 +593,7 @@ void * QDECL Sys_LoadGameDll( const char *name, int (QDECL **entryPoint)(int, ..
 	char	*fn;
 	char	filename[MAX_QPATH];
 
-	Com_sprintf( filename, sizeof( filename ), "%sx86.dll", name );
+	Com_sprintf( filename, sizeof( filename ), "mp/%sx86.dll", name );
 
 	if (!Sys_UnpackDLL(filename))
 	{
@@ -1152,28 +1151,6 @@ void QuickMemTest(void)
 		{
 			free(pvData);
 		}
-		else
-		{
-			// err...
-			//
-			LPCSTR psContinue = re.Language_IsAsian() ? 
-								"Your machine failed to allocate %dMB in a memory test, which may mean you'll have problems running this game all the way through.\n\nContinue anyway?"
-								: 
-								SE_GetString("CON_TEXT_FAILED_MEMTEST");
-								// ( since it's too much hassle doing MBCS code pages and decodings etc for MessageBox command )
-
-			#define GetYesNo(psQuery)	(!!(MessageBox(NULL,psQuery,"Query",MB_YESNO|MB_ICONWARNING|MB_TASKMODAL)==IDYES))
-			if (!GetYesNo(va(psContinue,iMemTestMegs)))
-			{
-				LPCSTR psNoMem = re.Language_IsAsian() ?
-								"Insufficient memory to run this game!\n"
-								:
-								SE_GetString("CON_TEXT_INSUFFICIENT_MEMORY");
-								// ( since it's too much hassle doing MBCS code pages and decodings etc for MessageBox command )
-
-				Com_Error( ERR_FATAL, psNoMem );
-			}
-		}
 	}
 }
 
diff --git a/codemp/win32/win_qgl.cpp b/codemp/win32/win_qgl.cpp
index 0f0e59f..28a4291 100644
--- a/codemp/win32/win_qgl.cpp
+++ b/codemp/win32/win_qgl.cpp
@@ -2781,11 +2781,11 @@ static void APIENTRY logViewport(GLint x, GLint y, GLsizei width, GLsizei height
 */
 void QGL_Shutdown( void )
 {
-//	Com_Printf ("...shutting down QGL\n" );
+	Com_Printf ("...shutting down QGL\n" );
 
 	if ( glw_state.hinstOpenGL )
 	{
-//		Com_Printf ("...unloading OpenGL DLL\n" );
+		Com_Printf ("...unloading OpenGL DLL\n" );
 		FreeLibrary( glw_state.hinstOpenGL );
 	}
 
diff --git a/codemp/win32/win_syscon.cpp b/codemp/win32/win_syscon.cpp
index 0f4e208..92755c4 100644
--- a/codemp/win32/win_syscon.cpp
+++ b/codemp/win32/win_syscon.cpp
@@ -113,8 +113,8 @@ static LONG WINAPI ConWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lPara
 	case WM_CTLCOLORSTATIC:
 		if ( ( HWND ) lParam == s_wcd.hwndBuffer )
 		{
-			SetBkColor( ( HDC ) wParam, RGB( 0, 0, 0 ) );
-			SetTextColor( ( HDC ) wParam, RGB( 249, 249, 000 ) );
+			SetBkColor( ( HDC ) wParam, RGB( 142, 162, 98 ) );
+			SetTextColor( ( HDC ) wParam, RGB( 0, 0, 0 ) );
 			return ( long ) s_wcd.hbrEditBackground;
 		}
 		else if ( ( HWND ) lParam == s_wcd.hwndErrorBox )
@@ -160,7 +160,7 @@ static LONG WINAPI ConWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lPara
 		}
 		break;
 	case WM_CREATE:
-		s_wcd.hbrEditBackground =  CreateSolidBrush( RGB( 0x00, 0x00, 0x00 ) );
+		s_wcd.hbrEditBackground =  CreateSolidBrush( RGB( 142, 162, 98 ) );
 		s_wcd.hbrErrorBackground = CreateSolidBrush( RGB( 0x80, 0x80, 0x80 ) );
 		SetTimer( hWnd, 1, 1000, NULL );
 		break;
@@ -262,7 +262,7 @@ void Sys_CreateConsole( void )
 	HDC hDC;
 	WNDCLASS wc;
 	RECT rect;
-	const char *DEDCLASS = "JAMP WinConsole";
+	const char *DEDCLASS = "SOF2MP WinConsole";
 	int nHeight;
 	int swidth, sheight;
 	int DEDSTYLE = WS_POPUPWINDOW | WS_CAPTION | WS_MINIMIZEBOX;
@@ -276,7 +276,7 @@ void Sys_CreateConsole( void )
 	wc.hInstance     = g_wv.hInstance;
 	wc.hIcon         = LoadIcon( g_wv.hInstance, MAKEINTRESOURCE(IDI_ICON1));
 	wc.hCursor       = LoadCursor (NULL,IDC_ARROW);
-	wc.hbrBackground = (HBRUSH__ *)COLOR_INACTIVEBORDER;
+	wc.hbrBackground = (HBRUSH__ *)GetSysColorBrush(COLOR_3DFACE);
 	wc.lpszMenuName  = 0;
 	wc.lpszClassName = DEDCLASS;
 
@@ -285,7 +285,7 @@ void Sys_CreateConsole( void )
 	}
 
 	rect.left = 0;
-	rect.right = 600;
+	rect.right = 540;
 	rect.top = 0;
 	rect.bottom = 450;
 	AdjustWindowRect( &rect, DEDSTYLE, FALSE );
@@ -302,7 +302,7 @@ void Sys_CreateConsole( void )
 							   DEDCLASS,
 							   CLIENT_CONSOLE_TITLE,
 							   DEDSTYLE,
-							   ( swidth - 600 ) / 2, ( sheight - 450 ) / 2 , rect.right - rect.left + 1, rect.bottom - rect.top + 1,
+							   ( swidth - 540 ) / 2, ( sheight - 450 ) / 2 , rect.right - rect.left + 1, rect.bottom - rect.top + 1,
 							   NULL,
 							   NULL,
 							   g_wv.hInstance,
diff --git a/codemp/win32/win_wndproc.cpp b/codemp/win32/win_wndproc.cpp
index afbbd5d..abca8fa 100644
--- a/codemp/win32/win_wndproc.cpp
+++ b/codemp/win32/win_wndproc.cpp
@@ -103,63 +103,63 @@ static void VID_AppActivate(BOOL fActive, BOOL minimize)
 static byte virtualKeyConvert[0x92][2] =
 {
 	{ 0,				0				},     
-	{ A_MOUSE1,			A_MOUSE1		}, // VK_LBUTTON 01 Left mouse button  
-	{ A_MOUSE2,			A_MOUSE2		}, // VK_RBUTTON 02 Right mouse button  
+	{ K_MOUSE1,			K_MOUSE1		}, // VK_LBUTTON 01 Left mouse button  
+	{ K_MOUSE2,			K_MOUSE2		}, // VK_RBUTTON 02 Right mouse button  
 	{ 0,				0				}, // VK_CANCEL 03 Control-break processing  
-	{ A_MOUSE3,			A_MOUSE3		}, // VK_MBUTTON 04 Middle mouse button (three-button mouse)  
-	{ A_MOUSE4,			A_MOUSE4		}, // VK_XBUTTON1 05 Windows 2000/XP: X1 mouse button 
-	{ A_MOUSE5,			A_MOUSE5		}, // VK_XBUTTON2 06 Windows 2000/XP: X2 mouse button 
+	{ K_MOUSE3,			K_MOUSE3		}, // VK_MBUTTON 04 Middle mouse button (three-button mouse)  
+	{ K_MOUSE4,			K_MOUSE4		}, // VK_XBUTTON1 05 Windows 2000/XP: X1 mouse button 
+	{ K_MOUSE5,			K_MOUSE5		}, // VK_XBUTTON2 06 Windows 2000/XP: X2 mouse button 
 	{ 0,				0				}, // 07 Undefined  
-	{ A_BACKSPACE,		A_BACKSPACE		}, // VK_BACK 08 BACKSPACE key  
-	{ A_TAB,			A_TAB			}, // VK_TAB 09 TAB key  
+	{ K_BACKSPACE,		K_BACKSPACE		}, // VK_BACK 08 BACKSPACE key  
+	{ K_TAB,			K_TAB			}, // VK_TAB 09 TAB key  
 	{ 0,				0				}, // 0A Reserved  
 	{ 0,				0				}, // 0B Reserved  
-	{ A_KP_5,			0				}, // VK_CLEAR 0C CLEAR key  
-	{ A_ENTER, 			A_KP_ENTER 		}, // VK_RETURN 0D ENTER key  
+	{ K_KP_5,			0				}, // VK_CLEAR 0C CLEAR key  
+	{ K_ENTER,			K_KP_ENTER 		}, // VK_RETURN 0D ENTER key  
 	{ 0,				0				}, // 0E Undefined  
 	{ 0,				0				}, // 0F Undefined  
-	{ A_SHIFT,			A_SHIFT			}, // VK_SHIFT 10 SHIFT key  
-	{ A_CTRL,			A_CTRL			}, // VK_CONTROL 11 CTRL key  
-	{ A_ALT,			A_ALT			}, // VK_MENU 12 ALT key  
-	{ A_PAUSE,			A_PAUSE			}, // VK_PAUSE 13 PAUSE key  
-	{ A_CAPSLOCK,		A_CAPSLOCK		}, // VK_CAPITAL 14 CAPS LOCK key  
+	{ K_SHIFT,			K_SHIFT			}, // VK_SHIFT 10 SHIFT key  
+	{ K_CTRL,			K_CTRL			}, // VK_CONTROL 11 CTRL key  
+	{ K_ALT,			K_ALT			}, // VK_MENU 12 ALT key  
+	{ K_PAUSE,			K_PAUSE			}, // VK_PAUSE 13 PAUSE key  
+	{ K_CAPSLOCK,		K_CAPSLOCK		}, // VK_CAPITAL 14 CAPS LOCK key  
 	{ 0,				0				}, // VK_KANA 15 IME Kana mode 
 	{ 0,				0				}, // 16 Undefined  
 	{ 0,				0				}, // VK_JUNJA 17 IME Junja mode 
 	{ 0,				0				}, // VK_FINAL 18 IME final mode 
 	{ 0,				0				}, // VK_KANJI 19 IME Kanji mode 
 	{ 0,				0				}, // 1A Undefined  
-	{ A_ESCAPE,			A_ESCAPE		}, // VK_ESCAPE 1B ESC key  
+	{ K_ESCAPE,			K_ESCAPE		}, // VK_ESCAPE 1B ESC key  
 	{ 0,				0				}, // VK_CONVERT 1C IME convert 
 	{ 0,				0				}, // VK_NONCONVERT 1D IME nonconvert 
 	{ 0,				0				}, // VK_ACCEPT 1E IME accept 
 	{ 0,				0				}, // VK_MODECHANGE 1F IME mode change request 
-	{ A_SPACE,			A_SPACE			}, // VK_SPACE 20 SPACEBAR  
-	{ A_KP_9,			A_PAGE_UP		}, // VK_PRIOR 21 PAGE UP key  
-	{ A_KP_3,			A_PAGE_DOWN		}, // VK_NEXT 22 PAGE DOWN key  
-	{ A_KP_1,			A_END			}, // VK_END 23 END key  
-	{ A_KP_7,			A_HOME			}, // VK_HOME 24 HOME key  
-	{ A_KP_4,			A_CURSOR_LEFT	}, // VK_LEFT 25 LEFT ARROW key  
-	{ A_KP_8,			A_CURSOR_UP   	}, // VK_UP 26 UP ARROW key  
-	{ A_KP_6,			A_CURSOR_RIGHT	}, // VK_RIGHT 27 RIGHT ARROW key  
-	{ A_KP_2,			A_CURSOR_DOWN	}, // VK_DOWN 28 DOWN ARROW key  
+	{ K_SPACE,			K_SPACE			}, // VK_SPACE 20 SPACEBAR  
+	{ K_KP_PGUP,		K_PGUP			}, // VK_PRIOR 21 PAGE UP key  
+	{ K_KP_PGDN,		K_PGDN			}, // VK_NEXT 22 PAGE DOWN key  
+	{ K_KP_END,			K_END			}, // VK_END 23 END key  
+	{ K_KP_HOME,		K_HOME			}, // VK_HOME 24 HOME key  
+	{ K_KP_LEFTARROW,	K_LEFTARROW		}, // VK_LEFT 25 LEFT ARROW key  
+	{ K_KP_UPARROW,		K_UPARROW   	}, // VK_UP 26 UP ARROW key  
+	{ K_KP_RIGHTARROW,	K_RIGHTARROW	}, // VK_RIGHT 27 RIGHT ARROW key  
+	{ K_KP_DOWNARROW,	K_DOWNARROW		}, // VK_DOWN 28 DOWN ARROW key  
 	{ 0,				0				}, // VK_SELECT 29 SELECT key  
 	{ 0,				0				}, // VK_PRINT 2A PRINT key 
 	{ 0,				0				}, // VK_EXECUTE 2B EXECUTE key  
-	{ A_PRINTSCREEN,	A_PRINTSCREEN	}, // VK_SNAPSHOT 2C PRINT SCREEN key  
-	{ A_KP_0,			A_INSERT		}, // VK_INSERT 2D INS key  
-	{ A_KP_PERIOD,		A_DELETE		}, // VK_DELETE 2E DEL key  
+	{ 0,				0				}, // VK_SNAPSHOT 2C PRINT SCREEN key  
+	{ K_KP_INS,			K_INS			}, // VK_INSERT 2D INS key  
+	{ K_KP_DEL,			K_DEL			}, // VK_DELETE 2E DEL key  
 	{ 0,				0				}, // VK_HELP 2F HELP key  
-	{ A_0,				A_0				}, // 30 0 key  
-	{ A_1,				A_1				}, // 31 1 key  
-	{ A_2,				A_2				}, // 32 2 key  
-	{ A_3,				A_3				}, // 33 3 key  
-	{ A_4,				A_4				}, // 34 4 key  
-	{ A_5,				A_5				}, // 35 5 key  
-	{ A_6,				A_6				}, // 36 6 key  
-	{ A_7,				A_7				}, // 37 7 key  
-	{ A_8,				A_8				}, // 38 8 key  
-	{ A_9,				A_9				}, // 39 9 key  
+	{ K_0,				K_0				}, // 30 0 key  
+	{ K_1,				K_1				}, // 31 1 key  
+	{ K_2,				K_2				}, // 32 2 key  
+	{ K_3,				K_3				}, // 33 3 key  
+	{ K_4,				K_4				}, // 34 4 key  
+	{ K_5,				K_5				}, // 35 5 key  
+	{ K_6,				K_6				}, // 36 6 key  
+	{ K_7,				K_7				}, // 37 7 key  
+	{ K_8,				K_8				}, // 38 8 key  
+	{ K_9,				K_9				}, // 39 9 key  
 	{ 0,				0				}, // 3A Undefined  
 	{ 0,				0				}, // 3B Undefined  
 	{ 0,				0				}, // 3C Undefined  
@@ -167,65 +167,65 @@ static byte virtualKeyConvert[0x92][2] =
 	{ 0,				0				}, // 3E Undefined  
 	{ 0,				0				}, // 3F Undefined  
 	{ 0,				0				}, // 40 Undefined  
-	{ A_CAP_A,			A_CAP_A			}, // 41 A key  
-	{ A_CAP_B,			A_CAP_B			}, // 42 B key  
-	{ A_CAP_C,			A_CAP_C			}, // 43 C key  
-	{ A_CAP_D,			A_CAP_D			}, // 44 D key  
-	{ A_CAP_E,			A_CAP_E			}, // 45 E key  
-	{ A_CAP_F,			A_CAP_F			}, // 46 F key  
-	{ A_CAP_G,			A_CAP_G			}, // 47 G key  
-	{ A_CAP_H,			A_CAP_H			}, // 48 H key  
-	{ A_CAP_I,			A_CAP_I			}, // 49 I key  
-	{ A_CAP_J,			A_CAP_J			}, // 4A J key  
-	{ A_CAP_K,			A_CAP_K			}, // 4B K key  
-	{ A_CAP_L,			A_CAP_L			}, // 4C L key  
-	{ A_CAP_M,			A_CAP_M			}, // 4D M key  
-	{ A_CAP_N,			A_CAP_N			}, // 4E N key  
-	{ A_CAP_O,			A_CAP_O			}, // 4F O key  
-	{ A_CAP_P,			A_CAP_P			}, // 50 P key  
-	{ A_CAP_Q,			A_CAP_Q			}, // 51 Q key  
-	{ A_CAP_R,			A_CAP_R			}, // 52 R key  
-	{ A_CAP_S,			A_CAP_S			}, // 53 S key  
-	{ A_CAP_T,			A_CAP_T			}, // 54 T key  
-	{ A_CAP_U,			A_CAP_U			}, // 55 U key  
-	{ A_CAP_V,			A_CAP_V			}, // 56 V key  
-	{ A_CAP_W,			A_CAP_W			}, // 57 W key  
-	{ A_CAP_X,			A_CAP_X			}, // 58 X key  
-	{ A_CAP_Y,			A_CAP_Y			}, // 59 Y key  
-	{ A_CAP_Z,			A_CAP_Z			}, // 5A Z key  
+	{ K_LOW_A,			K_LOW_A			}, // 41 A key  
+	{ K_LOW_B,			K_LOW_B			}, // 42 B key  
+	{ K_LOW_C,			K_LOW_C			}, // 43 C key  
+	{ K_LOW_D,			K_LOW_D			}, // 44 D key  
+	{ K_LOW_E,			K_LOW_E			}, // 45 E key  
+	{ K_LOW_F,			K_LOW_F			}, // 46 F key  
+	{ K_LOW_G,			K_LOW_G			}, // 47 G key  
+	{ K_LOW_H,			K_LOW_H			}, // 48 H key  
+	{ K_LOW_I,			K_LOW_I			}, // 49 I key  
+	{ K_LOW_J,			K_LOW_J			}, // 4A J key  
+	{ K_LOW_K,			K_LOW_K			}, // 4B K key  
+	{ K_LOW_L,			K_LOW_L			}, // 4C L key  
+	{ K_LOW_M,			K_LOW_M			}, // 4D M key  
+	{ K_LOW_N,			K_LOW_N			}, // 4E N key  
+	{ K_LOW_O,			K_LOW_O			}, // 4F O key  
+	{ K_LOW_P,			K_LOW_P			}, // 50 P key  
+	{ K_LOW_Q,			K_LOW_Q			}, // 51 Q key  
+	{ K_LOW_R,			K_LOW_R			}, // 52 R key  
+	{ K_LOW_S,			K_LOW_S			}, // 53 S key  
+	{ K_LOW_T,			K_LOW_T			}, // 54 T key  
+	{ K_LOW_U,			K_LOW_U			}, // 55 U key  
+	{ K_LOW_V,			K_LOW_V			}, // 56 V key  
+	{ K_LOW_W,			K_LOW_W			}, // 57 W key  
+	{ K_LOW_X,			K_LOW_X			}, // 58 X key  
+	{ K_LOW_Y,			K_LOW_Y			}, // 59 Y key  
+	{ K_LOW_Z,			K_LOW_Z			}, // 5A Z key  
 	{ 0,				0				}, // VK_LWIN 5B Left Windows key (Microsoft® Natural® keyboard)  
 	{ 0,				0				}, // VK_RWIN 5C Right Windows key (Natural keyboard)  
 	{ 0,				0				}, // VK_APPS 5D Applications key (Natural keyboard)  
 	{ 0,				0				}, // 5E Reserved  
 	{ 0,				0				}, // VK_SLEEP 5F Computer Sleep key 
-	{ A_KP_0,			A_KP_0			}, // VK_NUMPAD0 60 Numeric keypad 0 key  
-	{ A_KP_1,			A_KP_1			}, // VK_NUMPAD1 61 Numeric keypad 1 key  
-	{ A_KP_2,			A_KP_2			}, // VK_NUMPAD2 62 Numeric keypad 2 key  
-	{ A_KP_3,			A_KP_3			}, // VK_NUMPAD3 63 Numeric keypad 3 key  
-	{ A_KP_4,			A_KP_4			}, // VK_NUMPAD4 64 Numeric keypad 4 key  
-	{ A_KP_5,			A_KP_5			}, // VK_NUMPAD5 65 Numeric keypad 5 key  
-	{ A_KP_6,			A_KP_6			}, // VK_NUMPAD6 66 Numeric keypad 6 key  
-	{ A_KP_7,			A_KP_7			}, // VK_NUMPAD7 67 Numeric keypad 7 key  
-	{ A_KP_8,			A_KP_8			}, // VK_NUMPAD8 68 Numeric keypad 8 key  
-	{ A_KP_9,			A_KP_9			}, // VK_NUMPAD9 69 Numeric keypad 9 key  
-	{ A_MULTIPLY,		A_MULTIPLY		}, // VK_MULTIPLY 6A Multiply key  
-	{ A_KP_PLUS, 		A_KP_PLUS 		}, // VK_ADD 6B Add key  
+	{ K_0,				K_0				}, // VK_NUMPAD0 60 Numeric keypad 0 key  
+	{ K_1,				K_1				}, // VK_NUMPAD1 61 Numeric keypad 1 key  
+	{ K_2,				K_2				}, // VK_NUMPAD2 62 Numeric keypad 2 key  
+	{ K_3,				K_3				}, // VK_NUMPAD3 63 Numeric keypad 3 key  
+	{ K_4,				K_4				}, // VK_NUMPAD4 64 Numeric keypad 4 key  
+	{ K_5,				K_5				}, // VK_NUMPAD5 65 Numeric keypad 5 key  
+	{ K_6,				K_6				}, // VK_NUMPAD6 66 Numeric keypad 6 key  
+	{ K_7,				K_7				}, // VK_NUMPAD7 67 Numeric keypad 7 key  
+	{ K_8,				K_8				}, // VK_NUMPAD8 68 Numeric keypad 8 key  
+	{ K_9,				K_9				}, // VK_NUMPAD9 69 Numeric keypad 9 key  
+	{ K_KP_STAR,		K_KP_STAR		}, // VK_MULTIPLY 6A Multiply key  
+	{ K_KP_PLUS, 		K_KP_PLUS 		}, // VK_ADD 6B Add key  
 	{ 0,				0				}, // VK_SEPARATOR 6C Separator key  
-	{ A_KP_MINUS,		A_KP_MINUS		}, // VK_SUBTRACT 6D Subtract key  
-	{ A_KP_PERIOD,		A_KP_PERIOD		}, // VK_DECIMAL 6E Decimal key  
-	{ A_DIVIDE,			A_DIVIDE		}, // VK_DIVIDE 6F Divide key  
-	{ A_F1,				A_F1			}, // VK_F1 70 F1 key  
-	{ A_F2,				A_F2			}, // VK_F2 71 F2 key  
-	{ A_F3,				A_F3			}, // VK_F3 72 F3 key  
-	{ A_F4,				A_F4			}, // VK_F4 73 F4 key  
-	{ A_F5,				A_F5			}, // VK_F5 74 F5 key  
-	{ A_F6,				A_F6			}, // VK_F6 75 F6 key  
-	{ A_F7,				A_F7			}, // VK_F7 76 F7 key  
-	{ A_F8,				A_F8			}, // VK_F8 77 F8 key  
-	{ A_F9,				A_F9			}, // VK_F9 78 F9 key  
-	{ A_F10,			A_F10			}, // VK_F10 79 F10 key  
-	{ A_F11,			A_F11			}, // VK_F11 7A F11 key  
-	{ A_F12,			A_F12			}, // VK_F12 7B F12 key  
+	{ K_KP_MINUS,		K_KP_MINUS		}, // VK_SUBTRACT 6D Subtract key  
+	{ K_KP_DEL,			K_KP_DEL		}, // VK_DECIMAL 6E Decimal key  
+	{ K_KP_SLASH,		K_KP_SLASH		}, // VK_DIVIDE 6F Divide key  
+	{ K_F1,				K_F1			}, // VK_F1 70 F1 key  
+	{ K_F2,				K_F2			}, // VK_F2 71 F2 key  
+	{ K_F3,				K_F3			}, // VK_F3 72 F3 key  
+	{ K_F4,				K_F4			}, // VK_F4 73 F4 key  
+	{ K_F5,				K_F5			}, // VK_F5 74 F5 key  
+	{ K_F6,				K_F6			}, // VK_F6 75 F6 key  
+	{ K_F7,				K_F7			}, // VK_F7 76 F7 key  
+	{ K_F8,				K_F8			}, // VK_F8 77 F8 key  
+	{ K_F9,				K_F9			}, // VK_F9 78 F9 key  
+	{ K_F10,			K_F10			}, // VK_F10 79 F10 key  
+	{ K_F11,			K_F11			}, // VK_F11 7A F11 key  
+	{ K_F12,			K_F12			}, // VK_F12 7B F12 key  
 	{ 0,				0				}, // VK_F13 7C F13 key  
 	{ 0,				0				}, // VK_F14 7D F14 key  
 	{ 0,				0				}, // VK_F15 7E F15 key  
@@ -246,8 +246,8 @@ static byte virtualKeyConvert[0x92][2] =
 	{ 0,				0				}, // 8D Unassigned
 	{ 0,				0				}, // 8E Unassigned
 	{ 0,				0				}, // 8F Unassigned
-	{ A_NUMLOCK,		A_NUMLOCK		}, // VK_NUMLOCK 90 NUM LOCK key  
-	{ A_SCROLLLOCK,		A_SCROLLLOCK	}  // VK_SCROLL 91 
+	{ K_KP_NUMLOCK,		K_KP_NUMLOCK	}, // VK_NUMLOCK 90 NUM LOCK key  
+	{ 0,				0	}  // VK_SCROLL 91 
 };
 
 /*
@@ -265,7 +265,7 @@ static int MapKey (ulong key, word wParam)
 	scan = ( key >> 16 ) & 0xff;
 	if(scan == CONSOLE_SCAN_CODE)
 	{
-		return(A_CONSOLE);
+		return(K_CONSOLE);
 	}
 
 	// Try to convert the virtual key directly
@@ -324,13 +324,13 @@ LONG WINAPI MainWndProc (
 	{
 		if ( ( ( int ) wParam ) > 0 )
 		{
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_MWHEELUP, qtrue, 0, NULL );
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_MWHEELUP, qfalse, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELUP, qtrue, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELUP, qfalse, 0, NULL );
 		}
 		else
 		{
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_MWHEELDOWN, qtrue, 0, NULL );
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_MWHEELDOWN, qfalse, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELDOWN, qtrue, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELDOWN, qfalse, 0, NULL );
 		}
         return DefWindowProc (hWnd, uMsg, wParam, lParam);
 	}
@@ -345,13 +345,13 @@ LONG WINAPI MainWndProc (
 		//
 		if ( ( short ) HIWORD( wParam ) > 0 )
 		{
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_MWHEELUP, qtrue, 0, NULL );
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_MWHEELUP, qfalse, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELUP, qtrue, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELUP, qfalse, 0, NULL );
 		}
 		else
 		{
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_MWHEELDOWN, qtrue, 0, NULL );
-			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, A_MWHEELDOWN, qfalse, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELDOWN, qtrue, 0, NULL );
+			Sys_QueEvent( g_wv.sysMsgTime, SE_KEY, K_MWHEELDOWN, qfalse, 0, NULL );
 		}
 		break;
 
-- 
2.17.0

